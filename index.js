(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/axios/lib/helpers/bind.js
  var require_bind = __commonJS({
    "node_modules/axios/lib/helpers/bind.js"(exports, module) {
      "use strict";
      module.exports = function bind3(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };
    }
  });

  // node_modules/axios/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/axios/lib/utils.js"(exports, module) {
      "use strict";
      var bind3 = require_bind();
      var toString = Object.prototype.toString;
      function isArray(val) {
        return toString.call(val) === "[object Array]";
      }
      function isUndefined(val) {
        return typeof val === "undefined";
      }
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      function isArrayBuffer(val) {
        return toString.call(val) === "[object ArrayBuffer]";
      }
      function isFormData(val) {
        return typeof FormData !== "undefined" && val instanceof FormData;
      }
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && val.buffer instanceof ArrayBuffer;
        }
        return result;
      }
      function isString(val) {
        return typeof val === "string";
      }
      function isNumber2(val) {
        return typeof val === "number";
      }
      function isObject3(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject(val) {
        if (toString.call(val) !== "[object Object]") {
          return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }
      function isDate2(val) {
        return toString.call(val) === "[object Date]";
      }
      function isFile(val) {
        return toString.call(val) === "[object File]";
      }
      function isBlob(val) {
        return toString.call(val) === "[object Blob]";
      }
      function isFunction(val) {
        return toString.call(val) === "[object Function]";
      }
      function isStream(val) {
        return isObject3(val) && isFunction(val.pipe);
      }
      function isURLSearchParams(val) {
        return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach(obj, fn) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge() {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject(result[key]) && isPlainObject(val)) {
            result[key] = merge(result[key], val);
          } else if (isPlainObject(val)) {
            result[key] = merge({}, val);
          } else if (isArray(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }
      function extend3(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a[key] = bind3(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }
      function stripBOM(content) {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      module.exports = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber: isNumber2,
        isObject: isObject3,
        isPlainObject,
        isUndefined,
        isDate: isDate2,
        isFile,
        isBlob,
        isFunction,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge,
        extend: extend3,
        trim,
        stripBOM
      };
    }
  });

  // node_modules/axios/lib/helpers/buildURL.js
  var require_buildURL = __commonJS({
    "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      module.exports = function buildURL(url2, params, paramsSerializer) {
        if (!params) {
          return url2;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + "=" + encode(v));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url2.indexOf("#");
          if (hashmarkIndex !== -1) {
            url2 = url2.slice(0, hashmarkIndex);
          }
          url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url2;
      };
    }
  });

  // node_modules/axios/lib/core/InterceptorManager.js
  var require_InterceptorManager = __commonJS({
    "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function InterceptorManager() {
        this.handlers = [];
      }
      InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };
      module.exports = InterceptorManager;
    }
  });

  // node_modules/axios/lib/helpers/normalizeHeaderName.js
  var require_normalizeHeaderName = __commonJS({
    "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value2, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value2;
            delete headers[name];
          }
        });
      };
    }
  });

  // node_modules/axios/lib/core/enhanceError.js
  var require_enhanceError = __commonJS({
    "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
      "use strict";
      module.exports = function enhanceError(error, config, code, request, response) {
        error.config = config;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code
          };
        };
        return error;
      };
    }
  });

  // node_modules/axios/lib/core/createError.js
  var require_createError = __commonJS({
    "node_modules/axios/lib/core/createError.js"(exports, module) {
      "use strict";
      var enhanceError = require_enhanceError();
      module.exports = function createError(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config, code, request, response);
      };
    }
  });

  // node_modules/axios/lib/core/settle.js
  var require_settle = __commonJS({
    "node_modules/axios/lib/core/settle.js"(exports, module) {
      "use strict";
      var createError = require_createError();
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
        }
      };
    }
  });

  // node_modules/axios/lib/helpers/cookies.js
  var require_cookies = __commonJS({
    "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write(name, value2, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value2));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match2 ? decodeURIComponent(match2[3]) : null;
          },
          remove: function remove3(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove3() {
          }
        };
      }();
    }
  });

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  var require_isAbsoluteURL = __commonJS({
    "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
      "use strict";
      module.exports = function isAbsoluteURL(url2) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
      };
    }
  });

  // node_modules/axios/lib/helpers/combineURLs.js
  var require_combineURLs = __commonJS({
    "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
      "use strict";
      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
    }
  });

  // node_modules/axios/lib/core/buildFullPath.js
  var require_buildFullPath = __commonJS({
    "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
      "use strict";
      var isAbsoluteURL = require_isAbsoluteURL();
      var combineURLs = require_combineURLs();
      module.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };
    }
  });

  // node_modules/axios/lib/helpers/parseHeaders.js
  var require_parseHeaders = __commonJS({
    "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;
        if (!headers) {
          return parsed;
        }
        utils.forEach(headers.split("\n"), function parser(line) {
          i = line.indexOf(":");
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
    }
  });

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var require_isURLSameOrigin = __commonJS({
    "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url2) {
          var href = url2;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }();
    }
  });

  // node_modules/axios/lib/adapters/xhr.js
  var require_xhr = __commonJS({
    "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var settle = require_settle();
      var cookies = require_cookies();
      var buildURL = require_buildURL();
      var buildFullPath = require_buildFullPath();
      var parseHeaders = require_parseHeaders();
      var isURLSameOrigin = require_isURLSameOrigin();
      var createError = require_createError();
      module.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(resolve, reject, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError("Request aborted", config, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError("Network Error", config, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
            request = null;
          };
          if (utils.isStandardBrowserEnv()) {
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
          }
          if (config.cancelToken) {
            config.cancelToken.promise.then(function onCanceled(cancel) {
              if (!request) {
                return;
              }
              request.abort();
              reject(cancel);
              request = null;
            });
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
    }
  });

  // node_modules/axios/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/axios/lib/defaults.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var normalizeHeaderName = require_normalizeHeaderName();
      var enhanceError = require_enhanceError();
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value2) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value2;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = require_xhr();
        } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
          adapter = require_xhr();
        }
        return adapter;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils.trim(rawValue);
          } catch (e2) {
            if (e2.name !== "SyntaxError") {
              throw e2;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      var defaults = {
        transitional: {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        },
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest(data, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
            return data;
          }
          if (utils.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data.toString();
          }
          if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          var transitional = this.transitional;
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
            try {
              return JSON.parse(data);
            } catch (e2) {
              if (strictJSONParsing) {
                if (e2.name === "SyntaxError") {
                  throw enhanceError(e2, this, "E_JSON_PARSE");
                }
                throw e2;
              }
            }
          }
          return data;
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        }
      };
      defaults.headers = {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      };
      utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
        defaults.headers[method] = {};
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });
      module.exports = defaults;
    }
  });

  // node_modules/axios/lib/core/transformData.js
  var require_transformData = __commonJS({
    "node_modules/axios/lib/core/transformData.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var defaults = require_defaults();
      module.exports = function transformData(data, headers, fns) {
        var context = this || defaults;
        utils.forEach(fns, function transform2(fn) {
          data = fn.call(context, data, headers);
        });
        return data;
      };
    }
  });

  // node_modules/axios/lib/cancel/isCancel.js
  var require_isCancel = __commonJS({
    "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
      "use strict";
      module.exports = function isCancel(value2) {
        return !!(value2 && value2.__CANCEL__);
      };
    }
  });

  // node_modules/axios/lib/core/dispatchRequest.js
  var require_dispatchRequest = __commonJS({
    "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var transformData = require_transformData();
      var isCancel = require_isCancel();
      var defaults = require_defaults();
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
      }
      module.exports = function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = config.headers || {};
        config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
        config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
        utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
          delete config.headers[method];
        });
        var adapter = config.adapter || defaults.adapter;
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
            }
          }
          return Promise.reject(reason);
        });
      };
    }
  });

  // node_modules/axios/lib/core/mergeConfig.js
  var require_mergeConfig = __commonJS({
    "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = function mergeConfig(config1, config2) {
        config2 = config2 || {};
        var config = {};
        var valueFromConfig2Keys = ["url", "method", "data"];
        var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
        var defaultToConfig2Keys = [
          "baseURL",
          "transformRequest",
          "transformResponse",
          "paramsSerializer",
          "timeout",
          "timeoutMessage",
          "withCredentials",
          "adapter",
          "responseType",
          "xsrfCookieName",
          "xsrfHeaderName",
          "onUploadProgress",
          "onDownloadProgress",
          "decompress",
          "maxContentLength",
          "maxBodyLength",
          "maxRedirects",
          "transport",
          "httpAgent",
          "httpsAgent",
          "cancelToken",
          "socketPath",
          "responseEncoding"
        ];
        var directMergeKeys = ["validateStatus"];
        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(void 0, config1[prop]);
          }
        }
        utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(void 0, config2[prop]);
          }
        });
        utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
        utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(void 0, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(void 0, config1[prop]);
          }
        });
        utils.forEach(directMergeKeys, function merge(prop) {
          if (prop in config2) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            config[prop] = getMergedValue(void 0, config1[prop]);
          }
        });
        var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
        var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });
        utils.forEach(otherKeys, mergeDeepProperties);
        return config;
      };
    }
  });

  // node_modules/axios/package.json
  var require_package = __commonJS({
    "node_modules/axios/package.json"(exports, module) {
      module.exports = {
        name: "axios",
        version: "0.21.4",
        description: "Promise based HTTP client for the browser and node.js",
        main: "index.js",
        scripts: {
          test: "grunt test",
          start: "node ./sandbox/server.js",
          build: "NODE_ENV=production grunt build",
          preversion: "npm test",
          version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
          postversion: "git push && git push --tags",
          examples: "node ./examples/server.js",
          coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
          fix: "eslint --fix lib/**/*.js"
        },
        repository: {
          type: "git",
          url: "https://github.com/axios/axios.git"
        },
        keywords: [
          "xhr",
          "http",
          "ajax",
          "promise",
          "node"
        ],
        author: "Matt Zabriskie",
        license: "MIT",
        bugs: {
          url: "https://github.com/axios/axios/issues"
        },
        homepage: "https://axios-http.com",
        devDependencies: {
          coveralls: "^3.0.0",
          "es6-promise": "^4.2.4",
          grunt: "^1.3.0",
          "grunt-banner": "^0.6.0",
          "grunt-cli": "^1.2.0",
          "grunt-contrib-clean": "^1.1.0",
          "grunt-contrib-watch": "^1.0.0",
          "grunt-eslint": "^23.0.0",
          "grunt-karma": "^4.0.0",
          "grunt-mocha-test": "^0.13.3",
          "grunt-ts": "^6.0.0-beta.19",
          "grunt-webpack": "^4.0.2",
          "istanbul-instrumenter-loader": "^1.0.0",
          "jasmine-core": "^2.4.1",
          karma: "^6.3.2",
          "karma-chrome-launcher": "^3.1.0",
          "karma-firefox-launcher": "^2.1.0",
          "karma-jasmine": "^1.1.1",
          "karma-jasmine-ajax": "^0.1.13",
          "karma-safari-launcher": "^1.0.0",
          "karma-sauce-launcher": "^4.3.6",
          "karma-sinon": "^1.0.5",
          "karma-sourcemap-loader": "^0.3.8",
          "karma-webpack": "^4.0.2",
          "load-grunt-tasks": "^3.5.2",
          minimist: "^1.2.0",
          mocha: "^8.2.1",
          sinon: "^4.5.0",
          "terser-webpack-plugin": "^4.2.3",
          typescript: "^4.0.5",
          "url-search-params": "^0.10.0",
          webpack: "^4.44.2",
          "webpack-dev-server": "^3.11.0"
        },
        browser: {
          "./lib/adapters/http.js": "./lib/adapters/xhr.js"
        },
        jsdelivr: "dist/axios.min.js",
        unpkg: "dist/axios.min.js",
        typings: "./index.d.ts",
        dependencies: {
          "follow-redirects": "^1.14.0"
        },
        bundlesize: [
          {
            path: "./dist/axios.min.js",
            threshold: "5kB"
          }
        ]
      };
    }
  });

  // node_modules/axios/lib/helpers/validator.js
  var require_validator = __commonJS({
    "node_modules/axios/lib/helpers/validator.js"(exports, module) {
      "use strict";
      var pkg = require_package();
      var validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
        validators[type] = function validator(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      var deprecatedWarnings = {};
      var currentVerArr = pkg.version.split(".");
      function isOlderVersion(version, thanVersion) {
        var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
        var destVer = version.split(".");
        for (var i = 0; i < 3; i++) {
          if (pkgVersionArr[i] > destVer[i]) {
            return true;
          } else if (pkgVersionArr[i] < destVer[i]) {
            return false;
          }
        }
        return false;
      }
      validators.transitional = function transitional(validator, version, message) {
        var isDeprecated = version && isOlderVersion(version);
        function formatMessage(opt, desc) {
          return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return function(value2, opt, opts) {
          if (validator === false) {
            throw new Error(formatMessage(opt, " has been removed in " + version));
          }
          if (isDeprecated && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
          }
          return validator ? validator(value2, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var i = keys.length;
        while (i-- > 0) {
          var opt = keys[i];
          var validator = schema[opt];
          if (validator) {
            var value2 = options[opt];
            var result = value2 === void 0 || validator(value2, opt, options);
            if (result !== true) {
              throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
          }
        }
      }
      module.exports = {
        isOlderVersion,
        assertOptions,
        validators
      };
    }
  });

  // node_modules/axios/lib/core/Axios.js
  var require_Axios = __commonJS({
    "node_modules/axios/lib/core/Axios.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var buildURL = require_buildURL();
      var InterceptorManager = require_InterceptorManager();
      var dispatchRequest = require_dispatchRequest();
      var mergeConfig = require_mergeConfig();
      var validator = require_validator();
      var validators = validator.validators;
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      Axios.prototype.request = function request(config) {
        if (typeof config === "string") {
          config = arguments[1] || {};
          config.url = arguments[0];
        } else {
          config = config || {};
        }
        config = mergeConfig(this.defaults, config);
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = "get";
        }
        var transitional = config.transitional;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
            forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
            clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios.prototype.getUri = function getUri(config) {
        config = mergeConfig(this.defaults, config);
        return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
      };
      utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url2, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url: url2,
            data: (config || {}).data
          }));
        };
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        Axios.prototype[method] = function(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url: url2,
            data
          }));
        };
      });
      module.exports = Axios;
    }
  });

  // node_modules/axios/lib/cancel/Cancel.js
  var require_Cancel = __commonJS({
    "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
      "use strict";
      function Cancel(message) {
        this.message = message;
      }
      Cancel.prototype.toString = function toString() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel.prototype.__CANCEL__ = true;
      module.exports = Cancel;
    }
  });

  // node_modules/axios/lib/cancel/CancelToken.js
  var require_CancelToken = __commonJS({
    "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
      "use strict";
      var Cancel = require_Cancel();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token = this;
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new Cancel(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      };
      module.exports = CancelToken;
    }
  });

  // node_modules/axios/lib/helpers/spread.js
  var require_spread = __commonJS({
    "node_modules/axios/lib/helpers/spread.js"(exports, module) {
      "use strict";
      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    }
  });

  // node_modules/axios/lib/helpers/isAxiosError.js
  var require_isAxiosError = __commonJS({
    "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
      "use strict";
      module.exports = function isAxiosError(payload) {
        return typeof payload === "object" && payload.isAxiosError === true;
      };
    }
  });

  // node_modules/axios/lib/axios.js
  var require_axios = __commonJS({
    "node_modules/axios/lib/axios.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var bind3 = require_bind();
      var Axios = require_Axios();
      var mergeConfig = require_mergeConfig();
      var defaults = require_defaults();
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind3(Axios.prototype.request, context);
        utils.extend(instance, Axios.prototype, context);
        utils.extend(instance, context);
        return instance;
      }
      var axios15 = createInstance(defaults);
      axios15.Axios = Axios;
      axios15.create = function create(instanceConfig) {
        return createInstance(mergeConfig(axios15.defaults, instanceConfig));
      };
      axios15.Cancel = require_Cancel();
      axios15.CancelToken = require_CancelToken();
      axios15.isCancel = require_isCancel();
      axios15.all = function all(promises) {
        return Promise.all(promises);
      };
      axios15.spread = require_spread();
      axios15.isAxiosError = require_isAxiosError();
      module.exports = axios15;
      module.exports.default = axios15;
    }
  });

  // node_modules/axios/index.js
  var require_axios2 = __commonJS({
    "node_modules/axios/index.js"(exports, module) {
      module.exports = require_axios();
    }
  });

  // node_modules/debounce/index.js
  var require_debounce = __commonJS({
    "node_modules/debounce/index.js"(exports, module) {
      function debounce5(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        if (wait == null)
          wait = 100;
        function later() {
          var last = Date.now() - timestamp;
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              context = args = null;
            }
          }
        }
        ;
        var debounced = function() {
          context = this;
          args = arguments;
          timestamp = Date.now();
          var callNow = immediate && !timeout;
          if (!timeout)
            timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
          return result;
        };
        debounced.clear = function() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
        };
        debounced.flush = function() {
          if (timeout) {
            result = func.apply(context, args);
            context = args = null;
            clearTimeout(timeout);
            timeout = null;
          }
        };
        return debounced;
      }
      debounce5.debounce = debounce5;
      module.exports = debounce5;
    }
  });

  // node_modules/inputmask/dist/inputmask.js
  var require_inputmask = __commonJS({
    "node_modules/inputmask/dist/inputmask.js"(exports, module) {
      !function(e2, t) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = t();
        else if (typeof define == "function" && define.amd)
          define([], t);
        else {
          var i = t();
          for (var a in i)
            (typeof exports == "object" ? exports : e2)[a] = i[a];
        }
      }(self, function() {
        return function() {
          "use strict";
          var e2 = {
            8741: function(e3, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              var i2 = !(typeof window == "undefined" || !window.document || !window.document.createElement);
              t2.default = i2;
            },
            3976: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              var a2, n = (a2 = i2(5581)) && a2.__esModule ? a2 : {
                default: a2
              };
              var r = {
                _maxTestPos: 500,
                placeholder: "_",
                optionalmarker: ["[", "]"],
                quantifiermarker: ["{", "}"],
                groupmarker: ["(", ")"],
                alternatormarker: "|",
                escapeChar: "\\",
                mask: null,
                regex: null,
                oncomplete: function() {
                },
                onincomplete: function() {
                },
                oncleared: function() {
                },
                repeat: 0,
                greedy: false,
                autoUnmask: false,
                removeMaskOnSubmit: false,
                clearMaskOnLostFocus: true,
                insertMode: true,
                insertModeVisual: true,
                clearIncomplete: false,
                alias: null,
                onKeyDown: function() {
                },
                onBeforeMask: null,
                onBeforePaste: function(e4, t3) {
                  return typeof t3.onBeforeMask == "function" ? t3.onBeforeMask.call(this, e4, t3) : e4;
                },
                onBeforeWrite: null,
                onUnMask: null,
                showMaskOnFocus: true,
                showMaskOnHover: true,
                onKeyValidation: function() {
                },
                skipOptionalPartCharacter: " ",
                numericInput: false,
                rightAlign: false,
                undoOnEscape: true,
                radixPoint: "",
                _radixDance: false,
                groupSeparator: "",
                keepStatic: null,
                positionCaretOnTab: true,
                tabThrough: false,
                supportsInputType: ["text", "tel", "url", "password", "search"],
                ignorables: [n.default.BACKSPACE, n.default.TAB, n.default["PAUSE/BREAK"], n.default.ESCAPE, n.default.PAGE_UP, n.default.PAGE_DOWN, n.default.END, n.default.HOME, n.default.LEFT, n.default.UP, n.default.RIGHT, n.default.DOWN, n.default.INSERT, n.default.DELETE, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],
                isComplete: null,
                preValidation: null,
                postValidation: null,
                staticDefinitionSymbol: void 0,
                jitMasking: false,
                nullable: true,
                inputEventOnly: false,
                noValuePatching: false,
                positionCaretOnClick: "lvp",
                casing: null,
                inputmode: "text",
                importDataAttributes: true,
                shiftPositions: true,
                usePrototypeDefinitions: true,
                validationEventTimeOut: 3e3,
                substitutes: {}
              };
              t2.default = r;
            },
            7392: function(e3, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              t2.default = {
                9: {
                  validator: "[0-9\uFF10-\uFF19]",
                  definitionSymbol: "*"
                },
                a: {
                  validator: "[A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]",
                  definitionSymbol: "*"
                },
                "*": {
                  validator: "[0-9\uFF10-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]"
                }
              };
            },
            253: function(e3, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = function(e4, t3, i2) {
                if (i2 === void 0)
                  return e4.__data ? e4.__data[t3] : null;
                e4.__data = e4.__data || {}, e4.__data[t3] = i2;
              };
            },
            3776: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.Event = void 0, t2.off = function(e4, t3) {
                var i3, a3;
                function n2(e5, t4, n3) {
                  if (e5 in i3 == true)
                    if (a3.removeEventListener ? a3.removeEventListener(e5, n3, false) : a3.detachEvent && a3.detachEvent("on" + e5, n3), t4 === "global")
                      for (var r3 in i3[e5])
                        i3[e5][r3].splice(i3[e5][r3].indexOf(n3), 1);
                    else
                      i3[e5][t4].splice(i3[e5][t4].indexOf(n3), 1);
                }
                function r2(e5, a4) {
                  var n3, r3, o3 = [];
                  if (e5.length > 0)
                    if (t3 === void 0)
                      for (n3 = 0, r3 = i3[e5][a4].length; n3 < r3; n3++)
                        o3.push({
                          ev: e5,
                          namespace: a4 && a4.length > 0 ? a4 : "global",
                          handler: i3[e5][a4][n3]
                        });
                    else
                      o3.push({
                        ev: e5,
                        namespace: a4 && a4.length > 0 ? a4 : "global",
                        handler: t3
                      });
                  else if (a4.length > 0) {
                    for (var l3 in i3)
                      for (var s3 in i3[l3])
                        if (s3 === a4)
                          if (t3 === void 0)
                            for (n3 = 0, r3 = i3[l3][s3].length; n3 < r3; n3++)
                              o3.push({
                                ev: l3,
                                namespace: s3,
                                handler: i3[l3][s3][n3]
                              });
                          else
                            o3.push({
                              ev: l3,
                              namespace: s3,
                              handler: t3
                            });
                  }
                  return o3;
                }
                if (u(this[0]) && e4) {
                  i3 = this[0].eventRegistry, a3 = this[0];
                  for (var o2 = e4.split(" "), l2 = 0; l2 < o2.length; l2++)
                    for (var s2 = o2[l2].split("."), c = r2(s2[0], s2[1]), f = 0, d = c.length; f < d; f++)
                      n2(c[f].ev, c[f].namespace, c[f].handler);
                }
                return this;
              }, t2.on = function(e4, t3) {
                function i3(e5, i4) {
                  n2.addEventListener ? n2.addEventListener(e5, t3, false) : n2.attachEvent && n2.attachEvent("on" + e5, t3), a3[e5] = a3[e5] || {}, a3[e5][i4] = a3[e5][i4] || [], a3[e5][i4].push(t3);
                }
                if (u(this[0]))
                  for (var a3 = this[0].eventRegistry, n2 = this[0], r2 = e4.split(" "), o2 = 0; o2 < r2.length; o2++) {
                    var l2 = r2[o2].split("."), s2 = l2[0], c = l2[1] || "global";
                    i3(s2, c);
                  }
                return this;
              }, t2.trigger = function(e4) {
                if (u(this[0]))
                  for (var t3 = this[0].eventRegistry, i3 = this[0], a3 = typeof e4 == "string" ? e4.split(" ") : [e4.type], r2 = 0; r2 < a3.length; r2++) {
                    var l2 = a3[r2].split("."), s2 = l2[0], c = l2[1] || "global";
                    if (document !== void 0 && c === "global") {
                      var f, d, p = {
                        bubbles: true,
                        cancelable: true,
                        detail: arguments[1]
                      };
                      if (document.createEvent) {
                        try {
                          if (s2 === "input")
                            p.inputType = "insertText", f = new InputEvent(s2, p);
                          else
                            f = new CustomEvent(s2, p);
                        } catch (e5) {
                          (f = document.createEvent("CustomEvent")).initCustomEvent(s2, p.bubbles, p.cancelable, p.detail);
                        }
                        e4.type && (0, n.default)(f, e4), i3.dispatchEvent(f);
                      } else
                        (f = document.createEventObject()).eventType = s2, f.detail = arguments[1], e4.type && (0, n.default)(f, e4), i3.fireEvent("on" + f.eventType, f);
                    } else if (t3[s2] !== void 0)
                      if (arguments[0] = arguments[0].type ? arguments[0] : o.default.Event(arguments[0]), arguments[0].detail = arguments.slice(1), c === "global")
                        for (var h in t3[s2])
                          for (d = 0; d < t3[s2][h].length; d++)
                            t3[s2][h][d].apply(i3, arguments);
                      else
                        for (d = 0; d < t3[s2][c].length; d++)
                          t3[s2][c][d].apply(i3, arguments);
                  }
                return this;
              };
              var a2, n = s(i2(600)), r = s(i2(9380)), o = s(i2(4963)), l = s(i2(8741));
              function s(e4) {
                return e4 && e4.__esModule ? e4 : {
                  default: e4
                };
              }
              function u(e4) {
                return e4 instanceof Element;
              }
              t2.Event = a2, typeof r.default.CustomEvent == "function" ? t2.Event = a2 = r.default.CustomEvent : l.default && (t2.Event = a2 = function(e4, t3) {
                t3 = t3 || {
                  bubbles: false,
                  cancelable: false,
                  detail: void 0
                };
                var i3 = document.createEvent("CustomEvent");
                return i3.initCustomEvent(e4, t3.bubbles, t3.cancelable, t3.detail), i3;
              }, a2.prototype = r.default.Event.prototype);
            },
            600: function(e3, t2) {
              function i2(e4) {
                return i2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e5) {
                  return typeof e5;
                } : function(e5) {
                  return e5 && typeof Symbol == "function" && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                }, i2(e4);
              }
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = function e4() {
                var t3, a2, n, r, o, l, s = arguments[0] || {}, u = 1, c = arguments.length, f = false;
                typeof s == "boolean" && (f = s, s = arguments[u] || {}, u++);
                i2(s) !== "object" && typeof s != "function" && (s = {});
                for (; u < c; u++)
                  if ((t3 = arguments[u]) != null)
                    for (a2 in t3)
                      n = s[a2], r = t3[a2], s !== r && (f && r && (Object.prototype.toString.call(r) === "[object Object]" || (o = Array.isArray(r))) ? (o ? (o = false, l = n && Array.isArray(n) ? n : []) : l = n && Object.prototype.toString.call(n) === "[object Object]" ? n : {}, s[a2] = e4(f, l, r)) : r !== void 0 && (s[a2] = r));
                return s;
              };
            },
            4963: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              var a2 = l(i2(600)), n = l(i2(9380)), r = l(i2(253)), o = i2(3776);
              function l(e4) {
                return e4 && e4.__esModule ? e4 : {
                  default: e4
                };
              }
              var s = n.default.document;
              function u(e4) {
                return e4 instanceof u ? e4 : this instanceof u ? void (e4 != null && e4 !== n.default && (this[0] = e4.nodeName ? e4 : e4[0] !== void 0 && e4[0].nodeName ? e4[0] : s.querySelector(e4), this[0] !== void 0 && this[0] !== null && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new u(e4);
              }
              u.prototype = {
                on: o.on,
                off: o.off,
                trigger: o.trigger
              }, u.extend = a2.default, u.data = r.default, u.Event = o.Event;
              var c = u;
              t2.default = c;
            },
            9845: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.ua = t2.mobile = t2.iphone = t2.iemobile = t2.ie = void 0;
              var a2, n = (a2 = i2(9380)) && a2.__esModule ? a2 : {
                default: a2
              };
              var r = n.default.navigator && n.default.navigator.userAgent || "", o = r.indexOf("MSIE ") > 0 || r.indexOf("Trident/") > 0, l = "ontouchstart" in n.default, s = /iemobile/i.test(r), u = /iphone/i.test(r) && !s;
              t2.iphone = u, t2.iemobile = s, t2.mobile = l, t2.ie = o, t2.ua = r;
            },
            7184: function(e3, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = function(e4) {
                return e4.replace(i2, "\\$1");
              };
              var i2 = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim");
            },
            6030: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.EventHandlers = void 0;
              var a2, n = i2(8711), r = (a2 = i2(5581)) && a2.__esModule ? a2 : {
                default: a2
              }, o = i2(9845), l = i2(7215), s = i2(7760), u = i2(4713);
              function c(e4, t3) {
                var i3 = typeof Symbol != "undefined" && e4[Symbol.iterator] || e4["@@iterator"];
                if (!i3) {
                  if (Array.isArray(e4) || (i3 = function(e5, t4) {
                    if (!e5)
                      return;
                    if (typeof e5 == "string")
                      return f(e5, t4);
                    var i4 = Object.prototype.toString.call(e5).slice(8, -1);
                    i4 === "Object" && e5.constructor && (i4 = e5.constructor.name);
                    if (i4 === "Map" || i4 === "Set")
                      return Array.from(e5);
                    if (i4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4))
                      return f(e5, t4);
                  }(e4)) || t3 && e4 && typeof e4.length == "number") {
                    i3 && (e4 = i3);
                    var a3 = 0, n2 = function() {
                    };
                    return {
                      s: n2,
                      n: function() {
                        return a3 >= e4.length ? {
                          done: true
                        } : {
                          done: false,
                          value: e4[a3++]
                        };
                      },
                      e: function(e5) {
                        throw e5;
                      },
                      f: n2
                    };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var r2, o2 = true, l2 = false;
                return {
                  s: function() {
                    i3 = i3.call(e4);
                  },
                  n: function() {
                    var e5 = i3.next();
                    return o2 = e5.done, e5;
                  },
                  e: function(e5) {
                    l2 = true, r2 = e5;
                  },
                  f: function() {
                    try {
                      o2 || i3.return == null || i3.return();
                    } finally {
                      if (l2)
                        throw r2;
                    }
                  }
                };
              }
              function f(e4, t3) {
                (t3 == null || t3 > e4.length) && (t3 = e4.length);
                for (var i3 = 0, a3 = new Array(t3); i3 < t3; i3++)
                  a3[i3] = e4[i3];
                return a3;
              }
              var d = {
                keydownEvent: function(e4) {
                  var t3 = this.inputmask, i3 = t3.opts, a3 = t3.dependencyLib, c2 = t3.maskset, f2 = this, d2 = a3(f2), p = e4.keyCode, h = n.caret.call(t3, f2), v = i3.onKeyDown.call(this, e4, n.getBuffer.call(t3), h, i3);
                  if (v !== void 0)
                    return v;
                  if (p === r.default.BACKSPACE || p === r.default.DELETE || o.iphone && p === r.default.BACKSPACE_SAFARI || e4.ctrlKey && p === r.default.X && !("oncut" in f2))
                    e4.preventDefault(), l.handleRemove.call(t3, f2, p, h), (0, s.writeBuffer)(f2, n.getBuffer.call(t3, true), c2.p, e4, f2.inputmask._valueGet() !== n.getBuffer.call(t3).join(""));
                  else if (p === r.default.END || p === r.default.PAGE_DOWN) {
                    e4.preventDefault();
                    var m = n.seekNext.call(t3, n.getLastValidPosition.call(t3));
                    n.caret.call(t3, f2, e4.shiftKey ? h.begin : m, m, true);
                  } else
                    p === r.default.HOME && !e4.shiftKey || p === r.default.PAGE_UP ? (e4.preventDefault(), n.caret.call(t3, f2, 0, e4.shiftKey ? h.begin : 0, true)) : i3.undoOnEscape && p === r.default.ESCAPE && e4.altKey !== true ? ((0, s.checkVal)(f2, true, false, t3.undoValue.split("")), d2.trigger("click")) : p !== r.default.INSERT || e4.shiftKey || e4.ctrlKey || t3.userOptions.insertMode !== void 0 ? i3.tabThrough === true && p === r.default.TAB ? e4.shiftKey === true ? (h.end = n.seekPrevious.call(t3, h.end, true), u.getTest.call(t3, h.end - 1).match.static === true && h.end--, h.begin = n.seekPrevious.call(t3, h.end, true), h.begin >= 0 && h.end > 0 && (e4.preventDefault(), n.caret.call(t3, f2, h.begin, h.end))) : (h.begin = n.seekNext.call(t3, h.begin, true), h.end = n.seekNext.call(t3, h.begin, true), h.end < c2.maskLength && h.end--, h.begin <= c2.maskLength && (e4.preventDefault(), n.caret.call(t3, f2, h.begin, h.end))) : e4.shiftKey || i3.insertModeVisual && i3.insertMode === false && (p === r.default.RIGHT ? setTimeout(function() {
                      var e5 = n.caret.call(t3, f2);
                      n.caret.call(t3, f2, e5.begin);
                    }, 0) : p === r.default.LEFT && setTimeout(function() {
                      var e5 = n.translatePosition.call(t3, f2.inputmask.caretPos.begin);
                      n.translatePosition.call(t3, f2.inputmask.caretPos.end);
                      t3.isRTL ? n.caret.call(t3, f2, e5 + (e5 === c2.maskLength ? 0 : 1)) : n.caret.call(t3, f2, e5 - (e5 === 0 ? 0 : 1));
                    }, 0)) : l.isSelection.call(t3, h) ? i3.insertMode = !i3.insertMode : (i3.insertMode = !i3.insertMode, n.caret.call(t3, f2, h.begin, h.begin));
                  t3.ignorable = i3.ignorables.includes(p);
                },
                keypressEvent: function(e4, t3, i3, a3, o2) {
                  var u2 = this.inputmask || this, c2 = u2.opts, f2 = u2.dependencyLib, d2 = u2.maskset, p = u2.el, h = f2(p), v = e4.keyCode;
                  if (!(t3 === true || e4.ctrlKey && e4.altKey) && (e4.ctrlKey || e4.metaKey || u2.ignorable))
                    return v === r.default.ENTER && u2.undoValue !== u2._valueGet(true) && (u2.undoValue = u2._valueGet(true), setTimeout(function() {
                      h.trigger("change");
                    }, 0)), u2.skipInputEvent = true, true;
                  if (v) {
                    v !== 44 && v !== 46 || e4.location !== 3 || c2.radixPoint === "" || (v = c2.radixPoint.charCodeAt(0));
                    var m, g = t3 ? {
                      begin: o2,
                      end: o2
                    } : n.caret.call(u2, p), k = String.fromCharCode(v);
                    k = c2.substitutes[k] || k, d2.writeOutBuffer = true;
                    var y = l.isValid.call(u2, g, k, a3, void 0, void 0, void 0, t3);
                    if (y !== false && (n.resetMaskSet.call(u2, true), m = y.caret !== void 0 ? y.caret : n.seekNext.call(u2, y.pos.begin ? y.pos.begin : y.pos), d2.p = m), m = c2.numericInput && y.caret === void 0 ? n.seekPrevious.call(u2, m) : m, i3 !== false && (setTimeout(function() {
                      c2.onKeyValidation.call(p, v, y);
                    }, 0), d2.writeOutBuffer && y !== false)) {
                      var b = n.getBuffer.call(u2);
                      (0, s.writeBuffer)(p, b, m, e4, t3 !== true);
                    }
                    if (e4.preventDefault(), t3)
                      return y !== false && (y.forwardPosition = m), y;
                  }
                },
                keyupEvent: function(e4) {
                  var t3 = this.inputmask;
                  !t3.isComposing || e4.keyCode !== r.default.KEY_229 && e4.keyCode !== r.default.ENTER || t3.$el.trigger("input");
                },
                pasteEvent: function(e4) {
                  var t3, i3 = this.inputmask, a3 = i3.opts, r2 = i3._valueGet(true), o2 = n.caret.call(i3, this);
                  i3.isRTL && (t3 = o2.end, o2.end = n.translatePosition.call(i3, o2.begin), o2.begin = n.translatePosition.call(i3, t3));
                  var l2 = r2.substr(0, o2.begin), u2 = r2.substr(o2.end, r2.length);
                  if (l2 == (i3.isRTL ? n.getBufferTemplate.call(i3).slice().reverse() : n.getBufferTemplate.call(i3)).slice(0, o2.begin).join("") && (l2 = ""), u2 == (i3.isRTL ? n.getBufferTemplate.call(i3).slice().reverse() : n.getBufferTemplate.call(i3)).slice(o2.end).join("") && (u2 = ""), window.clipboardData && window.clipboardData.getData)
                    r2 = l2 + window.clipboardData.getData("Text") + u2;
                  else {
                    if (!e4.clipboardData || !e4.clipboardData.getData)
                      return true;
                    r2 = l2 + e4.clipboardData.getData("text/plain") + u2;
                  }
                  var f2 = r2;
                  if (i3.isRTL) {
                    f2 = f2.split("");
                    var d2, p = c(n.getBufferTemplate.call(i3));
                    try {
                      for (p.s(); !(d2 = p.n()).done; ) {
                        var h = d2.value;
                        f2[0] === h && f2.shift();
                      }
                    } catch (e5) {
                      p.e(e5);
                    } finally {
                      p.f();
                    }
                    f2 = f2.join("");
                  }
                  if (typeof a3.onBeforePaste == "function") {
                    if ((f2 = a3.onBeforePaste.call(i3, f2, a3)) === false)
                      return false;
                    f2 || (f2 = r2);
                  }
                  (0, s.checkVal)(this, true, false, f2.toString().split(""), e4), e4.preventDefault();
                },
                inputFallBackEvent: function(e4) {
                  var t3 = this.inputmask, i3 = t3.opts, a3 = t3.dependencyLib;
                  var l2 = this, c2 = l2.inputmask._valueGet(true), f2 = (t3.isRTL ? n.getBuffer.call(t3).slice().reverse() : n.getBuffer.call(t3)).join(""), p = n.caret.call(t3, l2, void 0, void 0, true);
                  if (f2 !== c2) {
                    c2 = function(e5, i4, a4) {
                      if (o.iemobile) {
                        var r2 = i4.replace(n.getBuffer.call(t3).join(""), "");
                        if (r2.length === 1) {
                          var l3 = i4.split("");
                          l3.splice(a4.begin, 0, r2), i4 = l3.join("");
                        }
                      }
                      return i4;
                    }(0, c2, p);
                    var h = function(e5, a4, r2) {
                      for (var o2, l3, s2, c3 = e5.substr(0, r2.begin).split(""), f3 = e5.substr(r2.begin).split(""), d2 = a4.substr(0, r2.begin).split(""), p2 = a4.substr(r2.begin).split(""), h2 = c3.length >= d2.length ? c3.length : d2.length, v2 = f3.length >= p2.length ? f3.length : p2.length, m = "", g = [], k = "~"; c3.length < h2; )
                        c3.push(k);
                      for (; d2.length < h2; )
                        d2.push(k);
                      for (; f3.length < v2; )
                        f3.unshift(k);
                      for (; p2.length < v2; )
                        p2.unshift(k);
                      var y = c3.concat(f3), b = d2.concat(p2);
                      for (l3 = 0, o2 = y.length; l3 < o2; l3++)
                        switch (s2 = u.getPlaceholder.call(t3, n.translatePosition.call(t3, l3)), m) {
                          case "insertText":
                            b[l3 - 1] === y[l3] && r2.begin == y.length - 1 && g.push(y[l3]), l3 = o2;
                            break;
                          case "insertReplacementText":
                          case "deleteContentBackward":
                            y[l3] === k ? r2.end++ : l3 = o2;
                            break;
                          default:
                            y[l3] !== b[l3] && (y[l3 + 1] !== k && y[l3 + 1] !== s2 && y[l3 + 1] !== void 0 || (b[l3] !== s2 || b[l3 + 1] !== k) && b[l3] !== k ? b[l3 + 1] === k && b[l3] === y[l3 + 1] ? (m = "insertText", g.push(y[l3]), r2.begin--, r2.end--) : y[l3] !== s2 && y[l3] !== k && (y[l3 + 1] === k || b[l3] !== y[l3] && b[l3 + 1] === y[l3 + 1]) ? (m = "insertReplacementText", g.push(y[l3]), r2.begin--) : y[l3] === k ? (m = "deleteContentBackward", (n.isMask.call(t3, n.translatePosition.call(t3, l3), true) || b[l3] === i3.radixPoint) && r2.end++) : l3 = o2 : (m = "insertText", g.push(y[l3]), r2.begin--, r2.end--));
                        }
                      return {
                        action: m,
                        data: g,
                        caret: r2
                      };
                    }(c2, f2, p);
                    switch ((l2.inputmask.shadowRoot || l2.ownerDocument).activeElement !== l2 && l2.focus(), (0, s.writeBuffer)(l2, n.getBuffer.call(t3)), n.caret.call(t3, l2, p.begin, p.end, true), h.action) {
                      case "insertText":
                      case "insertReplacementText":
                        h.data.forEach(function(e5, i4) {
                          var n2 = new a3.Event("keypress");
                          n2.keyCode = e5.charCodeAt(0), t3.ignorable = false, d.keypressEvent.call(l2, n2);
                        }), setTimeout(function() {
                          t3.$el.trigger("keyup");
                        }, 0);
                        break;
                      case "deleteContentBackward":
                        var v = new a3.Event("keydown");
                        v.keyCode = r.default.BACKSPACE, d.keydownEvent.call(l2, v);
                        break;
                      default:
                        (0, s.applyInputValue)(l2, c2);
                    }
                    e4.preventDefault();
                  }
                },
                compositionendEvent: function(e4) {
                  var t3 = this.inputmask;
                  t3.isComposing = false, t3.$el.trigger("input");
                },
                setValueEvent: function(e4) {
                  var t3 = this.inputmask, i3 = this, a3 = e4 && e4.detail ? e4.detail[0] : arguments[1];
                  a3 === void 0 && (a3 = i3.inputmask._valueGet(true)), (0, s.applyInputValue)(i3, a3), (e4.detail && e4.detail[1] !== void 0 || arguments[2] !== void 0) && n.caret.call(t3, i3, e4.detail ? e4.detail[1] : arguments[2]);
                },
                focusEvent: function(e4) {
                  var t3 = this.inputmask, i3 = t3.opts, a3 = this, r2 = a3.inputmask._valueGet();
                  i3.showMaskOnFocus && r2 !== n.getBuffer.call(t3).join("") && (0, s.writeBuffer)(a3, n.getBuffer.call(t3), n.seekNext.call(t3, n.getLastValidPosition.call(t3))), i3.positionCaretOnTab !== true || t3.mouseEnter !== false || l.isComplete.call(t3, n.getBuffer.call(t3)) && n.getLastValidPosition.call(t3) !== -1 || d.clickEvent.apply(a3, [e4, true]), t3.undoValue = t3._valueGet(true);
                },
                invalidEvent: function(e4) {
                  this.inputmask.validationEvent = true;
                },
                mouseleaveEvent: function() {
                  var e4 = this.inputmask, t3 = e4.opts, i3 = this;
                  e4.mouseEnter = false, t3.clearMaskOnLostFocus && (i3.inputmask.shadowRoot || i3.ownerDocument).activeElement !== i3 && (0, s.HandleNativePlaceholder)(i3, e4.originalPlaceholder);
                },
                clickEvent: function(e4, t3) {
                  var i3 = this.inputmask, a3 = this;
                  if ((a3.inputmask.shadowRoot || a3.ownerDocument).activeElement === a3) {
                    var r2 = n.determineNewCaretPosition.call(i3, n.caret.call(i3, a3), t3);
                    r2 !== void 0 && n.caret.call(i3, a3, r2);
                  }
                },
                cutEvent: function(e4) {
                  var t3 = this.inputmask, i3 = t3.maskset, a3 = this, o2 = n.caret.call(t3, a3), u2 = t3.isRTL ? n.getBuffer.call(t3).slice(o2.end, o2.begin) : n.getBuffer.call(t3).slice(o2.begin, o2.end), c2 = t3.isRTL ? u2.reverse().join("") : u2.join("");
                  window.navigator.clipboard ? window.navigator.clipboard.writeText(c2) : window.clipboardData && window.clipboardData.getData && window.clipboardData.setData("Text", c2), l.handleRemove.call(t3, a3, r.default.DELETE, o2), (0, s.writeBuffer)(a3, n.getBuffer.call(t3), i3.p, e4, t3.undoValue !== t3._valueGet(true));
                },
                blurEvent: function(e4) {
                  var t3 = this.inputmask, i3 = t3.opts, a3 = (0, t3.dependencyLib)(this), r2 = this;
                  if (r2.inputmask) {
                    (0, s.HandleNativePlaceholder)(r2, t3.originalPlaceholder);
                    var o2 = r2.inputmask._valueGet(), u2 = n.getBuffer.call(t3).slice();
                    o2 !== "" && (i3.clearMaskOnLostFocus && (n.getLastValidPosition.call(t3) === -1 && o2 === n.getBufferTemplate.call(t3).join("") ? u2 = [] : s.clearOptionalTail.call(t3, u2)), l.isComplete.call(t3, u2) === false && (setTimeout(function() {
                      a3.trigger("incomplete");
                    }, 0), i3.clearIncomplete && (n.resetMaskSet.call(t3), u2 = i3.clearMaskOnLostFocus ? [] : n.getBufferTemplate.call(t3).slice())), (0, s.writeBuffer)(r2, u2, void 0, e4)), t3.undoValue !== t3._valueGet(true) && (t3.undoValue = t3._valueGet(true), a3.trigger("change"));
                  }
                },
                mouseenterEvent: function() {
                  var e4 = this.inputmask, t3 = e4.opts, i3 = this;
                  if (e4.mouseEnter = true, (i3.inputmask.shadowRoot || i3.ownerDocument).activeElement !== i3) {
                    var a3 = (e4.isRTL ? n.getBufferTemplate.call(e4).slice().reverse() : n.getBufferTemplate.call(e4)).join("");
                    e4.placeholder !== a3 && i3.placeholder !== e4.originalPlaceholder && (e4.originalPlaceholder = i3.placeholder), t3.showMaskOnHover && (0, s.HandleNativePlaceholder)(i3, a3);
                  }
                },
                submitEvent: function() {
                  var e4 = this.inputmask, t3 = e4.opts;
                  e4.undoValue !== e4._valueGet(true) && e4.$el.trigger("change"), n.getLastValidPosition.call(e4) === -1 && e4._valueGet && e4._valueGet() === n.getBufferTemplate.call(e4).join("") && e4._valueSet(""), t3.clearIncomplete && l.isComplete.call(e4, n.getBuffer.call(e4)) === false && e4._valueSet(""), t3.removeMaskOnSubmit && (e4._valueSet(e4.unmaskedvalue(), true), setTimeout(function() {
                    (0, s.writeBuffer)(e4.el, n.getBuffer.call(e4));
                  }, 0));
                },
                resetEvent: function() {
                  var e4 = this.inputmask;
                  e4.refreshValue = true, setTimeout(function() {
                    (0, s.applyInputValue)(e4.el, e4._valueGet(true));
                  }, 0);
                }
              };
              t2.EventHandlers = d;
            },
            9716: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.EventRuler = void 0;
              var a2 = l(i2(2394)), n = l(i2(5581)), r = i2(8711), o = i2(7760);
              function l(e4) {
                return e4 && e4.__esModule ? e4 : {
                  default: e4
                };
              }
              var s = {
                on: function(e4, t3, i3) {
                  var l2 = e4.inputmask.dependencyLib, s2 = function(t4) {
                    t4.originalEvent && (t4 = t4.originalEvent || t4, arguments[0] = t4);
                    var s3, u = this, c = u.inputmask, f = c ? c.opts : void 0;
                    if (c === void 0 && this.nodeName !== "FORM") {
                      var d = l2.data(u, "_inputmask_opts");
                      l2(u).off(), d && new a2.default(d).mask(u);
                    } else {
                      if (["submit", "reset", "setvalue"].includes(t4.type) || this.nodeName === "FORM" || !(u.disabled || u.readOnly && !(t4.type === "keydown" && t4.ctrlKey && t4.keyCode === 67 || f.tabThrough === false && t4.keyCode === n.default.TAB))) {
                        switch (t4.type) {
                          case "input":
                            if (c.skipInputEvent === true || t4.inputType && t4.inputType === "insertCompositionText")
                              return c.skipInputEvent = false, t4.preventDefault();
                            break;
                          case "keydown":
                            c.skipKeyPressEvent = false, c.skipInputEvent = c.isComposing = t4.keyCode === n.default.KEY_229;
                            break;
                          case "keyup":
                          case "compositionend":
                            c.isComposing && (c.skipInputEvent = false);
                            break;
                          case "keypress":
                            if (c.skipKeyPressEvent === true)
                              return t4.preventDefault();
                            c.skipKeyPressEvent = true;
                            break;
                          case "click":
                          case "focus":
                            return c.validationEvent ? (c.validationEvent = false, e4.blur(), (0, o.HandleNativePlaceholder)(e4, (c.isRTL ? r.getBufferTemplate.call(c).slice().reverse() : r.getBufferTemplate.call(c)).join("")), setTimeout(function() {
                              e4.focus();
                            }, f.validationEventTimeOut), false) : (s3 = arguments, setTimeout(function() {
                              e4.inputmask && i3.apply(u, s3);
                            }, 0), false);
                        }
                        var p = i3.apply(u, arguments);
                        return p === false && (t4.preventDefault(), t4.stopPropagation()), p;
                      }
                      t4.preventDefault();
                    }
                  };
                  ["submit", "reset"].includes(t3) ? (s2 = s2.bind(e4), e4.form !== null && l2(e4.form).on(t3, s2)) : l2(e4).on(t3, s2), e4.inputmask.events[t3] = e4.inputmask.events[t3] || [], e4.inputmask.events[t3].push(s2);
                },
                off: function(e4, t3) {
                  if (e4.inputmask && e4.inputmask.events) {
                    var i3 = e4.inputmask.dependencyLib, a3 = e4.inputmask.events;
                    for (var n2 in t3 && ((a3 = [])[t3] = e4.inputmask.events[t3]), a3) {
                      for (var r2 = a3[n2]; r2.length > 0; ) {
                        var o2 = r2.pop();
                        ["submit", "reset"].includes(n2) ? e4.form !== null && i3(e4.form).off(n2, o2) : i3(e4).off(n2, o2);
                      }
                      delete e4.inputmask.events[n2];
                    }
                  }
                }
              };
              t2.EventRuler = s;
            },
            219: function(e3, t2, i2) {
              var a2 = d(i2(2394)), n = d(i2(5581)), r = d(i2(7184)), o = i2(8711), l = i2(4713);
              function s(e4) {
                return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e5) {
                  return typeof e5;
                } : function(e5) {
                  return e5 && typeof Symbol == "function" && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                }, s(e4);
              }
              function u(e4, t3) {
                return function(e5) {
                  if (Array.isArray(e5))
                    return e5;
                }(e4) || function(e5, t4) {
                  var i3 = e5 == null ? null : typeof Symbol != "undefined" && e5[Symbol.iterator] || e5["@@iterator"];
                  if (i3 == null)
                    return;
                  var a3, n2, r2 = [], o2 = true, l2 = false;
                  try {
                    for (i3 = i3.call(e5); !(o2 = (a3 = i3.next()).done) && (r2.push(a3.value), !t4 || r2.length !== t4); o2 = true)
                      ;
                  } catch (e6) {
                    l2 = true, n2 = e6;
                  } finally {
                    try {
                      o2 || i3.return == null || i3.return();
                    } finally {
                      if (l2)
                        throw n2;
                    }
                  }
                  return r2;
                }(e4, t3) || function(e5, t4) {
                  if (!e5)
                    return;
                  if (typeof e5 == "string")
                    return c(e5, t4);
                  var i3 = Object.prototype.toString.call(e5).slice(8, -1);
                  i3 === "Object" && e5.constructor && (i3 = e5.constructor.name);
                  if (i3 === "Map" || i3 === "Set")
                    return Array.from(e5);
                  if (i3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3))
                    return c(e5, t4);
                }(e4, t3) || function() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }();
              }
              function c(e4, t3) {
                (t3 == null || t3 > e4.length) && (t3 = e4.length);
                for (var i3 = 0, a3 = new Array(t3); i3 < t3; i3++)
                  a3[i3] = e4[i3];
                return a3;
              }
              function f(e4, t3) {
                for (var i3 = 0; i3 < t3.length; i3++) {
                  var a3 = t3[i3];
                  a3.enumerable = a3.enumerable || false, a3.configurable = true, "value" in a3 && (a3.writable = true), Object.defineProperty(e4, a3.key, a3);
                }
              }
              function d(e4) {
                return e4 && e4.__esModule ? e4 : {
                  default: e4
                };
              }
              var p = a2.default.dependencyLib, h = function() {
                function e4(t4, i4, a4) {
                  !function(e5, t5) {
                    if (!(e5 instanceof t5))
                      throw new TypeError("Cannot call a class as a function");
                  }(this, e4), this.mask = t4, this.format = i4, this.opts = a4, this._date = new Date(1, 0, 1), this.initDateObject(t4, this.opts);
                }
                var t3, i3, a3;
                return t3 = e4, (i3 = [{
                  key: "date",
                  get: function() {
                    return this._date === void 0 && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts)), this._date;
                  }
                }, {
                  key: "initDateObject",
                  value: function(e5, t4) {
                    var i4;
                    for (P(t4).lastIndex = 0; i4 = P(t4).exec(this.format); ) {
                      var a4 = new RegExp("\\d+$").exec(i4[0]), n2 = a4 ? i4[0][0] + "x" : i4[0], r2 = void 0;
                      if (e5 !== void 0) {
                        if (a4) {
                          var o2 = P(t4).lastIndex, l2 = O(i4.index, t4);
                          P(t4).lastIndex = o2, r2 = e5.slice(0, e5.indexOf(l2.nextMatch[0]));
                        } else
                          r2 = e5.slice(0, n2.length);
                        e5 = e5.slice(r2.length);
                      }
                      Object.prototype.hasOwnProperty.call(g, n2) && this.setValue(this, r2, n2, g[n2][2], g[n2][1]);
                    }
                  }
                }, {
                  key: "setValue",
                  value: function(e5, t4, i4, a4, n2) {
                    if (t4 !== void 0 && (e5[a4] = a4 === "ampm" ? t4 : t4.replace(/[^0-9]/g, "0"), e5["raw" + a4] = t4.replace(/\s/g, "_")), n2 !== void 0) {
                      var r2 = e5[a4];
                      (a4 === "day" && parseInt(r2) === 29 || a4 === "month" && parseInt(r2) === 2) && (parseInt(e5.day) !== 29 || parseInt(e5.month) !== 2 || e5.year !== "" && e5.year !== void 0 || e5._date.setFullYear(2012, 1, 29)), a4 === "day" && (m = true, parseInt(r2) === 0 && (r2 = 1)), a4 === "month" && (m = true), a4 === "year" && (m = true, r2.length < 4 && (r2 = _(r2, 4, true))), r2 === "" || isNaN(r2) || n2.call(e5._date, r2), a4 === "ampm" && n2.call(e5._date, r2);
                    }
                  }
                }, {
                  key: "reset",
                  value: function() {
                    this._date = new Date(1, 0, 1);
                  }
                }, {
                  key: "reInit",
                  value: function() {
                    this._date = void 0, this.date;
                  }
                }]) && f(t3.prototype, i3), a3 && f(t3, a3), Object.defineProperty(t3, "prototype", {
                  writable: false
                }), e4;
              }(), v = new Date().getFullYear(), m = false, g = {
                d: ["[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate],
                dd: ["0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
                  return _(Date.prototype.getDate.call(this), 2);
                }],
                ddd: [""],
                dddd: [""],
                m: ["[1-9]|1[012]", function(e4) {
                  var t3 = e4 ? parseInt(e4) : 0;
                  return t3 > 0 && t3--, Date.prototype.setMonth.call(this, t3);
                }, "month", function() {
                  return Date.prototype.getMonth.call(this) + 1;
                }],
                mm: ["0[1-9]|1[012]", function(e4) {
                  var t3 = e4 ? parseInt(e4) : 0;
                  return t3 > 0 && t3--, Date.prototype.setMonth.call(this, t3);
                }, "month", function() {
                  return _(Date.prototype.getMonth.call(this) + 1, 2);
                }],
                mmm: [""],
                mmmm: [""],
                yy: ["[0-9]{2}", Date.prototype.setFullYear, "year", function() {
                  return _(Date.prototype.getFullYear.call(this), 2);
                }],
                yyyy: ["[0-9]{4}", Date.prototype.setFullYear, "year", function() {
                  return _(Date.prototype.getFullYear.call(this), 4);
                }],
                h: ["[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours],
                hh: ["0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
                  return _(Date.prototype.getHours.call(this), 2);
                }],
                hx: [function(e4) {
                  return "[0-9]{".concat(e4, "}");
                }, Date.prototype.setHours, "hours", function(e4) {
                  return Date.prototype.getHours;
                }],
                H: ["1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours],
                HH: ["0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
                  return _(Date.prototype.getHours.call(this), 2);
                }],
                Hx: [function(e4) {
                  return "[0-9]{".concat(e4, "}");
                }, Date.prototype.setHours, "hours", function(e4) {
                  return function() {
                    return _(Date.prototype.getHours.call(this), e4);
                  };
                }],
                M: ["[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes],
                MM: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
                  return _(Date.prototype.getMinutes.call(this), 2);
                }],
                s: ["[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds],
                ss: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function() {
                  return _(Date.prototype.getSeconds.call(this), 2);
                }],
                l: ["[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
                  return _(Date.prototype.getMilliseconds.call(this), 3);
                }],
                L: ["[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
                  return _(Date.prototype.getMilliseconds.call(this), 2);
                }],
                t: ["[ap]", y, "ampm", b, 1],
                tt: ["[ap]m", y, "ampm", b, 2],
                T: ["[AP]", y, "ampm", b, 1],
                TT: ["[AP]M", y, "ampm", b, 2],
                Z: [".*", void 0, "Z", function() {
                  var e4 = this.toString().match(/\((.+)\)/)[1];
                  e4.includes(" ") && (e4 = (e4 = e4.replace("-", " ").toUpperCase()).split(" ").map(function(e5) {
                    return u(e5, 1)[0];
                  }).join(""));
                  return e4;
                }],
                o: [""],
                S: [""]
              }, k = {
                isoDate: "yyyy-mm-dd",
                isoTime: "HH:MM:ss",
                isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
                isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
              };
              function y(e4) {
                var t3 = this.getHours();
                e4.toLowerCase().includes("p") ? this.setHours(t3 + 12) : e4.toLowerCase().includes("a") && t3 >= 12 && this.setHours(t3 - 12);
              }
              function b() {
                var e4 = this.getHours();
                return (e4 = e4 || 12) >= 12 ? "PM" : "AM";
              }
              function x(e4) {
                var t3 = new RegExp("\\d+$").exec(e4[0]);
                if (t3 && t3[0] !== void 0) {
                  var i3 = g[e4[0][0] + "x"].slice("");
                  return i3[0] = i3[0](t3[0]), i3[3] = i3[3](t3[0]), i3;
                }
                if (g[e4[0]])
                  return g[e4[0]];
              }
              function P(e4) {
                if (!e4.tokenizer) {
                  var t3 = [], i3 = [];
                  for (var a3 in g)
                    if (/\.*x$/.test(a3)) {
                      var n2 = a3[0] + "\\d+";
                      i3.indexOf(n2) === -1 && i3.push(n2);
                    } else
                      t3.indexOf(a3[0]) === -1 && t3.push(a3[0]);
                  e4.tokenizer = "(" + (i3.length > 0 ? i3.join("|") + "|" : "") + t3.join("+|") + ")+?|.", e4.tokenizer = new RegExp(e4.tokenizer, "g");
                }
                return e4.tokenizer;
              }
              function E(e4, t3, i3) {
                if (!m)
                  return true;
                if (e4.rawday === void 0 || !isFinite(e4.rawday) && new Date(e4.date.getFullYear(), isFinite(e4.rawmonth) ? e4.month : e4.date.getMonth() + 1, 0).getDate() >= e4.day || e4.day == "29" && (!isFinite(e4.rawyear) || e4.rawyear === void 0 || e4.rawyear === "") || new Date(e4.date.getFullYear(), isFinite(e4.rawmonth) ? e4.month : e4.date.getMonth() + 1, 0).getDate() >= e4.day)
                  return t3;
                if (e4.day == "29") {
                  var a3 = O(t3.pos, i3);
                  if (a3.targetMatch[0] === "yyyy" && t3.pos - a3.targetMatchIndex == 2)
                    return t3.remove = t3.pos + 1, t3;
                } else if (e4.month == "02" && e4.day == "30" && t3.c !== void 0)
                  return e4.day = "03", e4.date.setDate(3), e4.date.setMonth(1), t3.insert = [{
                    pos: t3.pos,
                    c: "0"
                  }, {
                    pos: t3.pos + 1,
                    c: t3.c
                  }], t3.caret = o.seekNext.call(this, t3.pos + 1), t3;
                return false;
              }
              function S(e4, t3, i3, a3) {
                var n2, o2, l2 = "";
                for (P(i3).lastIndex = 0; n2 = P(i3).exec(e4); ) {
                  if (t3 === void 0)
                    if (o2 = x(n2))
                      l2 += "(" + o2[0] + ")";
                    else
                      switch (n2[0]) {
                        case "[":
                          l2 += "(";
                          break;
                        case "]":
                          l2 += ")?";
                          break;
                        default:
                          l2 += (0, r.default)(n2[0]);
                      }
                  else if (o2 = x(n2))
                    if (a3 !== true && o2[3])
                      l2 += o2[3].call(t3.date);
                    else
                      o2[2] ? l2 += t3["raw" + o2[2]] : l2 += n2[0];
                  else
                    l2 += n2[0];
                }
                return l2;
              }
              function _(e4, t3, i3) {
                for (e4 = String(e4), t3 = t3 || 2; e4.length < t3; )
                  e4 = i3 ? e4 + "0" : "0" + e4;
                return e4;
              }
              function w(e4, t3, i3) {
                return typeof e4 == "string" ? new h(e4, t3, i3) : e4 && s(e4) === "object" && Object.prototype.hasOwnProperty.call(e4, "date") ? e4 : void 0;
              }
              function M(e4, t3) {
                return S(t3.inputFormat, {
                  date: e4
                }, t3);
              }
              function O(e4, t3) {
                var i3, a3, n2 = 0, r2 = 0;
                for (P(t3).lastIndex = 0; a3 = P(t3).exec(t3.inputFormat); ) {
                  var o2 = new RegExp("\\d+$").exec(a3[0]);
                  if ((n2 += r2 = o2 ? parseInt(o2[0]) : a3[0].length) >= e4 + 1) {
                    i3 = a3, a3 = P(t3).exec(t3.inputFormat);
                    break;
                  }
                }
                return {
                  targetMatchIndex: n2 - r2,
                  nextMatch: a3,
                  targetMatch: i3
                };
              }
              a2.default.extendAliases({
                datetime: {
                  mask: function(e4) {
                    return e4.numericInput = false, g.S = e4.i18n.ordinalSuffix.join("|"), e4.inputFormat = k[e4.inputFormat] || e4.inputFormat, e4.displayFormat = k[e4.displayFormat] || e4.displayFormat || e4.inputFormat, e4.outputFormat = k[e4.outputFormat] || e4.outputFormat || e4.inputFormat, e4.placeholder = e4.placeholder !== "" ? e4.placeholder : e4.inputFormat.replace(/[[\]]/, ""), e4.regex = S(e4.inputFormat, void 0, e4), e4.min = w(e4.min, e4.inputFormat, e4), e4.max = w(e4.max, e4.inputFormat, e4), null;
                  },
                  placeholder: "",
                  inputFormat: "isoDateTime",
                  displayFormat: null,
                  outputFormat: null,
                  min: null,
                  max: null,
                  skipOptionalPartCharacter: "",
                  i18n: {
                    dayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
                    monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    ordinalSuffix: ["st", "nd", "rd", "th"]
                  },
                  preValidation: function(e4, t3, i3, a3, n2, r2, o2, l2) {
                    if (l2)
                      return true;
                    if (isNaN(i3) && e4[t3] !== i3) {
                      var s2 = O(t3, n2);
                      if (s2.nextMatch && s2.nextMatch[0] === i3 && s2.targetMatch[0].length > 1) {
                        var u2 = g[s2.targetMatch[0]][0];
                        if (new RegExp(u2).test("0" + e4[t3 - 1]))
                          return e4[t3] = e4[t3 - 1], e4[t3 - 1] = "0", {
                            fuzzy: true,
                            buffer: e4,
                            refreshFromBuffer: {
                              start: t3 - 1,
                              end: t3 + 1
                            },
                            pos: t3 + 1
                          };
                      }
                    }
                    return true;
                  },
                  postValidation: function(e4, t3, i3, a3, n2, r2, o2, s2) {
                    var u2, c2;
                    if (o2)
                      return true;
                    if (a3 === false && (((u2 = O(t3 + 1, n2)).targetMatch && u2.targetMatchIndex === t3 && u2.targetMatch[0].length > 1 && g[u2.targetMatch[0]] !== void 0 || (u2 = O(t3 + 2, n2)).targetMatch && u2.targetMatchIndex === t3 + 1 && u2.targetMatch[0].length > 1 && g[u2.targetMatch[0]] !== void 0) && (c2 = g[u2.targetMatch[0]][0]), c2 !== void 0 && (r2.validPositions[t3 + 1] !== void 0 && new RegExp(c2).test(i3 + "0") ? (e4[t3] = i3, e4[t3 + 1] = "0", a3 = {
                      pos: t3 + 2,
                      caret: t3
                    }) : new RegExp(c2).test("0" + i3) && (e4[t3] = "0", e4[t3 + 1] = i3, a3 = {
                      pos: t3 + 2
                    })), a3 === false))
                      return a3;
                    if (a3.fuzzy && (e4 = a3.buffer, t3 = a3.pos), (u2 = O(t3, n2)).targetMatch && u2.targetMatch[0] && g[u2.targetMatch[0]] !== void 0) {
                      var f2 = g[u2.targetMatch[0]];
                      c2 = f2[0];
                      var d2 = e4.slice(u2.targetMatchIndex, u2.targetMatchIndex + u2.targetMatch[0].length);
                      if (new RegExp(c2).test(d2.join("")) === false && u2.targetMatch[0].length === 2 && r2.validPositions[u2.targetMatchIndex] && r2.validPositions[u2.targetMatchIndex + 1] && (r2.validPositions[u2.targetMatchIndex + 1].input = "0"), f2[2] == "year")
                        for (var p2 = l.getMaskTemplate.call(this, false, 1, void 0, true), h2 = t3 + 1; h2 < e4.length; h2++)
                          e4[h2] = p2[h2], delete r2.validPositions[h2];
                    }
                    var m2 = a3, k2 = w(e4.join(""), n2.inputFormat, n2);
                    return m2 && k2.date.getTime() == k2.date.getTime() && (n2.prefillYear && (m2 = function(e5, t4, i4) {
                      if (e5.year !== e5.rawyear) {
                        var a4 = v.toString(), n3 = e5.rawyear.replace(/[^0-9]/g, ""), r3 = a4.slice(0, n3.length), o3 = a4.slice(n3.length);
                        if (n3.length === 2 && n3 === r3) {
                          var l2 = new Date(v, e5.month - 1, e5.day);
                          e5.day == l2.getDate() && (!i4.max || i4.max.date.getTime() >= l2.getTime()) && (e5.date.setFullYear(v), e5.year = a4, t4.insert = [{
                            pos: t4.pos + 1,
                            c: o3[0]
                          }, {
                            pos: t4.pos + 2,
                            c: o3[1]
                          }]);
                        }
                      }
                      return t4;
                    }(k2, m2, n2)), m2 = function(e5, t4, i4, a4, n3) {
                      if (!t4)
                        return t4;
                      if (t4 && i4.min && i4.min.date.getTime() == i4.min.date.getTime()) {
                        var r3;
                        for (e5.reset(), P(i4).lastIndex = 0; r3 = P(i4).exec(i4.inputFormat); ) {
                          var o3;
                          if ((o3 = x(r3)) && o3[3]) {
                            for (var l2 = o3[1], s3 = e5[o3[2]], u3 = i4.min[o3[2]], c3 = i4.max ? i4.max[o3[2]] : u3, f3 = [], d3 = false, p3 = 0; p3 < u3.length; p3++)
                              a4.validPositions[p3 + r3.index] !== void 0 || d3 ? (f3[p3] = s3[p3], d3 = d3 || s3[p3] > u3[p3]) : (f3[p3] = u3[p3], o3[2] === "year" && s3.length - 1 == p3 && u3 != c3 && (f3 = (parseInt(f3.join("")) + 1).toString().split("")), o3[2] === "ampm" && u3 != c3 && i4.min.date.getTime() > e5.date.getTime() && (f3[p3] = c3[p3]));
                            l2.call(e5._date, f3.join(""));
                          }
                        }
                        t4 = i4.min.date.getTime() <= e5.date.getTime(), e5.reInit();
                      }
                      return t4 && i4.max && i4.max.date.getTime() == i4.max.date.getTime() && (t4 = i4.max.date.getTime() >= e5.date.getTime()), t4;
                    }(k2, m2 = E.call(this, k2, m2, n2), n2, r2)), t3 !== void 0 && m2 && a3.pos !== t3 ? {
                      buffer: S(n2.inputFormat, k2, n2).split(""),
                      refreshFromBuffer: {
                        start: t3,
                        end: a3.pos
                      },
                      pos: a3.caret || a3.pos
                    } : m2;
                  },
                  onKeyDown: function(e4, t3, i3, a3) {
                    e4.ctrlKey && e4.keyCode === n.default.RIGHT && (this.inputmask._valueSet(M(new Date(), a3)), p(this).trigger("setvalue"));
                  },
                  onUnMask: function(e4, t3, i3) {
                    return t3 ? S(i3.outputFormat, w(e4, i3.inputFormat, i3), i3, true) : t3;
                  },
                  casing: function(e4, t3, i3, a3) {
                    return t3.nativeDef.indexOf("[ap]") == 0 ? e4.toLowerCase() : t3.nativeDef.indexOf("[AP]") == 0 ? e4.toUpperCase() : e4;
                  },
                  onBeforeMask: function(e4, t3) {
                    return Object.prototype.toString.call(e4) === "[object Date]" && (e4 = M(e4, t3)), e4;
                  },
                  insertMode: false,
                  shiftPositions: false,
                  keepStatic: false,
                  inputmode: "numeric",
                  prefillYear: true
                }
              });
            },
            3851: function(e3, t2, i2) {
              var a2, n = (a2 = i2(2394)) && a2.__esModule ? a2 : {
                default: a2
              }, r = i2(8711), o = i2(4713);
              n.default.extendDefinitions({
                A: {
                  validator: "[A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]",
                  casing: "upper"
                },
                "&": {
                  validator: "[0-9A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5]",
                  casing: "upper"
                },
                "#": {
                  validator: "[0-9A-Fa-f]",
                  casing: "upper"
                }
              });
              var l = new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]");
              function s(e4, t3, i3, a3, n2) {
                return i3 - 1 > -1 && t3.buffer[i3 - 1] !== "." ? (e4 = t3.buffer[i3 - 1] + e4, e4 = i3 - 2 > -1 && t3.buffer[i3 - 2] !== "." ? t3.buffer[i3 - 2] + e4 : "0" + e4) : e4 = "00" + e4, l.test(e4);
              }
              n.default.extendAliases({
                cssunit: {
                  regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
                },
                url: {
                  regex: "(https?|ftp)://.*",
                  autoUnmask: false,
                  keepStatic: false,
                  tabThrough: true
                },
                ip: {
                  mask: "i{1,3}.j{1,3}.k{1,3}.l{1,3}",
                  definitions: {
                    i: {
                      validator: s
                    },
                    j: {
                      validator: s
                    },
                    k: {
                      validator: s
                    },
                    l: {
                      validator: s
                    }
                  },
                  onUnMask: function(e4, t3, i3) {
                    return e4;
                  },
                  inputmode: "decimal",
                  substitutes: {
                    ",": "."
                  }
                },
                email: {
                  mask: function(e4) {
                    var t3 = "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", i3 = t3;
                    if (e4.separator)
                      for (var a3 = 0; a3 < e4.quantifier; a3++)
                        i3 += "[".concat(e4.separator).concat(t3, "]");
                    return i3;
                  },
                  greedy: false,
                  casing: "lower",
                  separator: null,
                  quantifier: 5,
                  skipOptionalPartCharacter: "",
                  onBeforePaste: function(e4, t3) {
                    return (e4 = e4.toLowerCase()).replace("mailto:", "");
                  },
                  definitions: {
                    "*": {
                      validator: "[0-9\uFF11-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\xC0-\xFF\xB5!#$%&'*+/=?^_`{|}~-]"
                    },
                    "-": {
                      validator: "[0-9A-Za-z-]"
                    }
                  },
                  onUnMask: function(e4, t3, i3) {
                    return e4;
                  },
                  inputmode: "email"
                },
                mac: {
                  mask: "##:##:##:##:##:##"
                },
                vin: {
                  mask: "V{13}9{4}",
                  definitions: {
                    V: {
                      validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                      casing: "upper"
                    }
                  },
                  clearIncomplete: true,
                  autoUnmask: true
                },
                ssn: {
                  mask: "999-99-9999",
                  postValidation: function(e4, t3, i3, a3, n2, l2, s2) {
                    var u = o.getMaskTemplate.call(this, true, r.getLastValidPosition.call(this), true, true);
                    return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(u.join(""));
                  }
                }
              });
            },
            207: function(e3, t2, i2) {
              var a2 = l(i2(2394)), n = l(i2(5581)), r = l(i2(7184)), o = i2(8711);
              function l(e4) {
                return e4 && e4.__esModule ? e4 : {
                  default: e4
                };
              }
              var s = a2.default.dependencyLib;
              function u(e4, t3) {
                for (var i3 = "", n2 = 0; n2 < e4.length; n2++)
                  a2.default.prototype.definitions[e4.charAt(n2)] || t3.definitions[e4.charAt(n2)] || t3.optionalmarker[0] === e4.charAt(n2) || t3.optionalmarker[1] === e4.charAt(n2) || t3.quantifiermarker[0] === e4.charAt(n2) || t3.quantifiermarker[1] === e4.charAt(n2) || t3.groupmarker[0] === e4.charAt(n2) || t3.groupmarker[1] === e4.charAt(n2) || t3.alternatormarker === e4.charAt(n2) ? i3 += "\\" + e4.charAt(n2) : i3 += e4.charAt(n2);
                return i3;
              }
              function c(e4, t3, i3, a3) {
                if (e4.length > 0 && t3 > 0 && (!i3.digitsOptional || a3)) {
                  var n2 = e4.indexOf(i3.radixPoint), r2 = false;
                  i3.negationSymbol.back === e4[e4.length - 1] && (r2 = true, e4.length--), n2 === -1 && (e4.push(i3.radixPoint), n2 = e4.length - 1);
                  for (var o2 = 1; o2 <= t3; o2++)
                    isFinite(e4[n2 + o2]) || (e4[n2 + o2] = "0");
                }
                return r2 && e4.push(i3.negationSymbol.back), e4;
              }
              function f(e4, t3) {
                var i3 = 0;
                if (e4 === "+") {
                  for (i3 in t3.validPositions)
                    ;
                  i3 = o.seekNext.call(this, parseInt(i3));
                }
                for (var a3 in t3.tests)
                  if ((a3 = parseInt(a3)) >= i3) {
                    for (var n2 = 0, r2 = t3.tests[a3].length; n2 < r2; n2++)
                      if ((t3.validPositions[a3] === void 0 || e4 === "-") && t3.tests[a3][n2].match.def === e4)
                        return a3 + (t3.validPositions[a3] !== void 0 && e4 !== "-" ? 1 : 0);
                  }
                return i3;
              }
              function d(e4, t3) {
                var i3 = -1;
                for (var a3 in t3.validPositions) {
                  var n2 = t3.validPositions[a3];
                  if (n2 && n2.match.def === e4) {
                    i3 = parseInt(a3);
                    break;
                  }
                }
                return i3;
              }
              function p(e4, t3, i3, a3, n2) {
                var r2 = t3.buffer ? t3.buffer.indexOf(n2.radixPoint) : -1, o2 = (r2 !== -1 || a3 && n2.jitMasking) && new RegExp(n2.definitions[9].validator).test(e4);
                return n2._radixDance && r2 !== -1 && o2 && t3.validPositions[r2] == null ? {
                  insert: {
                    pos: r2 === i3 ? r2 + 1 : r2,
                    c: n2.radixPoint
                  },
                  pos: i3
                } : o2;
              }
              a2.default.extendAliases({
                numeric: {
                  mask: function(e4) {
                    e4.repeat = 0, e4.groupSeparator === e4.radixPoint && e4.digits && e4.digits !== "0" && (e4.radixPoint === "." ? e4.groupSeparator = "," : e4.radixPoint === "," ? e4.groupSeparator = "." : e4.groupSeparator = ""), e4.groupSeparator === " " && (e4.skipOptionalPartCharacter = void 0), e4.placeholder.length > 1 && (e4.placeholder = e4.placeholder.charAt(0)), e4.positionCaretOnClick === "radixFocus" && e4.placeholder === "" && (e4.positionCaretOnClick = "lvp");
                    var t3 = "0", i3 = e4.radixPoint;
                    e4.numericInput === true && e4.__financeInput === void 0 ? (t3 = "1", e4.positionCaretOnClick = e4.positionCaretOnClick === "radixFocus" ? "lvp" : e4.positionCaretOnClick, e4.digitsOptional = false, isNaN(e4.digits) && (e4.digits = 2), e4._radixDance = false, i3 = e4.radixPoint === "," ? "?" : "!", e4.radixPoint !== "" && e4.definitions[i3] === void 0 && (e4.definitions[i3] = {}, e4.definitions[i3].validator = "[" + e4.radixPoint + "]", e4.definitions[i3].placeholder = e4.radixPoint, e4.definitions[i3].static = true, e4.definitions[i3].generated = true)) : (e4.__financeInput = false, e4.numericInput = true);
                    var a3, n2 = "[+]";
                    if (n2 += u(e4.prefix, e4), e4.groupSeparator !== "" ? (e4.definitions[e4.groupSeparator] === void 0 && (e4.definitions[e4.groupSeparator] = {}, e4.definitions[e4.groupSeparator].validator = "[" + e4.groupSeparator + "]", e4.definitions[e4.groupSeparator].placeholder = e4.groupSeparator, e4.definitions[e4.groupSeparator].static = true, e4.definitions[e4.groupSeparator].generated = true), n2 += e4._mask(e4)) : n2 += "9{+}", e4.digits !== void 0 && e4.digits !== 0) {
                      var o2 = e4.digits.toString().split(",");
                      isFinite(o2[0]) && o2[1] && isFinite(o2[1]) ? n2 += i3 + t3 + "{" + e4.digits + "}" : (isNaN(e4.digits) || parseInt(e4.digits) > 0) && (e4.digitsOptional || e4.jitMasking ? (a3 = n2 + i3 + t3 + "{0," + e4.digits + "}", e4.keepStatic = true) : n2 += i3 + t3 + "{" + e4.digits + "}");
                    } else
                      e4.inputmode = "numeric";
                    return n2 += u(e4.suffix, e4), n2 += "[-]", a3 && (n2 = [a3 + u(e4.suffix, e4) + "[-]", n2]), e4.greedy = false, function(e5) {
                      e5.parseMinMaxOptions === void 0 && (e5.min !== null && (e5.min = e5.min.toString().replace(new RegExp((0, r.default)(e5.groupSeparator), "g"), ""), e5.radixPoint === "," && (e5.min = e5.min.replace(e5.radixPoint, ".")), e5.min = isFinite(e5.min) ? parseFloat(e5.min) : NaN, isNaN(e5.min) && (e5.min = Number.MIN_VALUE)), e5.max !== null && (e5.max = e5.max.toString().replace(new RegExp((0, r.default)(e5.groupSeparator), "g"), ""), e5.radixPoint === "," && (e5.max = e5.max.replace(e5.radixPoint, ".")), e5.max = isFinite(e5.max) ? parseFloat(e5.max) : NaN, isNaN(e5.max) && (e5.max = Number.MAX_VALUE)), e5.parseMinMaxOptions = "done");
                    }(e4), e4.radixPoint !== "" && (e4.substitutes[e4.radixPoint == "." ? "," : "."] = e4.radixPoint), n2;
                  },
                  _mask: function(e4) {
                    return "(" + e4.groupSeparator + "999){+|1}";
                  },
                  digits: "*",
                  digitsOptional: true,
                  enforceDigitsOnBlur: false,
                  radixPoint: ".",
                  positionCaretOnClick: "radixFocus",
                  _radixDance: true,
                  groupSeparator: "",
                  allowMinus: true,
                  negationSymbol: {
                    front: "-",
                    back: ""
                  },
                  prefix: "",
                  suffix: "",
                  min: null,
                  max: null,
                  SetMaxOnOverflow: false,
                  step: 1,
                  inputType: "text",
                  unmaskAsNumber: false,
                  roundingFN: Math.round,
                  inputmode: "decimal",
                  shortcuts: {
                    k: "1000",
                    m: "1000000"
                  },
                  placeholder: "0",
                  greedy: false,
                  rightAlign: true,
                  insertMode: true,
                  autoUnmask: false,
                  skipOptionalPartCharacter: "",
                  usePrototypeDefinitions: false,
                  stripLeadingZeroes: true,
                  definitions: {
                    0: {
                      validator: p
                    },
                    1: {
                      validator: p,
                      definitionSymbol: "9"
                    },
                    9: {
                      validator: "[0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]",
                      definitionSymbol: "*"
                    },
                    "+": {
                      validator: function(e4, t3, i3, a3, n2) {
                        return n2.allowMinus && (e4 === "-" || e4 === n2.negationSymbol.front);
                      }
                    },
                    "-": {
                      validator: function(e4, t3, i3, a3, n2) {
                        return n2.allowMinus && e4 === n2.negationSymbol.back;
                      }
                    }
                  },
                  preValidation: function(e4, t3, i3, a3, n2, r2, o2, l2) {
                    if (n2.__financeInput !== false && i3 === n2.radixPoint)
                      return false;
                    var s2 = e4.indexOf(n2.radixPoint), u2 = t3;
                    if (t3 = function(e5, t4, i4, a4, n3) {
                      return n3._radixDance && n3.numericInput && t4 !== n3.negationSymbol.back && e5 <= i4 && (i4 > 0 || t4 == n3.radixPoint) && (a4.validPositions[e5 - 1] === void 0 || a4.validPositions[e5 - 1].input !== n3.negationSymbol.back) && (e5 -= 1), e5;
                    }(t3, i3, s2, r2, n2), i3 === "-" || i3 === n2.negationSymbol.front) {
                      if (n2.allowMinus !== true)
                        return false;
                      var c2 = false, p2 = d("+", r2), h = d("-", r2);
                      return p2 !== -1 && (c2 = [p2, h]), c2 !== false ? {
                        remove: c2,
                        caret: u2 - n2.negationSymbol.back.length
                      } : {
                        insert: [{
                          pos: f.call(this, "+", r2),
                          c: n2.negationSymbol.front,
                          fromIsValid: true
                        }, {
                          pos: f.call(this, "-", r2),
                          c: n2.negationSymbol.back,
                          fromIsValid: void 0
                        }],
                        caret: u2 + n2.negationSymbol.back.length
                      };
                    }
                    if (i3 === n2.groupSeparator)
                      return {
                        caret: u2
                      };
                    if (l2)
                      return true;
                    if (s2 !== -1 && n2._radixDance === true && a3 === false && i3 === n2.radixPoint && n2.digits !== void 0 && (isNaN(n2.digits) || parseInt(n2.digits) > 0) && s2 !== t3)
                      return {
                        caret: n2._radixDance && t3 === s2 - 1 ? s2 + 1 : s2
                      };
                    if (n2.__financeInput === false) {
                      if (a3) {
                        if (n2.digitsOptional)
                          return {
                            rewritePosition: o2.end
                          };
                        if (!n2.digitsOptional) {
                          if (o2.begin > s2 && o2.end <= s2)
                            return i3 === n2.radixPoint ? {
                              insert: {
                                pos: s2 + 1,
                                c: "0",
                                fromIsValid: true
                              },
                              rewritePosition: s2
                            } : {
                              rewritePosition: s2 + 1
                            };
                          if (o2.begin < s2)
                            return {
                              rewritePosition: o2.begin - 1
                            };
                        }
                      } else if (!n2.showMaskOnHover && !n2.showMaskOnFocus && !n2.digitsOptional && n2.digits > 0 && this.__valueGet.call(this.el) === "")
                        return {
                          rewritePosition: s2
                        };
                    }
                    return {
                      rewritePosition: t3
                    };
                  },
                  postValidation: function(e4, t3, i3, a3, n2, r2, o2) {
                    if (a3 === false)
                      return a3;
                    if (o2)
                      return true;
                    if (n2.min !== null || n2.max !== null) {
                      var l2 = n2.onUnMask(e4.slice().reverse().join(""), void 0, s.extend({}, n2, {
                        unmaskAsNumber: true
                      }));
                      if (n2.min !== null && l2 < n2.min && (l2.toString().length > n2.min.toString().length || l2 < 0))
                        return false;
                      if (n2.max !== null && l2 > n2.max)
                        return !!n2.SetMaxOnOverflow && {
                          refreshFromBuffer: true,
                          buffer: c(n2.max.toString().replace(".", n2.radixPoint).split(""), n2.digits, n2).reverse()
                        };
                    }
                    return a3;
                  },
                  onUnMask: function(e4, t3, i3) {
                    if (t3 === "" && i3.nullable === true)
                      return t3;
                    var a3 = e4.replace(i3.prefix, "");
                    return a3 = (a3 = a3.replace(i3.suffix, "")).replace(new RegExp((0, r.default)(i3.groupSeparator), "g"), ""), i3.placeholder.charAt(0) !== "" && (a3 = a3.replace(new RegExp(i3.placeholder.charAt(0), "g"), "0")), i3.unmaskAsNumber ? (i3.radixPoint !== "" && a3.indexOf(i3.radixPoint) !== -1 && (a3 = a3.replace(r.default.call(this, i3.radixPoint), ".")), a3 = (a3 = a3.replace(new RegExp("^" + (0, r.default)(i3.negationSymbol.front)), "-")).replace(new RegExp((0, r.default)(i3.negationSymbol.back) + "$"), ""), Number(a3)) : a3;
                  },
                  isComplete: function(e4, t3) {
                    var i3 = (t3.numericInput ? e4.slice().reverse() : e4).join("");
                    return i3 = (i3 = (i3 = (i3 = (i3 = i3.replace(new RegExp("^" + (0, r.default)(t3.negationSymbol.front)), "-")).replace(new RegExp((0, r.default)(t3.negationSymbol.back) + "$"), "")).replace(t3.prefix, "")).replace(t3.suffix, "")).replace(new RegExp((0, r.default)(t3.groupSeparator) + "([0-9]{3})", "g"), "$1"), t3.radixPoint === "," && (i3 = i3.replace((0, r.default)(t3.radixPoint), ".")), isFinite(i3);
                  },
                  onBeforeMask: function(e4, t3) {
                    var i3 = t3.radixPoint || ",";
                    isFinite(t3.digits) && (t3.digits = parseInt(t3.digits)), typeof e4 != "number" && t3.inputType !== "number" || i3 === "" || (e4 = e4.toString().replace(".", i3));
                    var a3 = e4.charAt(0) === "-" || e4.charAt(0) === t3.negationSymbol.front, n2 = e4.split(i3), o2 = n2[0].replace(/[^\-0-9]/g, ""), l2 = n2.length > 1 ? n2[1].replace(/[^0-9]/g, "") : "", s2 = n2.length > 1;
                    e4 = o2 + (l2 !== "" ? i3 + l2 : l2);
                    var u2 = 0;
                    if (i3 !== "" && (u2 = t3.digitsOptional ? t3.digits < l2.length ? t3.digits : l2.length : t3.digits, l2 !== "" || !t3.digitsOptional)) {
                      var f2 = Math.pow(10, u2 || 1);
                      e4 = e4.replace((0, r.default)(i3), "."), isNaN(parseFloat(e4)) || (e4 = (t3.roundingFN(parseFloat(e4) * f2) / f2).toFixed(u2)), e4 = e4.toString().replace(".", i3);
                    }
                    if (t3.digits === 0 && e4.indexOf(i3) !== -1 && (e4 = e4.substring(0, e4.indexOf(i3))), t3.min !== null || t3.max !== null) {
                      var d2 = e4.toString().replace(i3, ".");
                      t3.min !== null && d2 < t3.min ? e4 = t3.min.toString().replace(".", i3) : t3.max !== null && d2 > t3.max && (e4 = t3.max.toString().replace(".", i3));
                    }
                    return a3 && e4.charAt(0) !== "-" && (e4 = "-" + e4), c(e4.toString().split(""), u2, t3, s2).join("");
                  },
                  onBeforeWrite: function(e4, t3, i3, a3) {
                    function n2(e5, t4) {
                      if (a3.__financeInput !== false || t4) {
                        var i4 = e5.indexOf(a3.radixPoint);
                        i4 !== -1 && e5.splice(i4, 1);
                      }
                      if (a3.groupSeparator !== "")
                        for (; (i4 = e5.indexOf(a3.groupSeparator)) !== -1; )
                          e5.splice(i4, 1);
                      return e5;
                    }
                    var o2, l2;
                    if (a3.stripLeadingZeroes && (l2 = function(e5, t4) {
                      var i4 = new RegExp("(^" + (t4.negationSymbol.front !== "" ? (0, r.default)(t4.negationSymbol.front) + "?" : "") + (0, r.default)(t4.prefix) + ")(.*)(" + (0, r.default)(t4.suffix) + (t4.negationSymbol.back != "" ? (0, r.default)(t4.negationSymbol.back) + "?" : "") + "$)").exec(e5.slice().reverse().join("")), a4 = i4 ? i4[2] : "", n3 = false;
                      return a4 && (a4 = a4.split(t4.radixPoint.charAt(0))[0], n3 = new RegExp("^[0" + t4.groupSeparator + "]*").exec(a4)), !(!n3 || !(n3[0].length > 1 || n3[0].length > 0 && n3[0].length < a4.length)) && n3;
                    }(t3, a3)))
                      for (var u2 = t3.join("").lastIndexOf(l2[0].split("").reverse().join("")) - (l2[0] == l2.input ? 0 : 1), f2 = l2[0] == l2.input ? 1 : 0, d2 = l2[0].length - f2; d2 > 0; d2--)
                        delete this.maskset.validPositions[u2 + d2], delete t3[u2 + d2];
                    if (e4)
                      switch (e4.type) {
                        case "blur":
                        case "checkval":
                          if (a3.min !== null) {
                            var p2 = a3.onUnMask(t3.slice().reverse().join(""), void 0, s.extend({}, a3, {
                              unmaskAsNumber: true
                            }));
                            if (a3.min !== null && p2 < a3.min)
                              return {
                                refreshFromBuffer: true,
                                buffer: c(a3.min.toString().replace(".", a3.radixPoint).split(""), a3.digits, a3).reverse()
                              };
                          }
                          if (t3[t3.length - 1] === a3.negationSymbol.front) {
                            var h = new RegExp("(^" + (a3.negationSymbol.front != "" ? (0, r.default)(a3.negationSymbol.front) + "?" : "") + (0, r.default)(a3.prefix) + ")(.*)(" + (0, r.default)(a3.suffix) + (a3.negationSymbol.back != "" ? (0, r.default)(a3.negationSymbol.back) + "?" : "") + "$)").exec(n2(t3.slice(), true).reverse().join(""));
                            (h ? h[2] : "") == 0 && (o2 = {
                              refreshFromBuffer: true,
                              buffer: [0]
                            });
                          } else if (a3.radixPoint !== "") {
                            t3.indexOf(a3.radixPoint) === a3.suffix.length && (o2 && o2.buffer ? o2.buffer.splice(0, 1 + a3.suffix.length) : (t3.splice(0, 1 + a3.suffix.length), o2 = {
                              refreshFromBuffer: true,
                              buffer: n2(t3)
                            }));
                          }
                          if (a3.enforceDigitsOnBlur) {
                            var v = (o2 = o2 || {}) && o2.buffer || t3.slice().reverse();
                            o2.refreshFromBuffer = true, o2.buffer = c(v, a3.digits, a3, true).reverse();
                          }
                      }
                    return o2;
                  },
                  onKeyDown: function(e4, t3, i3, a3) {
                    var r2, o2, l2 = s(this), u2 = String.fromCharCode(e4.keyCode).toLowerCase();
                    if ((o2 = a3.shortcuts && a3.shortcuts[u2]) && o2.length > 1)
                      return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(o2)), l2.trigger("setvalue"), false;
                    if (e4.ctrlKey)
                      switch (e4.keyCode) {
                        case n.default.UP:
                          return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(a3.step)), l2.trigger("setvalue"), false;
                        case n.default.DOWN:
                          return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(a3.step)), l2.trigger("setvalue"), false;
                      }
                    if (!e4.shiftKey && (e4.keyCode === n.default.DELETE || e4.keyCode === n.default.BACKSPACE || e4.keyCode === n.default.BACKSPACE_SAFARI) && i3.begin !== t3.length) {
                      if (t3[e4.keyCode === n.default.DELETE ? i3.begin - 1 : i3.end] === a3.negationSymbol.front)
                        return r2 = t3.slice().reverse(), a3.negationSymbol.front !== "" && r2.shift(), a3.negationSymbol.back !== "" && r2.pop(), l2.trigger("setvalue", [r2.join(""), i3.begin]), false;
                      if (a3._radixDance === true) {
                        var f2 = t3.indexOf(a3.radixPoint);
                        if (a3.digitsOptional) {
                          if (f2 === 0)
                            return (r2 = t3.slice().reverse()).pop(), l2.trigger("setvalue", [r2.join(""), i3.begin >= r2.length ? r2.length : i3.begin]), false;
                        } else if (f2 !== -1 && (i3.begin < f2 || i3.end < f2 || e4.keyCode === n.default.DELETE && i3.begin === f2))
                          return i3.begin !== i3.end || e4.keyCode !== n.default.BACKSPACE && e4.keyCode !== n.default.BACKSPACE_SAFARI || i3.begin++, (r2 = t3.slice().reverse()).splice(r2.length - i3.begin, i3.begin - i3.end + 1), r2 = c(r2, a3.digits, a3).join(""), l2.trigger("setvalue", [r2, i3.begin >= r2.length ? f2 + 1 : i3.begin]), false;
                      }
                    }
                  }
                },
                currency: {
                  prefix: "",
                  groupSeparator: ",",
                  alias: "numeric",
                  digits: 2,
                  digitsOptional: false
                },
                decimal: {
                  alias: "numeric"
                },
                integer: {
                  alias: "numeric",
                  inputmode: "numeric",
                  digits: 0
                },
                percentage: {
                  alias: "numeric",
                  min: 0,
                  max: 100,
                  suffix: " %",
                  digits: 0,
                  allowMinus: false
                },
                indianns: {
                  alias: "numeric",
                  _mask: function(e4) {
                    return "(" + e4.groupSeparator + "99){*|1}(" + e4.groupSeparator + "999){1|1}";
                  },
                  groupSeparator: ",",
                  radixPoint: ".",
                  placeholder: "0",
                  digits: 2,
                  digitsOptional: false
                }
              });
            },
            9380: function(e3, t2, i2) {
              var a2;
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0;
              var n = ((a2 = i2(8741)) && a2.__esModule ? a2 : {
                default: a2
              }).default ? window : {};
              t2.default = n;
            },
            7760: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.HandleNativePlaceholder = function(e4, t3) {
                var i3 = e4 ? e4.inputmask : this;
                if (s.ie) {
                  if (e4.inputmask._valueGet() !== t3 && (e4.placeholder !== t3 || e4.placeholder === "")) {
                    var a3 = o.getBuffer.call(i3).slice(), n2 = e4.inputmask._valueGet();
                    if (n2 !== t3) {
                      var r2 = o.getLastValidPosition.call(i3);
                      r2 === -1 && n2 === o.getBufferTemplate.call(i3).join("") ? a3 = [] : r2 !== -1 && f.call(i3, a3), p(e4, a3);
                    }
                  }
                } else
                  e4.placeholder !== t3 && (e4.placeholder = t3, e4.placeholder === "" && e4.removeAttribute("placeholder"));
              }, t2.applyInputValue = c, t2.checkVal = d, t2.clearOptionalTail = f, t2.unmaskedvalue = function(e4) {
                var t3 = e4 ? e4.inputmask : this, i3 = t3.opts, a3 = t3.maskset;
                if (e4) {
                  if (e4.inputmask === void 0)
                    return e4.value;
                  e4.inputmask && e4.inputmask.refreshValue && c(e4, e4.inputmask._valueGet(true));
                }
                var n2 = [], r2 = a3.validPositions;
                for (var l2 in r2)
                  r2[l2] && r2[l2].match && (r2[l2].match.static != 1 || Array.isArray(a3.metadata) && r2[l2].generatedInput !== true) && n2.push(r2[l2].input);
                var s2 = n2.length === 0 ? "" : (t3.isRTL ? n2.reverse() : n2).join("");
                if (typeof i3.onUnMask == "function") {
                  var u2 = (t3.isRTL ? o.getBuffer.call(t3).slice().reverse() : o.getBuffer.call(t3)).join("");
                  s2 = i3.onUnMask.call(t3, u2, s2, i3);
                }
                return s2;
              }, t2.writeBuffer = p;
              var a2, n = (a2 = i2(5581)) && a2.__esModule ? a2 : {
                default: a2
              }, r = i2(4713), o = i2(8711), l = i2(7215), s = i2(9845), u = i2(6030);
              function c(e4, t3) {
                var i3 = e4 ? e4.inputmask : this, a3 = i3.opts;
                e4.inputmask.refreshValue = false, typeof a3.onBeforeMask == "function" && (t3 = a3.onBeforeMask.call(i3, t3, a3) || t3), d(e4, true, false, t3 = t3.toString().split("")), i3.undoValue = i3._valueGet(true), (a3.clearMaskOnLostFocus || a3.clearIncomplete) && e4.inputmask._valueGet() === o.getBufferTemplate.call(i3).join("") && o.getLastValidPosition.call(i3) === -1 && e4.inputmask._valueSet("");
              }
              function f(e4) {
                e4.length = 0;
                for (var t3, i3 = r.getMaskTemplate.call(this, true, 0, true, void 0, true); (t3 = i3.shift()) !== void 0; )
                  e4.push(t3);
                return e4;
              }
              function d(e4, t3, i3, a3, n2) {
                var s2 = e4 ? e4.inputmask : this, c2 = s2.maskset, f2 = s2.opts, d2 = s2.dependencyLib, h = a3.slice(), v = "", m = -1, g = void 0, k = f2.skipOptionalPartCharacter;
                f2.skipOptionalPartCharacter = "", o.resetMaskSet.call(s2), c2.tests = {}, m = f2.radixPoint ? o.determineNewCaretPosition.call(s2, {
                  begin: 0,
                  end: 0
                }, false, f2.__financeInput === false ? "radixFocus" : void 0).begin : 0, c2.p = m, s2.caretPos = {
                  begin: m
                };
                var y = [], b = s2.caretPos;
                if (h.forEach(function(e5, t4) {
                  if (e5 !== void 0) {
                    var a4 = new d2.Event("_checkval");
                    a4.keyCode = e5.toString().charCodeAt(0), v += e5;
                    var n3 = o.getLastValidPosition.call(s2, void 0, true);
                    !function(e6, t5) {
                      for (var i4 = r.getMaskTemplate.call(s2, true, 0).slice(e6, o.seekNext.call(s2, e6, false, false)).join("").replace(/'/g, ""), a5 = i4.indexOf(t5); a5 > 0 && i4[a5 - 1] === " "; )
                        a5--;
                      var n4 = a5 === 0 && !o.isMask.call(s2, e6) && (r.getTest.call(s2, e6).match.nativeDef === t5.charAt(0) || r.getTest.call(s2, e6).match.static === true && r.getTest.call(s2, e6).match.nativeDef === "'" + t5.charAt(0) || r.getTest.call(s2, e6).match.nativeDef === " " && (r.getTest.call(s2, e6 + 1).match.nativeDef === t5.charAt(0) || r.getTest.call(s2, e6 + 1).match.static === true && r.getTest.call(s2, e6 + 1).match.nativeDef === "'" + t5.charAt(0)));
                      if (!n4 && a5 > 0 && !o.isMask.call(s2, e6, false, true)) {
                        var l2 = o.seekNext.call(s2, e6);
                        s2.caretPos.begin < l2 && (s2.caretPos = {
                          begin: l2
                        });
                      }
                      return n4;
                    }(m, v) ? (g = u.EventHandlers.keypressEvent.call(s2, a4, true, false, i3, s2.caretPos.begin)) && (m = s2.caretPos.begin + 1, v = "") : g = u.EventHandlers.keypressEvent.call(s2, a4, true, false, i3, n3 + 1), g ? (g.pos !== void 0 && c2.validPositions[g.pos] && c2.validPositions[g.pos].match.static === true && c2.validPositions[g.pos].alternation === void 0 && (y.push(g.pos), s2.isRTL || (g.forwardPosition = g.pos + 1)), p.call(s2, void 0, o.getBuffer.call(s2), g.forwardPosition, a4, false), s2.caretPos = {
                      begin: g.forwardPosition,
                      end: g.forwardPosition
                    }, b = s2.caretPos) : c2.validPositions[t4] === void 0 && h[t4] === r.getPlaceholder.call(s2, t4) && o.isMask.call(s2, t4, true) ? s2.caretPos.begin++ : s2.caretPos = b;
                  }
                }), y.length > 0) {
                  var x, P, E = o.seekNext.call(s2, -1, void 0, false);
                  if (!l.isComplete.call(s2, o.getBuffer.call(s2)) && y.length <= E || l.isComplete.call(s2, o.getBuffer.call(s2)) && y.length > 0 && y.length !== E && y[0] === 0)
                    for (var S = E; (x = y.shift()) !== void 0; ) {
                      var _ = new d2.Event("_checkval");
                      if ((P = c2.validPositions[x]).generatedInput = true, _.keyCode = P.input.charCodeAt(0), (g = u.EventHandlers.keypressEvent.call(s2, _, true, false, i3, S)) && g.pos !== void 0 && g.pos !== x && c2.validPositions[g.pos] && c2.validPositions[g.pos].match.static === true)
                        y.push(g.pos);
                      else if (!g)
                        break;
                      S++;
                    }
                }
                t3 && p.call(s2, e4, o.getBuffer.call(s2), g ? g.forwardPosition : s2.caretPos.begin, n2 || new d2.Event("checkval"), n2 && (n2.type === "input" && s2.undoValue !== o.getBuffer.call(s2).join("") || n2.type === "paste")), f2.skipOptionalPartCharacter = k;
              }
              function p(e4, t3, i3, a3, r2) {
                var s2 = e4 ? e4.inputmask : this, u2 = s2.opts, c2 = s2.dependencyLib;
                if (a3 && typeof u2.onBeforeWrite == "function") {
                  var f2 = u2.onBeforeWrite.call(s2, a3, t3, i3, u2);
                  if (f2) {
                    if (f2.refreshFromBuffer) {
                      var d2 = f2.refreshFromBuffer;
                      l.refreshFromBuffer.call(s2, d2 === true ? d2 : d2.start, d2.end, f2.buffer || t3), t3 = o.getBuffer.call(s2, true);
                    }
                    i3 !== void 0 && (i3 = f2.caret !== void 0 ? f2.caret : i3);
                  }
                }
                if (e4 !== void 0 && (e4.inputmask._valueSet(t3.join("")), i3 === void 0 || a3 !== void 0 && a3.type === "blur" || o.caret.call(s2, e4, i3, void 0, void 0, a3 !== void 0 && a3.type === "keydown" && (a3.keyCode === n.default.DELETE || a3.keyCode === n.default.BACKSPACE)), r2 === true)) {
                  var p2 = c2(e4), h = e4.inputmask._valueGet();
                  e4.inputmask.skipInputEvent = true, p2.trigger("input"), setTimeout(function() {
                    h === o.getBufferTemplate.call(s2).join("") ? p2.trigger("cleared") : l.isComplete.call(s2, t3) === true && p2.trigger("complete");
                  }, 0);
                }
              }
            },
            2394: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = void 0, i2(7149), i2(3194);
              var a2 = i2(157), n = m(i2(4963)), r = m(i2(9380)), o = i2(2391), l = i2(4713), s = i2(8711), u = i2(7215), c = i2(7760), f = i2(9716), d = m(i2(7392)), p = m(i2(3976)), h = m(i2(8741));
              function v(e4) {
                return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e5) {
                  return typeof e5;
                } : function(e5) {
                  return e5 && typeof Symbol == "function" && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                }, v(e4);
              }
              function m(e4) {
                return e4 && e4.__esModule ? e4 : {
                  default: e4
                };
              }
              var g = r.default.document, k = "_inputmask_opts";
              function y(e4, t3, i3) {
                if (h.default) {
                  if (!(this instanceof y))
                    return new y(e4, t3, i3);
                  this.dependencyLib = n.default, this.el = void 0, this.events = {}, this.maskset = void 0, i3 !== true && (Object.prototype.toString.call(e4) === "[object Object]" ? t3 = e4 : (t3 = t3 || {}, e4 && (t3.alias = e4)), this.opts = n.default.extend(true, {}, this.defaults, t3), this.noMasksCache = t3 && t3.definitions !== void 0, this.userOptions = t3 || {}, b(this.opts.alias, t3, this.opts)), this.refreshValue = false, this.undoValue = void 0, this.$el = void 0, this.skipKeyPressEvent = false, this.skipInputEvent = false, this.validationEvent = false, this.ignorable = false, this.maxLength, this.mouseEnter = false, this.originalPlaceholder = void 0, this.isComposing = false;
                }
              }
              function b(e4, t3, i3) {
                var a3 = y.prototype.aliases[e4];
                return a3 ? (a3.alias && b(a3.alias, void 0, i3), n.default.extend(true, i3, a3), n.default.extend(true, i3, t3), true) : (i3.mask === null && (i3.mask = e4), false);
              }
              y.prototype = {
                dataAttribute: "data-inputmask",
                defaults: p.default,
                definitions: d.default,
                aliases: {},
                masksCache: {},
                get isRTL() {
                  return this.opts.isRTL || this.opts.numericInput;
                },
                mask: function(e4) {
                  var t3 = this;
                  return typeof e4 == "string" && (e4 = g.getElementById(e4) || g.querySelectorAll(e4)), (e4 = e4.nodeName ? [e4] : Array.isArray(e4) ? e4 : Array.from(e4)).forEach(function(e5, i3) {
                    var l2 = n.default.extend(true, {}, t3.opts);
                    if (function(e6, t4, i4, a3) {
                      function o2(t5, n2) {
                        var o3 = a3 === "" ? t5 : a3 + "-" + t5;
                        (n2 = n2 !== void 0 ? n2 : e6.getAttribute(o3)) !== null && (typeof n2 == "string" && (t5.indexOf("on") === 0 ? n2 = r.default[n2] : n2 === "false" ? n2 = false : n2 === "true" && (n2 = true)), i4[t5] = n2);
                      }
                      if (t4.importDataAttributes === true) {
                        var l3, s3, u2, c2, f2 = e6.getAttribute(a3);
                        if (f2 && f2 !== "" && (f2 = f2.replace(/'/g, '"'), s3 = JSON.parse("{" + f2 + "}")), s3) {
                          for (c2 in u2 = void 0, s3)
                            if (c2.toLowerCase() === "alias") {
                              u2 = s3[c2];
                              break;
                            }
                        }
                        for (l3 in o2("alias", u2), i4.alias && b(i4.alias, i4, t4), t4) {
                          if (s3) {
                            for (c2 in u2 = void 0, s3)
                              if (c2.toLowerCase() === l3.toLowerCase()) {
                                u2 = s3[c2];
                                break;
                              }
                          }
                          o2(l3, u2);
                        }
                      }
                      n.default.extend(true, t4, i4), (e6.dir === "rtl" || t4.rightAlign) && (e6.style.textAlign = "right");
                      (e6.dir === "rtl" || t4.numericInput) && (e6.dir = "ltr", e6.removeAttribute("dir"), t4.isRTL = true);
                      return Object.keys(i4).length;
                    }(e5, l2, n.default.extend(true, {}, t3.userOptions), t3.dataAttribute)) {
                      var s2 = (0, o.generateMaskSet)(l2, t3.noMasksCache);
                      s2 !== void 0 && (e5.inputmask !== void 0 && (e5.inputmask.opts.autoUnmask = true, e5.inputmask.remove()), e5.inputmask = new y(void 0, void 0, true), e5.inputmask.opts = l2, e5.inputmask.noMasksCache = t3.noMasksCache, e5.inputmask.userOptions = n.default.extend(true, {}, t3.userOptions), e5.inputmask.el = e5, e5.inputmask.$el = (0, n.default)(e5), e5.inputmask.maskset = s2, n.default.data(e5, k, t3.userOptions), a2.mask.call(e5.inputmask));
                    }
                  }), e4 && e4[0] && e4[0].inputmask || this;
                },
                option: function(e4, t3) {
                  return typeof e4 == "string" ? this.opts[e4] : v(e4) === "object" ? (n.default.extend(this.userOptions, e4), this.el && t3 !== true && this.mask(this.el), this) : void 0;
                },
                unmaskedvalue: function(e4) {
                  if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), this.el === void 0 || e4 !== void 0) {
                    var t3 = (typeof this.opts.onBeforeMask == "function" && this.opts.onBeforeMask.call(this, e4, this.opts) || e4).split("");
                    c.checkVal.call(this, void 0, false, false, t3), typeof this.opts.onBeforeWrite == "function" && this.opts.onBeforeWrite.call(this, void 0, s.getBuffer.call(this), 0, this.opts);
                  }
                  return c.unmaskedvalue.call(this, this.el);
                },
                remove: function() {
                  if (this.el) {
                    n.default.data(this.el, k, null);
                    var e4 = this.opts.autoUnmask ? (0, c.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
                    e4 !== s.getBufferTemplate.call(this).join("") ? this._valueSet(e4, this.opts.autoUnmask) : this._valueSet(""), f.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value") && this.__valueGet && Object.defineProperty(this.el, "value", {
                      get: this.__valueGet,
                      set: this.__valueSet,
                      configurable: true
                    }) : g.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet), this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0;
                  }
                  return this.el;
                },
                getemptymask: function() {
                  return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), s.getBufferTemplate.call(this).join("");
                },
                hasMaskedValue: function() {
                  return !this.opts.autoUnmask;
                },
                isComplete: function() {
                  return this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), u.isComplete.call(this, s.getBuffer.call(this));
                },
                getmetadata: function() {
                  if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), Array.isArray(this.maskset.metadata)) {
                    var e4 = l.getMaskTemplate.call(this, true, 0, false).join("");
                    return this.maskset.metadata.forEach(function(t3) {
                      return t3.mask !== e4 || (e4 = t3, false);
                    }), e4;
                  }
                  return this.maskset.metadata;
                },
                isValid: function(e4) {
                  if (this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache), e4) {
                    var t3 = (typeof this.opts.onBeforeMask == "function" && this.opts.onBeforeMask.call(this, e4, this.opts) || e4).split("");
                    c.checkVal.call(this, void 0, true, false, t3);
                  } else
                    e4 = this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join("");
                  for (var i3 = s.getBuffer.call(this), a3 = s.determineLastRequiredPosition.call(this), n2 = i3.length - 1; n2 > a3 && !s.isMask.call(this, n2); n2--)
                    ;
                  return i3.splice(a3, n2 + 1 - a3), u.isComplete.call(this, i3) && e4 === (this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join(""));
                },
                format: function(e4, t3) {
                  this.maskset = this.maskset || (0, o.generateMaskSet)(this.opts, this.noMasksCache);
                  var i3 = (typeof this.opts.onBeforeMask == "function" && this.opts.onBeforeMask.call(this, e4, this.opts) || e4).split("");
                  c.checkVal.call(this, void 0, true, false, i3);
                  var a3 = this.isRTL ? s.getBuffer.call(this).slice().reverse().join("") : s.getBuffer.call(this).join("");
                  return t3 ? {
                    value: a3,
                    metadata: this.getmetadata()
                  } : a3;
                },
                setValue: function(e4) {
                  this.el && (0, n.default)(this.el).trigger("setvalue", [e4]);
                },
                analyseMask: o.analyseMask
              }, y.extendDefaults = function(e4) {
                n.default.extend(true, y.prototype.defaults, e4);
              }, y.extendDefinitions = function(e4) {
                n.default.extend(true, y.prototype.definitions, e4);
              }, y.extendAliases = function(e4) {
                n.default.extend(true, y.prototype.aliases, e4);
              }, y.format = function(e4, t3, i3) {
                return y(t3).format(e4, i3);
              }, y.unmask = function(e4, t3) {
                return y(t3).unmaskedvalue(e4);
              }, y.isValid = function(e4, t3) {
                return y(t3).isValid(e4);
              }, y.remove = function(e4) {
                typeof e4 == "string" && (e4 = g.getElementById(e4) || g.querySelectorAll(e4)), (e4 = e4.nodeName ? [e4] : e4).forEach(function(e5) {
                  e5.inputmask && e5.inputmask.remove();
                });
              }, y.setValue = function(e4, t3) {
                typeof e4 == "string" && (e4 = g.getElementById(e4) || g.querySelectorAll(e4)), (e4 = e4.nodeName ? [e4] : e4).forEach(function(e5) {
                  e5.inputmask ? e5.inputmask.setValue(t3) : (0, n.default)(e5).trigger("setvalue", [t3]);
                });
              }, y.dependencyLib = n.default, r.default.Inputmask = y;
              var x = y;
              t2.default = x;
            },
            5296: function(e3, t2, i2) {
              function a2(e4) {
                return a2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e5) {
                  return typeof e5;
                } : function(e5) {
                  return e5 && typeof Symbol == "function" && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
                }, a2(e4);
              }
              var n = h(i2(9380)), r = h(i2(2394)), o = h(i2(8741));
              function l(e4, t3) {
                for (var i3 = 0; i3 < t3.length; i3++) {
                  var a3 = t3[i3];
                  a3.enumerable = a3.enumerable || false, a3.configurable = true, "value" in a3 && (a3.writable = true), Object.defineProperty(e4, a3.key, a3);
                }
              }
              function s(e4, t3) {
                if (t3 && (a2(t3) === "object" || typeof t3 == "function"))
                  return t3;
                if (t3 !== void 0)
                  throw new TypeError("Derived constructors may only return object or undefined");
                return function(e5) {
                  if (e5 === void 0)
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return e5;
                }(e4);
              }
              function u(e4) {
                var t3 = typeof Map == "function" ? new Map() : void 0;
                return u = function(e5) {
                  if (e5 === null || (i3 = e5, Function.toString.call(i3).indexOf("[native code]") === -1))
                    return e5;
                  var i3;
                  if (typeof e5 != "function")
                    throw new TypeError("Super expression must either be null or a function");
                  if (t3 !== void 0) {
                    if (t3.has(e5))
                      return t3.get(e5);
                    t3.set(e5, a3);
                  }
                  function a3() {
                    return c(e5, arguments, p(this).constructor);
                  }
                  return a3.prototype = Object.create(e5.prototype, {
                    constructor: {
                      value: a3,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  }), d(a3, e5);
                }, u(e4);
              }
              function c(e4, t3, i3) {
                return c = f() ? Reflect.construct : function(e5, t4, i4) {
                  var a3 = [null];
                  a3.push.apply(a3, t4);
                  var n2 = new (Function.bind.apply(e5, a3))();
                  return i4 && d(n2, i4.prototype), n2;
                }, c.apply(null, arguments);
              }
              function f() {
                if (typeof Reflect == "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy == "function")
                  return true;
                try {
                  return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  })), true;
                } catch (e4) {
                  return false;
                }
              }
              function d(e4, t3) {
                return d = Object.setPrototypeOf || function(e5, t4) {
                  return e5.__proto__ = t4, e5;
                }, d(e4, t3);
              }
              function p(e4) {
                return p = Object.setPrototypeOf ? Object.getPrototypeOf : function(e5) {
                  return e5.__proto__ || Object.getPrototypeOf(e5);
                }, p(e4);
              }
              function h(e4) {
                return e4 && e4.__esModule ? e4 : {
                  default: e4
                };
              }
              var v = n.default.document;
              if (o.default && v && v.head && v.head.attachShadow && n.default.customElements && n.default.customElements.get("input-mask") === void 0) {
                var m = function(e4) {
                  !function(e5, t4) {
                    if (typeof t4 != "function" && t4 !== null)
                      throw new TypeError("Super expression must either be null or a function");
                    Object.defineProperty(e5, "prototype", {
                      value: Object.create(t4 && t4.prototype, {
                        constructor: {
                          value: e5,
                          writable: true,
                          configurable: true
                        }
                      }),
                      writable: false
                    }), t4 && d(e5, t4);
                  }(c2, e4);
                  var t3, i3, a3, n2, o2, u2 = (t3 = c2, i3 = f(), function() {
                    var e5, a4 = p(t3);
                    if (i3) {
                      var n3 = p(this).constructor;
                      e5 = Reflect.construct(a4, arguments, n3);
                    } else
                      e5 = a4.apply(this, arguments);
                    return s(this, e5);
                  });
                  function c2() {
                    var e5;
                    !function(e6, t5) {
                      if (!(e6 instanceof t5))
                        throw new TypeError("Cannot call a class as a function");
                    }(this, c2);
                    var t4 = (e5 = u2.call(this)).getAttributeNames(), i4 = e5.attachShadow({
                      mode: "closed"
                    }), a4 = v.createElement("input");
                    for (var n3 in a4.type = "text", i4.appendChild(a4), t4)
                      Object.prototype.hasOwnProperty.call(t4, n3) && a4.setAttribute(t4[n3], e5.getAttribute(t4[n3]));
                    var o3 = new r.default();
                    return o3.dataAttribute = "", o3.mask(a4), a4.inputmask.shadowRoot = i4, e5;
                  }
                  return a3 = c2, n2 && l(a3.prototype, n2), o2 && l(a3, o2), Object.defineProperty(a3, "prototype", {
                    writable: false
                  }), a3;
                }(u(HTMLElement));
                n.default.customElements.define("input-mask", m);
              }
            },
            2391: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.analyseMask = function(e4, t3, i3) {
                var a3, o2, l, s, u, c, f = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g, d = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, p = false, h = new n.default(), v = [], m = [], g = false;
                function k(e5, a4, n2) {
                  n2 = n2 !== void 0 ? n2 : e5.matches.length;
                  var o3 = e5.matches[n2 - 1];
                  if (t3)
                    a4.indexOf("[") === 0 || p && /\\d|\\s|\\w/i.test(a4) || a4 === "." ? e5.matches.splice(n2++, 0, {
                      fn: new RegExp(a4, i3.casing ? "i" : ""),
                      static: false,
                      optionality: false,
                      newBlockMarker: o3 === void 0 ? "master" : o3.def !== a4,
                      casing: null,
                      def: a4,
                      placeholder: void 0,
                      nativeDef: a4
                    }) : (p && (a4 = a4[a4.length - 1]), a4.split("").forEach(function(t4, a5) {
                      o3 = e5.matches[n2 - 1], e5.matches.splice(n2++, 0, {
                        fn: /[a-z]/i.test(i3.staticDefinitionSymbol || t4) ? new RegExp("[" + (i3.staticDefinitionSymbol || t4) + "]", i3.casing ? "i" : "") : null,
                        static: true,
                        optionality: false,
                        newBlockMarker: o3 === void 0 ? "master" : o3.def !== t4 && o3.static !== true,
                        casing: null,
                        def: i3.staticDefinitionSymbol || t4,
                        placeholder: i3.staticDefinitionSymbol !== void 0 ? t4 : void 0,
                        nativeDef: (p ? "'" : "") + t4
                      });
                    })), p = false;
                  else {
                    var l2 = i3.definitions && i3.definitions[a4] || i3.usePrototypeDefinitions && r.default.prototype.definitions[a4];
                    l2 && !p ? e5.matches.splice(n2++, 0, {
                      fn: l2.validator ? typeof l2.validator == "string" ? new RegExp(l2.validator, i3.casing ? "i" : "") : new function() {
                        this.test = l2.validator;
                      }() : new RegExp("."),
                      static: l2.static || false,
                      optionality: l2.optional || false,
                      newBlockMarker: o3 === void 0 || l2.optional ? "master" : o3.def !== (l2.definitionSymbol || a4),
                      casing: l2.casing,
                      def: l2.definitionSymbol || a4,
                      placeholder: l2.placeholder,
                      nativeDef: a4,
                      generated: l2.generated
                    }) : (e5.matches.splice(n2++, 0, {
                      fn: /[a-z]/i.test(i3.staticDefinitionSymbol || a4) ? new RegExp("[" + (i3.staticDefinitionSymbol || a4) + "]", i3.casing ? "i" : "") : null,
                      static: true,
                      optionality: false,
                      newBlockMarker: o3 === void 0 ? "master" : o3.def !== a4 && o3.static !== true,
                      casing: null,
                      def: i3.staticDefinitionSymbol || a4,
                      placeholder: i3.staticDefinitionSymbol !== void 0 ? a4 : void 0,
                      nativeDef: (p ? "'" : "") + a4
                    }), p = false);
                  }
                }
                function y() {
                  if (v.length > 0) {
                    if (k(s = v[v.length - 1], o2), s.isAlternator) {
                      u = v.pop();
                      for (var e5 = 0; e5 < u.matches.length; e5++)
                        u.matches[e5].isGroup && (u.matches[e5].isGroup = false);
                      v.length > 0 ? (s = v[v.length - 1]).matches.push(u) : h.matches.push(u);
                    }
                  } else
                    k(h, o2);
                }
                function b(e5) {
                  var t4 = new n.default(true);
                  return t4.openGroup = false, t4.matches = e5, t4;
                }
                function x() {
                  if ((l = v.pop()).openGroup = false, l !== void 0)
                    if (v.length > 0) {
                      if ((s = v[v.length - 1]).matches.push(l), s.isAlternator) {
                        for (var e5 = (u = v.pop()).matches[0].matches ? u.matches[0].matches.length : 1, t4 = 0; t4 < u.matches.length; t4++)
                          u.matches[t4].isGroup = false, u.matches[t4].alternatorGroup = false, i3.keepStatic === null && e5 < (u.matches[t4].matches ? u.matches[t4].matches.length : 1) && (i3.keepStatic = true), e5 = u.matches[t4].matches ? u.matches[t4].matches.length : 1;
                        v.length > 0 ? (s = v[v.length - 1]).matches.push(u) : h.matches.push(u);
                      }
                    } else
                      h.matches.push(l);
                  else
                    y();
                }
                function P(e5) {
                  var t4 = e5.pop();
                  return t4.isQuantifier && (t4 = b([e5.pop(), t4])), t4;
                }
                t3 && (i3.optionalmarker[0] = void 0, i3.optionalmarker[1] = void 0);
                for (; a3 = t3 ? d.exec(e4) : f.exec(e4); ) {
                  if (o2 = a3[0], t3) {
                    switch (o2.charAt(0)) {
                      case "?":
                        o2 = "{0,1}";
                        break;
                      case "+":
                      case "*":
                        o2 = "{" + o2 + "}";
                        break;
                      case "|":
                        if (v.length === 0) {
                          var E = b(h.matches);
                          E.openGroup = true, v.push(E), h.matches = [], g = true;
                        }
                    }
                    if (o2 === "\\d")
                      o2 = "[0-9]";
                  }
                  if (p)
                    y();
                  else
                    switch (o2.charAt(0)) {
                      case "$":
                      case "^":
                        t3 || y();
                        break;
                      case i3.escapeChar:
                        p = true, t3 && y();
                        break;
                      case i3.optionalmarker[1]:
                      case i3.groupmarker[1]:
                        x();
                        break;
                      case i3.optionalmarker[0]:
                        v.push(new n.default(false, true));
                        break;
                      case i3.groupmarker[0]:
                        v.push(new n.default(true));
                        break;
                      case i3.quantifiermarker[0]:
                        var S = new n.default(false, false, true), _ = (o2 = o2.replace(/[{}?]/g, "")).split("|"), w = _[0].split(","), M = isNaN(w[0]) ? w[0] : parseInt(w[0]), O = w.length === 1 ? M : isNaN(w[1]) ? w[1] : parseInt(w[1]), T = isNaN(_[1]) ? _[1] : parseInt(_[1]);
                        M !== "*" && M !== "+" || (M = O === "*" ? 0 : 1), S.quantifier = {
                          min: M,
                          max: O,
                          jit: T
                        };
                        var C = v.length > 0 ? v[v.length - 1].matches : h.matches;
                        if ((a3 = C.pop()).isAlternator) {
                          C.push(a3), C = a3.matches;
                          var A = new n.default(true), D = C.pop();
                          C.push(A), C = A.matches, a3 = D;
                        }
                        a3.isGroup || (a3 = b([a3])), C.push(a3), C.push(S);
                        break;
                      case i3.alternatormarker:
                        if (v.length > 0) {
                          var j = (s = v[v.length - 1]).matches[s.matches.length - 1];
                          c = s.openGroup && (j.matches === void 0 || j.isGroup === false && j.isAlternator === false) ? v.pop() : P(s.matches);
                        } else
                          c = P(h.matches);
                        if (c.isAlternator)
                          v.push(c);
                        else if (c.alternatorGroup ? (u = v.pop(), c.alternatorGroup = false) : u = new n.default(false, false, false, true), u.matches.push(c), v.push(u), c.openGroup) {
                          c.openGroup = false;
                          var B = new n.default(true);
                          B.alternatorGroup = true, v.push(B);
                        }
                        break;
                      default:
                        y();
                    }
                }
                g && x();
                for (; v.length > 0; )
                  l = v.pop(), h.matches.push(l);
                h.matches.length > 0 && (!function e5(a4) {
                  a4 && a4.matches && a4.matches.forEach(function(n2, r2) {
                    var o3 = a4.matches[r2 + 1];
                    (o3 === void 0 || o3.matches === void 0 || o3.isQuantifier === false) && n2 && n2.isGroup && (n2.isGroup = false, t3 || (k(n2, i3.groupmarker[0], 0), n2.openGroup !== true && k(n2, i3.groupmarker[1]))), e5(n2);
                  });
                }(h), m.push(h));
                (i3.numericInput || i3.isRTL) && function e5(t4) {
                  for (var a4 in t4.matches = t4.matches.reverse(), t4.matches)
                    if (Object.prototype.hasOwnProperty.call(t4.matches, a4)) {
                      var n2 = parseInt(a4);
                      if (t4.matches[a4].isQuantifier && t4.matches[n2 + 1] && t4.matches[n2 + 1].isGroup) {
                        var r2 = t4.matches[a4];
                        t4.matches.splice(a4, 1), t4.matches.splice(n2 + 1, 0, r2);
                      }
                      t4.matches[a4].matches !== void 0 ? t4.matches[a4] = e5(t4.matches[a4]) : t4.matches[a4] = ((o3 = t4.matches[a4]) === i3.optionalmarker[0] ? o3 = i3.optionalmarker[1] : o3 === i3.optionalmarker[1] ? o3 = i3.optionalmarker[0] : o3 === i3.groupmarker[0] ? o3 = i3.groupmarker[1] : o3 === i3.groupmarker[1] && (o3 = i3.groupmarker[0]), o3);
                    }
                  var o3;
                  return t4;
                }(m[0]);
                return m;
              }, t2.generateMaskSet = function(e4, t3) {
                var i3;
                function n2(e5, i4, n3) {
                  var o3, l, s = false;
                  if (e5 !== null && e5 !== "" || ((s = n3.regex !== null) ? e5 = (e5 = n3.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (s = true, e5 = ".*")), e5.length === 1 && n3.greedy === false && n3.repeat !== 0 && (n3.placeholder = ""), n3.repeat > 0 || n3.repeat === "*" || n3.repeat === "+") {
                    var u = n3.repeat === "*" ? 0 : n3.repeat === "+" ? 1 : n3.repeat;
                    e5 = n3.groupmarker[0] + e5 + n3.groupmarker[1] + n3.quantifiermarker[0] + u + "," + n3.repeat + n3.quantifiermarker[1];
                  }
                  return l = s ? "regex_" + n3.regex : n3.numericInput ? e5.split("").reverse().join("") : e5, n3.keepStatic !== null && (l = "ks_" + n3.keepStatic + l), r.default.prototype.masksCache[l] === void 0 || t3 === true ? (o3 = {
                    mask: e5,
                    maskToken: r.default.prototype.analyseMask(e5, s, n3),
                    validPositions: {},
                    _buffer: void 0,
                    buffer: void 0,
                    tests: {},
                    excludes: {},
                    metadata: i4,
                    maskLength: void 0,
                    jitOffset: {}
                  }, t3 !== true && (r.default.prototype.masksCache[l] = o3, o3 = a2.default.extend(true, {}, r.default.prototype.masksCache[l]))) : o3 = a2.default.extend(true, {}, r.default.prototype.masksCache[l]), o3;
                }
                typeof e4.mask == "function" && (e4.mask = e4.mask(e4));
                if (Array.isArray(e4.mask)) {
                  if (e4.mask.length > 1) {
                    e4.keepStatic === null && (e4.keepStatic = true);
                    var o2 = e4.groupmarker[0];
                    return (e4.isRTL ? e4.mask.reverse() : e4.mask).forEach(function(t4) {
                      o2.length > 1 && (o2 += e4.alternatormarker), t4.mask !== void 0 && typeof t4.mask != "function" ? o2 += t4.mask : o2 += t4;
                    }), n2(o2 += e4.groupmarker[1], e4.mask, e4);
                  }
                  e4.mask = e4.mask.pop();
                }
                i3 = e4.mask && e4.mask.mask !== void 0 && typeof e4.mask.mask != "function" ? n2(e4.mask.mask, e4.mask, e4) : n2(e4.mask, e4.mask, e4);
                e4.keepStatic === null && (e4.keepStatic = false);
                return i3;
              };
              var a2 = o(i2(4963)), n = o(i2(9695)), r = o(i2(2394));
              function o(e4) {
                return e4 && e4.__esModule ? e4 : {
                  default: e4
                };
              }
            },
            157: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.mask = function() {
                var e4 = this, t3 = this.opts, i3 = this.el, a3 = this.dependencyLib;
                l.EventRuler.off(i3);
                var f = function(t4, i4) {
                  t4.tagName.toLowerCase() !== "textarea" && i4.ignorables.push(n.default.ENTER);
                  var s2 = t4.getAttribute("type"), u2 = t4.tagName.toLowerCase() === "input" && i4.supportsInputType.includes(s2) || t4.isContentEditable || t4.tagName.toLowerCase() === "textarea";
                  if (!u2)
                    if (t4.tagName.toLowerCase() === "input") {
                      var c2 = document.createElement("input");
                      c2.setAttribute("type", s2), u2 = c2.type === "text", c2 = null;
                    } else
                      u2 = "partial";
                  return u2 !== false ? function(t5) {
                    var n2, s3;
                    function u3() {
                      return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : r.getLastValidPosition.call(e4) !== -1 || i4.nullable !== true ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && i4.clearMaskOnLostFocus ? (e4.isRTL ? o.clearOptionalTail.call(e4, r.getBuffer.call(e4).slice()).reverse() : o.clearOptionalTail.call(e4, r.getBuffer.call(e4).slice())).join("") : n2.call(this) : "" : n2.call(this);
                    }
                    function c3(e5) {
                      s3.call(this, e5), this.inputmask && (0, o.applyInputValue)(this, e5);
                    }
                    if (!t5.inputmask.__valueGet) {
                      if (i4.noValuePatching !== true) {
                        if (Object.getOwnPropertyDescriptor) {
                          var f2 = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t5), "value") : void 0;
                          f2 && f2.get && f2.set ? (n2 = f2.get, s3 = f2.set, Object.defineProperty(t5, "value", {
                            get: u3,
                            set: c3,
                            configurable: true
                          })) : t5.tagName.toLowerCase() !== "input" && (n2 = function() {
                            return this.textContent;
                          }, s3 = function(e5) {
                            this.textContent = e5;
                          }, Object.defineProperty(t5, "value", {
                            get: u3,
                            set: c3,
                            configurable: true
                          }));
                        } else
                          document.__lookupGetter__ && t5.__lookupGetter__("value") && (n2 = t5.__lookupGetter__("value"), s3 = t5.__lookupSetter__("value"), t5.__defineGetter__("value", u3), t5.__defineSetter__("value", c3));
                        t5.inputmask.__valueGet = n2, t5.inputmask.__valueSet = s3;
                      }
                      t5.inputmask._valueGet = function(t6) {
                        return e4.isRTL && t6 !== true ? n2.call(this.el).split("").reverse().join("") : n2.call(this.el);
                      }, t5.inputmask._valueSet = function(t6, i5) {
                        s3.call(this.el, t6 == null ? "" : i5 !== true && e4.isRTL ? t6.split("").reverse().join("") : t6);
                      }, n2 === void 0 && (n2 = function() {
                        return this.value;
                      }, s3 = function(e5) {
                        this.value = e5;
                      }, function(t6) {
                        if (a3.valHooks && (a3.valHooks[t6] === void 0 || a3.valHooks[t6].inputmaskpatch !== true)) {
                          var n3 = a3.valHooks[t6] && a3.valHooks[t6].get ? a3.valHooks[t6].get : function(e5) {
                            return e5.value;
                          }, l2 = a3.valHooks[t6] && a3.valHooks[t6].set ? a3.valHooks[t6].set : function(e5, t7) {
                            return e5.value = t7, e5;
                          };
                          a3.valHooks[t6] = {
                            get: function(t7) {
                              if (t7.inputmask) {
                                if (t7.inputmask.opts.autoUnmask)
                                  return t7.inputmask.unmaskedvalue();
                                var a4 = n3(t7);
                                return r.getLastValidPosition.call(e4, void 0, void 0, t7.inputmask.maskset.validPositions) !== -1 || i4.nullable !== true ? a4 : "";
                              }
                              return n3(t7);
                            },
                            set: function(e5, t7) {
                              var i5 = l2(e5, t7);
                              return e5.inputmask && (0, o.applyInputValue)(e5, t7), i5;
                            },
                            inputmaskpatch: true
                          };
                        }
                      }(t5.type), function(t6) {
                        l.EventRuler.on(t6, "mouseenter", function() {
                          var t7 = this.inputmask._valueGet(true);
                          t7 !== (e4.isRTL ? r.getBuffer.call(e4).reverse() : r.getBuffer.call(e4)).join("") && (0, o.applyInputValue)(this, t7);
                        });
                      }(t5));
                    }
                  }(t4) : t4.inputmask = void 0, u2;
                }(i3, t3);
                if (f !== false) {
                  e4.originalPlaceholder = i3.placeholder, e4.maxLength = i3 !== void 0 ? i3.maxLength : void 0, e4.maxLength === -1 && (e4.maxLength = void 0), "inputMode" in i3 && i3.getAttribute("inputmode") === null && (i3.inputMode = t3.inputmode, i3.setAttribute("inputmode", t3.inputmode)), f === true && (t3.showMaskOnFocus = t3.showMaskOnFocus && ["cc-number", "cc-exp"].indexOf(i3.autocomplete) === -1, s.iphone && (t3.insertModeVisual = false), l.EventRuler.on(i3, "submit", c.EventHandlers.submitEvent), l.EventRuler.on(i3, "reset", c.EventHandlers.resetEvent), l.EventRuler.on(i3, "blur", c.EventHandlers.blurEvent), l.EventRuler.on(i3, "focus", c.EventHandlers.focusEvent), l.EventRuler.on(i3, "invalid", c.EventHandlers.invalidEvent), l.EventRuler.on(i3, "click", c.EventHandlers.clickEvent), l.EventRuler.on(i3, "mouseleave", c.EventHandlers.mouseleaveEvent), l.EventRuler.on(i3, "mouseenter", c.EventHandlers.mouseenterEvent), l.EventRuler.on(i3, "paste", c.EventHandlers.pasteEvent), l.EventRuler.on(i3, "cut", c.EventHandlers.cutEvent), l.EventRuler.on(i3, "complete", t3.oncomplete), l.EventRuler.on(i3, "incomplete", t3.onincomplete), l.EventRuler.on(i3, "cleared", t3.oncleared), t3.inputEventOnly !== true && (l.EventRuler.on(i3, "keydown", c.EventHandlers.keydownEvent), l.EventRuler.on(i3, "keypress", c.EventHandlers.keypressEvent), l.EventRuler.on(i3, "keyup", c.EventHandlers.keyupEvent)), (s.mobile || t3.inputEventOnly) && i3.removeAttribute("maxLength"), l.EventRuler.on(i3, "input", c.EventHandlers.inputFallBackEvent), l.EventRuler.on(i3, "compositionend", c.EventHandlers.compositionendEvent)), l.EventRuler.on(i3, "setvalue", c.EventHandlers.setValueEvent), r.getBufferTemplate.call(e4).join(""), e4.undoValue = e4._valueGet(true);
                  var d = (i3.inputmask.shadowRoot || i3.ownerDocument).activeElement;
                  if (i3.inputmask._valueGet(true) !== "" || t3.clearMaskOnLostFocus === false || d === i3) {
                    (0, o.applyInputValue)(i3, i3.inputmask._valueGet(true), t3);
                    var p = r.getBuffer.call(e4).slice();
                    u.isComplete.call(e4, p) === false && t3.clearIncomplete && r.resetMaskSet.call(e4), t3.clearMaskOnLostFocus && d !== i3 && (r.getLastValidPosition.call(e4) === -1 ? p = [] : o.clearOptionalTail.call(e4, p)), (t3.clearMaskOnLostFocus === false || t3.showMaskOnFocus && d === i3 || i3.inputmask._valueGet(true) !== "") && (0, o.writeBuffer)(i3, p), d === i3 && r.caret.call(e4, i3, r.seekNext.call(e4, r.getLastValidPosition.call(e4)));
                  }
                }
              };
              var a2, n = (a2 = i2(5581)) && a2.__esModule ? a2 : {
                default: a2
              }, r = i2(8711), o = i2(7760), l = i2(9716), s = i2(9845), u = i2(7215), c = i2(6030);
            },
            9695: function(e3, t2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.default = function(e4, t3, i2, a2) {
                this.matches = [], this.openGroup = e4 || false, this.alternatorGroup = false, this.isGroup = e4 || false, this.isOptional = t3 || false, this.isQuantifier = i2 || false, this.isAlternator = a2 || false, this.quantifier = {
                  min: 1,
                  max: 1
                };
              };
            },
            3194: function() {
              Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
                value: function(e3, t2) {
                  if (this == null)
                    throw new TypeError('"this" is null or not defined');
                  var i2 = Object(this), a2 = i2.length >>> 0;
                  if (a2 === 0)
                    return false;
                  for (var n = 0 | t2, r = Math.max(n >= 0 ? n : a2 - Math.abs(n), 0); r < a2; ) {
                    if (i2[r] === e3)
                      return true;
                    r++;
                  }
                  return false;
                }
              });
            },
            7149: function() {
              function e3(t2) {
                return e3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
                  return typeof e4;
                } : function(e4) {
                  return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
                }, e3(t2);
              }
              typeof Object.getPrototypeOf != "function" && (Object.getPrototypeOf = e3("test".__proto__) === "object" ? function(e4) {
                return e4.__proto__;
              } : function(e4) {
                return e4.constructor.prototype;
              });
            },
            8711: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.caret = function(e4, t3, i3, a3, n2) {
                var r2, o2 = this, l2 = this.opts;
                if (t3 === void 0)
                  return "selectionStart" in e4 && "selectionEnd" in e4 ? (t3 = e4.selectionStart, i3 = e4.selectionEnd) : window.getSelection ? (r2 = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e4 && r2.commonAncestorContainer !== e4 || (t3 = r2.startOffset, i3 = r2.endOffset) : document.selection && document.selection.createRange && (r2 = document.selection.createRange(), t3 = 0 - r2.duplicate().moveStart("character", -e4.inputmask._valueGet().length), i3 = t3 + r2.text.length), {
                    begin: a3 ? t3 : u.call(o2, t3),
                    end: a3 ? i3 : u.call(o2, i3)
                  };
                if (Array.isArray(t3) && (i3 = o2.isRTL ? t3[0] : t3[1], t3 = o2.isRTL ? t3[1] : t3[0]), t3.begin !== void 0 && (i3 = o2.isRTL ? t3.begin : t3.end, t3 = o2.isRTL ? t3.end : t3.begin), typeof t3 == "number") {
                  t3 = a3 ? t3 : u.call(o2, t3), i3 = typeof (i3 = a3 ? i3 : u.call(o2, i3)) == "number" ? i3 : t3;
                  var s2 = parseInt(((e4.ownerDocument.defaultView || window).getComputedStyle ? (e4.ownerDocument.defaultView || window).getComputedStyle(e4, null) : e4.currentStyle).fontSize) * i3;
                  if (e4.scrollLeft = s2 > e4.scrollWidth ? s2 : 0, e4.inputmask.caretPos = {
                    begin: t3,
                    end: i3
                  }, l2.insertModeVisual && l2.insertMode === false && t3 === i3 && (n2 || i3++), e4 === (e4.inputmask.shadowRoot || e4.ownerDocument).activeElement)
                    if ("setSelectionRange" in e4)
                      e4.setSelectionRange(t3, i3);
                    else if (window.getSelection) {
                      if (r2 = document.createRange(), e4.firstChild === void 0 || e4.firstChild === null) {
                        var c = document.createTextNode("");
                        e4.appendChild(c);
                      }
                      r2.setStart(e4.firstChild, t3 < e4.inputmask._valueGet().length ? t3 : e4.inputmask._valueGet().length), r2.setEnd(e4.firstChild, i3 < e4.inputmask._valueGet().length ? i3 : e4.inputmask._valueGet().length), r2.collapse(true);
                      var f = window.getSelection();
                      f.removeAllRanges(), f.addRange(r2);
                    } else
                      e4.createTextRange && ((r2 = e4.createTextRange()).collapse(true), r2.moveEnd("character", i3), r2.moveStart("character", t3), r2.select());
                }
              }, t2.determineLastRequiredPosition = function(e4) {
                var t3, i3, r2 = this, l2 = this.maskset, s2 = this.dependencyLib, u2 = a2.getMaskTemplate.call(r2, true, o.call(r2), true, true), c = u2.length, f = o.call(r2), d = {}, p = l2.validPositions[f], h = p !== void 0 ? p.locator.slice() : void 0;
                for (t3 = f + 1; t3 < u2.length; t3++)
                  i3 = a2.getTestTemplate.call(r2, t3, h, t3 - 1), h = i3.locator.slice(), d[t3] = s2.extend(true, {}, i3);
                var v = p && p.alternation !== void 0 ? p.locator[p.alternation] : void 0;
                for (t3 = c - 1; t3 > f && (((i3 = d[t3]).match.optionality || i3.match.optionalQuantifier && i3.match.newBlockMarker || v && (v !== d[t3].locator[p.alternation] && i3.match.static != 1 || i3.match.static === true && i3.locator[p.alternation] && n.checkAlternationMatch.call(r2, i3.locator[p.alternation].toString().split(","), v.toString().split(",")) && a2.getTests.call(r2, t3)[0].def !== "")) && u2[t3] === a2.getPlaceholder.call(r2, t3, i3.match)); t3--)
                  c--;
                return e4 ? {
                  l: c,
                  def: d[c] ? d[c].match : void 0
                } : c;
              }, t2.determineNewCaretPosition = function(e4, t3, i3) {
                var n2 = this, u2 = this.maskset, c = this.opts;
                t3 && (n2.isRTL ? e4.end = e4.begin : e4.begin = e4.end);
                if (e4.begin === e4.end) {
                  switch (i3 = i3 || c.positionCaretOnClick) {
                    case "none":
                      break;
                    case "select":
                      e4 = {
                        begin: 0,
                        end: r.call(n2).length
                      };
                      break;
                    case "ignore":
                      e4.end = e4.begin = s.call(n2, o.call(n2));
                      break;
                    case "radixFocus":
                      if (function(e5) {
                        if (c.radixPoint !== "" && c.digits !== 0) {
                          var t4 = u2.validPositions;
                          if (t4[e5] === void 0 || t4[e5].input === a2.getPlaceholder.call(n2, e5)) {
                            if (e5 < s.call(n2, -1))
                              return true;
                            var i4 = r.call(n2).indexOf(c.radixPoint);
                            if (i4 !== -1) {
                              for (var o2 in t4)
                                if (t4[o2] && i4 < o2 && t4[o2].input !== a2.getPlaceholder.call(n2, o2))
                                  return false;
                              return true;
                            }
                          }
                        }
                        return false;
                      }(e4.begin)) {
                        var f = r.call(n2).join("").indexOf(c.radixPoint);
                        e4.end = e4.begin = c.numericInput ? s.call(n2, f) : f;
                        break;
                      }
                    default:
                      var d = e4.begin, p = o.call(n2, d, true), h = s.call(n2, p !== -1 || l.call(n2, 0) ? p : -1);
                      if (d <= h)
                        e4.end = e4.begin = l.call(n2, d, false, true) ? d : s.call(n2, d);
                      else {
                        var v = u2.validPositions[p], m = a2.getTestTemplate.call(n2, h, v ? v.match.locator : void 0, v), g = a2.getPlaceholder.call(n2, h, m.match);
                        if (g !== "" && r.call(n2)[h] !== g && m.match.optionalQuantifier !== true && m.match.newBlockMarker !== true || !l.call(n2, h, c.keepStatic, true) && m.match.def === g) {
                          var k = s.call(n2, h);
                          (d >= k || d === h) && (h = k);
                        }
                        e4.end = e4.begin = h;
                      }
                  }
                  return e4;
                }
              }, t2.getBuffer = r, t2.getBufferTemplate = function() {
                var e4 = this.maskset;
                e4._buffer === void 0 && (e4._buffer = a2.getMaskTemplate.call(this, false, 1), e4.buffer === void 0 && (e4.buffer = e4._buffer.slice()));
                return e4._buffer;
              }, t2.getLastValidPosition = o, t2.isMask = l, t2.resetMaskSet = function(e4) {
                var t3 = this.maskset;
                t3.buffer = void 0, e4 !== true && (t3.validPositions = {}, t3.p = 0);
              }, t2.seekNext = s, t2.seekPrevious = function(e4, t3) {
                var i3 = this, n2 = e4 - 1;
                if (e4 <= 0)
                  return 0;
                for (; n2 > 0 && (t3 === true && (a2.getTest.call(i3, n2).match.newBlockMarker !== true || !l.call(i3, n2, void 0, true)) || t3 !== true && !l.call(i3, n2, void 0, true)); )
                  n2--;
                return n2;
              }, t2.translatePosition = u;
              var a2 = i2(4713), n = i2(7215);
              function r(e4) {
                var t3 = this.maskset;
                return t3.buffer !== void 0 && e4 !== true || (t3.buffer = a2.getMaskTemplate.call(this, true, o.call(this), true), t3._buffer === void 0 && (t3._buffer = t3.buffer.slice())), t3.buffer;
              }
              function o(e4, t3, i3) {
                var a3 = this.maskset, n2 = -1, r2 = -1, o2 = i3 || a3.validPositions;
                for (var l2 in e4 === void 0 && (e4 = -1), o2) {
                  var s2 = parseInt(l2);
                  o2[s2] && (t3 || o2[s2].generatedInput !== true) && (s2 <= e4 && (n2 = s2), s2 >= e4 && (r2 = s2));
                }
                return n2 === -1 || n2 == e4 ? r2 : r2 == -1 || e4 - n2 < r2 - e4 ? n2 : r2;
              }
              function l(e4, t3, i3) {
                var n2 = this, r2 = this.maskset, o2 = a2.getTestTemplate.call(n2, e4).match;
                if (o2.def === "" && (o2 = a2.getTest.call(n2, e4).match), o2.static !== true)
                  return o2.fn;
                if (i3 === true && r2.validPositions[e4] !== void 0 && r2.validPositions[e4].generatedInput !== true)
                  return true;
                if (t3 !== true && e4 > -1) {
                  if (i3) {
                    var l2 = a2.getTests.call(n2, e4);
                    return l2.length > 1 + (l2[l2.length - 1].match.def === "" ? 1 : 0);
                  }
                  var s2 = a2.determineTestTemplate.call(n2, e4, a2.getTests.call(n2, e4)), u2 = a2.getPlaceholder.call(n2, e4, s2.match);
                  return s2.match.def !== u2;
                }
                return false;
              }
              function s(e4, t3, i3) {
                var n2 = this;
                i3 === void 0 && (i3 = true);
                for (var r2 = e4 + 1; a2.getTest.call(n2, r2).match.def !== "" && (t3 === true && (a2.getTest.call(n2, r2).match.newBlockMarker !== true || !l.call(n2, r2, void 0, true)) || t3 !== true && !l.call(n2, r2, void 0, i3)); )
                  r2++;
                return r2;
              }
              function u(e4) {
                var t3 = this.opts, i3 = this.el;
                return !this.isRTL || typeof e4 != "number" || t3.greedy && t3.placeholder === "" || !i3 || (e4 = Math.abs(this._valueGet().length - e4)), e4;
              }
            },
            4713: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.determineTestTemplate = u, t2.getDecisionTaker = o, t2.getMaskTemplate = function(e4, t3, i3, a3, n2) {
                var r2 = this, o2 = this.opts, c2 = this.maskset, f2 = o2.greedy;
                n2 && o2.greedy && (o2.greedy = false, r2.maskset.tests = {});
                t3 = t3 || 0;
                var p, h, v, m, g = [], k = 0;
                do {
                  if (e4 === true && c2.validPositions[k])
                    v = n2 && c2.validPositions[k].match.optionality && c2.validPositions[k + 1] === void 0 && (c2.validPositions[k].generatedInput === true || c2.validPositions[k].input == o2.skipOptionalPartCharacter && k > 0) ? u.call(r2, k, d.call(r2, k, p, k - 1)) : c2.validPositions[k], h = v.match, p = v.locator.slice(), g.push(i3 === true ? v.input : i3 === false ? h.nativeDef : l.call(r2, k, h));
                  else {
                    v = s.call(r2, k, p, k - 1), h = v.match, p = v.locator.slice();
                    var y = a3 !== true && (o2.jitMasking !== false ? o2.jitMasking : h.jit);
                    (m = (m && h.static && h.def !== o2.groupSeparator && h.fn === null || c2.validPositions[k - 1] && h.static && h.def !== o2.groupSeparator && h.fn === null) && c2.tests[k] && c2.tests[k].length === 1) || y === false || y === void 0 || typeof y == "number" && isFinite(y) && y > k ? g.push(i3 === false ? h.nativeDef : l.call(r2, k, h)) : m = false;
                  }
                  k++;
                } while (h.static !== true || h.def !== "" || t3 > k);
                g[g.length - 1] === "" && g.pop();
                i3 === false && c2.maskLength !== void 0 || (c2.maskLength = k - 1);
                return o2.greedy = f2, g;
              }, t2.getPlaceholder = l, t2.getTest = c, t2.getTestTemplate = s, t2.getTests = d, t2.isSubsetOf = f;
              var a2, n = (a2 = i2(2394)) && a2.__esModule ? a2 : {
                default: a2
              };
              function r(e4, t3) {
                var i3 = (e4.alternation != null ? e4.mloc[o(e4)] : e4.locator).join("");
                if (i3 !== "")
                  for (; i3.length < t3; )
                    i3 += "0";
                return i3;
              }
              function o(e4) {
                var t3 = e4.locator[e4.alternation];
                return typeof t3 == "string" && t3.length > 0 && (t3 = t3.split(",")[0]), t3 !== void 0 ? t3.toString() : "";
              }
              function l(e4, t3, i3) {
                var a3 = this.opts, n2 = this.maskset;
                if ((t3 = t3 || c.call(this, e4).match).placeholder !== void 0 || i3 === true)
                  return typeof t3.placeholder == "function" ? t3.placeholder(a3) : t3.placeholder;
                if (t3.static === true) {
                  if (e4 > -1 && n2.validPositions[e4] === void 0) {
                    var r2, o2 = d.call(this, e4), l2 = [];
                    if (o2.length > 1 + (o2[o2.length - 1].match.def === "" ? 1 : 0)) {
                      for (var s2 = 0; s2 < o2.length; s2++)
                        if (o2[s2].match.def !== "" && o2[s2].match.optionality !== true && o2[s2].match.optionalQuantifier !== true && (o2[s2].match.static === true || r2 === void 0 || o2[s2].match.fn.test(r2.match.def, n2, e4, true, a3) !== false) && (l2.push(o2[s2]), o2[s2].match.static === true && (r2 = o2[s2]), l2.length > 1 && /[0-9a-bA-Z]/.test(l2[0].match.def)))
                          return a3.placeholder.charAt(e4 % a3.placeholder.length);
                    }
                  }
                  return t3.def;
                }
                return a3.placeholder.charAt(e4 % a3.placeholder.length);
              }
              function s(e4, t3, i3) {
                return this.maskset.validPositions[e4] || u.call(this, e4, d.call(this, e4, t3 ? t3.slice() : t3, i3));
              }
              function u(e4, t3) {
                var i3 = this.opts, a3 = function(e5, t4) {
                  var i4 = 0, a4 = false;
                  t4.forEach(function(e6) {
                    e6.match.optionality && (i4 !== 0 && i4 !== e6.match.optionality && (a4 = true), (i4 === 0 || i4 > e6.match.optionality) && (i4 = e6.match.optionality));
                  }), i4 && (e5 == 0 || t4.length == 1 ? i4 = 0 : a4 || (i4 = 0));
                  return i4;
                }(e4, t3);
                e4 = e4 > 0 ? e4 - 1 : 0;
                var n2, o2, l2, s2 = r(c.call(this, e4));
                i3.greedy && t3.length > 1 && t3[t3.length - 1].match.def === "" && t3.pop();
                for (var u2 = 0; u2 < t3.length; u2++) {
                  var f2 = t3[u2];
                  n2 = r(f2, s2.length);
                  var d2 = Math.abs(n2 - s2);
                  (o2 === void 0 || n2 !== "" && d2 < o2 || l2 && !i3.greedy && l2.match.optionality && l2.match.optionality - a3 > 0 && l2.match.newBlockMarker === "master" && (!f2.match.optionality || f2.match.optionality - a3 < 1 || !f2.match.newBlockMarker) || l2 && !i3.greedy && l2.match.optionalQuantifier && !f2.match.optionalQuantifier) && (o2 = d2, l2 = f2);
                }
                return l2;
              }
              function c(e4, t3) {
                var i3 = this.maskset;
                return i3.validPositions[e4] ? i3.validPositions[e4] : (t3 || d.call(this, e4))[0];
              }
              function f(e4, t3, i3) {
                function a3(e5) {
                  for (var t4, i4 = [], a4 = -1, n2 = 0, r2 = e5.length; n2 < r2; n2++)
                    if (e5.charAt(n2) === "-")
                      for (t4 = e5.charCodeAt(n2 + 1); ++a4 < t4; )
                        i4.push(String.fromCharCode(a4));
                    else
                      a4 = e5.charCodeAt(n2), i4.push(e5.charAt(n2));
                  return i4.join("");
                }
                return e4.match.def === t3.match.nativeDef || !(!(i3.regex || e4.match.fn instanceof RegExp && t3.match.fn instanceof RegExp) || e4.match.static === true || t3.match.static === true) && a3(t3.match.fn.toString().replace(/[[\]/]/g, "")).indexOf(a3(e4.match.fn.toString().replace(/[[\]/]/g, ""))) !== -1;
              }
              function d(e4, t3, i3) {
                var a3, r2, o2 = this, l2 = this.dependencyLib, s2 = this.maskset, c2 = this.opts, d2 = this.el, p = s2.maskToken, h = t3 ? i3 : 0, v = t3 ? t3.slice() : [0], m = [], g = false, k = t3 ? t3.join("") : "";
                function y(t4, i4, r3, o3) {
                  function l3(r4, o4, u3) {
                    function p3(e5, t5) {
                      var i5 = t5.matches.indexOf(e5) === 0;
                      return i5 || t5.matches.every(function(a4, n2) {
                        return a4.isQuantifier === true ? i5 = p3(e5, t5.matches[n2 - 1]) : Object.prototype.hasOwnProperty.call(a4, "matches") && (i5 = p3(e5, a4)), !i5;
                      }), i5;
                    }
                    function v2(e5, t5, i5) {
                      var a4, n2;
                      if ((s2.tests[e5] || s2.validPositions[e5]) && (s2.tests[e5] || [s2.validPositions[e5]]).every(function(e6, r6) {
                        if (e6.mloc[t5])
                          return a4 = e6, false;
                        var o5 = i5 !== void 0 ? i5 : e6.alternation, l4 = e6.locator[o5] !== void 0 ? e6.locator[o5].toString().indexOf(t5) : -1;
                        return (n2 === void 0 || l4 < n2) && l4 !== -1 && (a4 = e6, n2 = l4), true;
                      }), a4) {
                        var r5 = a4.locator[a4.alternation];
                        return (a4.mloc[t5] || a4.mloc[r5] || a4.locator).slice((i5 !== void 0 ? i5 : a4.alternation) + 1);
                      }
                      return i5 !== void 0 ? v2(e5, t5) : void 0;
                    }
                    function b2(e5, t5) {
                      var i5 = e5.alternation, a4 = t5 === void 0 || i5 === t5.alternation && e5.locator[i5].toString().indexOf(t5.locator[i5]) === -1;
                      if (!a4 && i5 > t5.alternation) {
                        for (var n2 = t5.alternation; n2 < i5; n2++)
                          if (e5.locator[n2] !== t5.locator[n2]) {
                            i5 = n2, a4 = true;
                            break;
                          }
                      }
                      if (a4) {
                        e5.mloc = e5.mloc || {};
                        var r5 = e5.locator[i5];
                        if (r5 !== void 0) {
                          if (typeof r5 == "string" && (r5 = r5.split(",")[0]), e5.mloc[r5] === void 0 && (e5.mloc[r5] = e5.locator.slice()), t5 !== void 0) {
                            for (var o5 in t5.mloc)
                              typeof o5 == "string" && (o5 = o5.split(",")[0]), e5.mloc[o5] === void 0 && (e5.mloc[o5] = t5.mloc[o5]);
                            e5.locator[i5] = Object.keys(e5.mloc).join(",");
                          }
                          return true;
                        }
                        e5.alternation = void 0;
                      }
                      return false;
                    }
                    function x2(e5, t5) {
                      if (e5.locator.length !== t5.locator.length)
                        return false;
                      for (var i5 = e5.alternation + 1; i5 < e5.locator.length; i5++)
                        if (e5.locator[i5] !== t5.locator[i5])
                          return false;
                      return true;
                    }
                    if (h > e4 + c2._maxTestPos)
                      throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + s2.mask;
                    if (h === e4 && r4.matches === void 0) {
                      if (m.push({
                        match: r4,
                        locator: o4.reverse(),
                        cd: k,
                        mloc: {}
                      }), !r4.optionality || u3 !== void 0 || !(c2.definitions && c2.definitions[r4.nativeDef] && c2.definitions[r4.nativeDef].optional || n.default.prototype.definitions[r4.nativeDef] && n.default.prototype.definitions[r4.nativeDef].optional))
                        return true;
                      g = true, h = e4;
                    } else if (r4.matches !== void 0) {
                      if (r4.isGroup && u3 !== r4) {
                        if (r4 = l3(t4.matches[t4.matches.indexOf(r4) + 1], o4, u3))
                          return true;
                      } else if (r4.isOptional) {
                        var P2 = r4, E = m.length;
                        if (r4 = y(r4, i4, o4, u3)) {
                          if (m.forEach(function(e5, t5) {
                            t5 >= E && (e5.match.optionality = e5.match.optionality ? e5.match.optionality + 1 : 1);
                          }), a3 = m[m.length - 1].match, u3 !== void 0 || !p3(a3, P2))
                            return true;
                          g = true, h = e4;
                        }
                      } else if (r4.isAlternator) {
                        var S, _ = r4, w = [], M = m.slice(), O = o4.length, T = false, C = i4.length > 0 ? i4.shift() : -1;
                        if (C === -1 || typeof C == "string") {
                          var A, D = h, j = i4.slice(), B = [];
                          if (typeof C == "string")
                            B = C.split(",");
                          else
                            for (A = 0; A < _.matches.length; A++)
                              B.push(A.toString());
                          if (s2.excludes[e4] !== void 0) {
                            for (var R = B.slice(), L = 0, I = s2.excludes[e4].length; L < I; L++) {
                              var F = s2.excludes[e4][L].toString().split(":");
                              o4.length == F[1] && B.splice(B.indexOf(F[0]), 1);
                            }
                            B.length === 0 && (delete s2.excludes[e4], B = R);
                          }
                          (c2.keepStatic === true || isFinite(parseInt(c2.keepStatic)) && D >= c2.keepStatic) && (B = B.slice(0, 1));
                          for (var N = 0; N < B.length; N++) {
                            A = parseInt(B[N]), m = [], i4 = typeof C == "string" && v2(h, A, O) || j.slice();
                            var V = _.matches[A];
                            if (V && l3(V, [A].concat(o4), u3))
                              r4 = true;
                            else if (N === 0 && (T = true), V && V.matches && V.matches.length > _.matches[0].matches.length)
                              break;
                            S = m.slice(), h = D, m = [];
                            for (var G = 0; G < S.length; G++) {
                              var H = S[G], K = false;
                              H.match.jit = H.match.jit || T, H.alternation = H.alternation || O, b2(H);
                              for (var U = 0; U < w.length; U++) {
                                var $2 = w[U];
                                if (typeof C != "string" || H.alternation !== void 0 && B.includes(H.locator[H.alternation].toString())) {
                                  if (H.match.nativeDef === $2.match.nativeDef) {
                                    K = true, b2($2, H);
                                    break;
                                  }
                                  if (f(H, $2, c2)) {
                                    b2(H, $2) && (K = true, w.splice(w.indexOf($2), 0, H));
                                    break;
                                  }
                                  if (f($2, H, c2)) {
                                    b2($2, H);
                                    break;
                                  }
                                  if (Z = $2, (Q = H).match.static === true && Z.match.static !== true && Z.match.fn.test(Q.match.def, s2, e4, false, c2, false)) {
                                    x2(H, $2) || d2.inputmask.userOptions.keepStatic !== void 0 ? b2(H, $2) && (K = true, w.splice(w.indexOf($2), 0, H)) : c2.keepStatic = true;
                                    break;
                                  }
                                }
                              }
                              K || w.push(H);
                            }
                          }
                          m = M.concat(w), h = e4, g = m.length > 0, r4 = w.length > 0, i4 = j.slice();
                        } else
                          r4 = l3(_.matches[C] || t4.matches[C], [C].concat(o4), u3);
                        if (r4)
                          return true;
                      } else if (r4.isQuantifier && u3 !== t4.matches[t4.matches.indexOf(r4) - 1])
                        for (var q = r4, z = i4.length > 0 ? i4.shift() : 0; z < (isNaN(q.quantifier.max) ? z + 1 : q.quantifier.max) && h <= e4; z++) {
                          var W = t4.matches[t4.matches.indexOf(q) - 1];
                          if (r4 = l3(W, [z].concat(o4), W)) {
                            if ((a3 = m[m.length - 1].match).optionalQuantifier = z >= q.quantifier.min, a3.jit = (z + 1) * (W.matches.indexOf(a3) + 1) > q.quantifier.jit, a3.optionalQuantifier && p3(a3, W)) {
                              g = true, h = e4;
                              break;
                            }
                            return a3.jit && (s2.jitOffset[e4] = W.matches.length - W.matches.indexOf(a3)), true;
                          }
                        }
                      else if (r4 = y(r4, i4, o4, u3))
                        return true;
                    } else
                      h++;
                    var Q, Z;
                  }
                  for (var u2 = i4.length > 0 ? i4.shift() : 0; u2 < t4.matches.length; u2++)
                    if (t4.matches[u2].isQuantifier !== true) {
                      var p2 = l3(t4.matches[u2], [u2].concat(r3), o3);
                      if (p2 && h === e4)
                        return p2;
                      if (h > e4)
                        break;
                    }
                }
                if (e4 > -1) {
                  if (t3 === void 0) {
                    for (var b, x = e4 - 1; (b = s2.validPositions[x] || s2.tests[x]) === void 0 && x > -1; )
                      x--;
                    b !== void 0 && x > -1 && (v = function(e5, t4) {
                      var i4, a4 = [];
                      return Array.isArray(t4) || (t4 = [t4]), t4.length > 0 && (t4[0].alternation === void 0 || c2.keepStatic === true ? (a4 = u.call(o2, e5, t4.slice()).locator.slice()).length === 0 && (a4 = t4[0].locator.slice()) : t4.forEach(function(e6) {
                        e6.def !== "" && (a4.length === 0 ? (i4 = e6.alternation, a4 = e6.locator.slice()) : e6.locator[i4] && a4[i4].toString().indexOf(e6.locator[i4]) === -1 && (a4[i4] += "," + e6.locator[i4]));
                      })), a4;
                    }(x, b), k = v.join(""), h = x);
                  }
                  if (s2.tests[e4] && s2.tests[e4][0].cd === k)
                    return s2.tests[e4];
                  for (var P = v.shift(); P < p.length; P++) {
                    if (y(p[P], v, [P]) && h === e4 || h > e4)
                      break;
                  }
                }
                return (m.length === 0 || g) && m.push({
                  match: {
                    fn: null,
                    static: true,
                    optionality: false,
                    casing: null,
                    def: "",
                    placeholder: ""
                  },
                  locator: [],
                  mloc: {},
                  cd: k
                }), t3 !== void 0 && s2.tests[e4] ? r2 = l2.extend(true, [], m) : (s2.tests[e4] = l2.extend(true, [], m), r2 = s2.tests[e4]), m.forEach(function(e5) {
                  e5.match.optionality = false;
                }), r2;
              }
            },
            7215: function(e3, t2, i2) {
              Object.defineProperty(t2, "__esModule", {
                value: true
              }), t2.alternate = s, t2.checkAlternationMatch = function(e4, t3, i3) {
                for (var a3, n2 = this.opts.greedy ? t3 : t3.slice(0, 1), r2 = false, o2 = i3 !== void 0 ? i3.split(",") : [], l2 = 0; l2 < o2.length; l2++)
                  (a3 = e4.indexOf(o2[l2])) !== -1 && e4.splice(a3, 1);
                for (var s2 = 0; s2 < e4.length; s2++)
                  if (n2.includes(e4[s2])) {
                    r2 = true;
                    break;
                  }
                return r2;
              }, t2.handleRemove = function(e4, t3, i3, a3, l2) {
                var u2 = this, c2 = this.maskset, f2 = this.opts;
                if ((f2.numericInput || u2.isRTL) && (t3 === r.default.BACKSPACE ? t3 = r.default.DELETE : t3 === r.default.DELETE && (t3 = r.default.BACKSPACE), u2.isRTL)) {
                  var d2 = i3.end;
                  i3.end = i3.begin, i3.begin = d2;
                }
                var p2, h2 = o.getLastValidPosition.call(u2, void 0, true);
                i3.end >= o.getBuffer.call(u2).length && h2 >= i3.end && (i3.end = h2 + 1);
                t3 === r.default.BACKSPACE ? i3.end - i3.begin < 1 && (i3.begin = o.seekPrevious.call(u2, i3.begin)) : t3 === r.default.DELETE && i3.begin === i3.end && (i3.end = o.isMask.call(u2, i3.end, true, true) ? i3.end + 1 : o.seekNext.call(u2, i3.end) + 1);
                if ((p2 = m.call(u2, i3)) !== false) {
                  if (a3 !== true && f2.keepStatic !== false || f2.regex !== null && n.getTest.call(u2, i3.begin).match.def.indexOf("|") !== -1) {
                    var v2 = s.call(u2, true);
                    if (v2) {
                      var g = v2.caret !== void 0 ? v2.caret : v2.pos ? o.seekNext.call(u2, v2.pos.begin ? v2.pos.begin : v2.pos) : o.getLastValidPosition.call(u2, -1, true);
                      (t3 !== r.default.DELETE || i3.begin > g) && i3.begin;
                    }
                  }
                  a3 !== true && (c2.p = t3 === r.default.DELETE ? i3.begin + p2 : i3.begin, c2.p = o.determineNewCaretPosition.call(u2, {
                    begin: c2.p,
                    end: c2.p
                  }, false, f2.insertMode === false && t3 === r.default.BACKSPACE ? "none" : void 0).begin);
                }
              }, t2.isComplete = c, t2.isSelection = f, t2.isValid = d, t2.refreshFromBuffer = h, t2.revalidateMask = m;
              var a2, n = i2(4713), r = (a2 = i2(5581)) && a2.__esModule ? a2 : {
                default: a2
              }, o = i2(8711), l = i2(6030);
              function s(e4, t3, i3, a3, r2, l2) {
                var u2, c2, f2, p2, h2, v2, m2, g, k, y, b, x = this, P = this.dependencyLib, E = this.opts, S = x.maskset, _ = P.extend(true, {}, S.validPositions), w = P.extend(true, {}, S.tests), M = false, O = false, T = r2 !== void 0 ? r2 : o.getLastValidPosition.call(x);
                if (l2 && (y = l2.begin, b = l2.end, l2.begin > l2.end && (y = l2.end, b = l2.begin)), T === -1 && r2 === void 0)
                  u2 = 0, c2 = (p2 = n.getTest.call(x, u2)).alternation;
                else
                  for (; T >= 0; T--)
                    if ((f2 = S.validPositions[T]) && f2.alternation !== void 0) {
                      if (p2 && p2.locator[f2.alternation] !== f2.locator[f2.alternation])
                        break;
                      u2 = T, c2 = S.validPositions[u2].alternation, p2 = f2;
                    }
                if (c2 !== void 0) {
                  m2 = parseInt(u2), S.excludes[m2] = S.excludes[m2] || [], e4 !== true && S.excludes[m2].push((0, n.getDecisionTaker)(p2) + ":" + p2.alternation);
                  var C = [], A = -1;
                  for (h2 = m2; h2 < o.getLastValidPosition.call(x, void 0, true) + 1; h2++)
                    A === -1 && e4 <= h2 && t3 !== void 0 && (C.push(t3), A = C.length - 1), (v2 = S.validPositions[h2]) && v2.generatedInput !== true && (l2 === void 0 || h2 < y || h2 >= b) && C.push(v2.input), delete S.validPositions[h2];
                  for (A === -1 && t3 !== void 0 && (C.push(t3), A = C.length - 1); S.excludes[m2] !== void 0 && S.excludes[m2].length < 10; ) {
                    for (S.tests = {}, o.resetMaskSet.call(x, true), M = true, h2 = 0; h2 < C.length && (g = M.caret || o.getLastValidPosition.call(x, void 0, true) + 1, k = C[h2], M = d.call(x, g, k, false, a3, true)); h2++)
                      h2 === A && (O = M), e4 == 1 && M && (O = {
                        caretPos: h2
                      });
                    if (M)
                      break;
                    if (o.resetMaskSet.call(x), p2 = n.getTest.call(x, m2), S.validPositions = P.extend(true, {}, _), S.tests = P.extend(true, {}, w), !S.excludes[m2]) {
                      O = s.call(x, e4, t3, i3, a3, m2 - 1, l2);
                      break;
                    }
                    var D = (0, n.getDecisionTaker)(p2);
                    if (S.excludes[m2].indexOf(D + ":" + p2.alternation) !== -1) {
                      O = s.call(x, e4, t3, i3, a3, m2 - 1, l2);
                      break;
                    }
                    for (S.excludes[m2].push(D + ":" + p2.alternation), h2 = m2; h2 < o.getLastValidPosition.call(x, void 0, true) + 1; h2++)
                      delete S.validPositions[h2];
                  }
                }
                return O && E.keepStatic === false || delete S.excludes[m2], O;
              }
              function u(e4, t3, i3) {
                var a3 = this.opts, n2 = this.maskset;
                switch (a3.casing || t3.casing) {
                  case "upper":
                    e4 = e4.toUpperCase();
                    break;
                  case "lower":
                    e4 = e4.toLowerCase();
                    break;
                  case "title":
                    var o2 = n2.validPositions[i3 - 1];
                    e4 = i3 === 0 || o2 && o2.input === String.fromCharCode(r.default.SPACE) ? e4.toUpperCase() : e4.toLowerCase();
                    break;
                  default:
                    if (typeof a3.casing == "function") {
                      var l2 = Array.prototype.slice.call(arguments);
                      l2.push(n2.validPositions), e4 = a3.casing.apply(this, l2);
                    }
                }
                return e4;
              }
              function c(e4) {
                var t3 = this, i3 = this.opts, a3 = this.maskset;
                if (typeof i3.isComplete == "function")
                  return i3.isComplete(e4, i3);
                if (i3.repeat !== "*") {
                  var r2 = false, l2 = o.determineLastRequiredPosition.call(t3, true), s2 = o.seekPrevious.call(t3, l2.l);
                  if (l2.def === void 0 || l2.def.newBlockMarker || l2.def.optionality || l2.def.optionalQuantifier) {
                    r2 = true;
                    for (var u2 = 0; u2 <= s2; u2++) {
                      var c2 = n.getTestTemplate.call(t3, u2).match;
                      if (c2.static !== true && a3.validPositions[u2] === void 0 && c2.optionality !== true && c2.optionalQuantifier !== true || c2.static === true && e4[u2] !== n.getPlaceholder.call(t3, u2, c2)) {
                        r2 = false;
                        break;
                      }
                    }
                  }
                  return r2;
                }
              }
              function f(e4) {
                var t3 = this.opts.insertMode ? 0 : 1;
                return this.isRTL ? e4.begin - e4.end > t3 : e4.end - e4.begin > t3;
              }
              function d(e4, t3, i3, a3, r2, l2, p2) {
                var g = this, k = this.dependencyLib, y = this.opts, b = g.maskset;
                i3 = i3 === true;
                var x = e4;
                function P(e5) {
                  if (e5 !== void 0) {
                    if (e5.remove !== void 0 && (Array.isArray(e5.remove) || (e5.remove = [e5.remove]), e5.remove.sort(function(e6, t5) {
                      return t5.pos - e6.pos;
                    }).forEach(function(e6) {
                      m.call(g, {
                        begin: e6,
                        end: e6 + 1
                      });
                    }), e5.remove = void 0), e5.insert !== void 0 && (Array.isArray(e5.insert) || (e5.insert = [e5.insert]), e5.insert.sort(function(e6, t5) {
                      return e6.pos - t5.pos;
                    }).forEach(function(e6) {
                      e6.c !== "" && d.call(g, e6.pos, e6.c, e6.strict === void 0 || e6.strict, e6.fromIsValid !== void 0 ? e6.fromIsValid : a3);
                    }), e5.insert = void 0), e5.refreshFromBuffer && e5.buffer) {
                      var t4 = e5.refreshFromBuffer;
                      h.call(g, t4 === true ? t4 : t4.start, t4.end, e5.buffer), e5.refreshFromBuffer = void 0;
                    }
                    e5.rewritePosition !== void 0 && (x = e5.rewritePosition, e5 = true);
                  }
                  return e5;
                }
                function E(t4, i4, r3) {
                  var l3 = false;
                  return n.getTests.call(g, t4).every(function(s2, c2) {
                    var d2 = s2.match;
                    if (o.getBuffer.call(g, true), (l3 = (!d2.jit || b.validPositions[o.seekPrevious.call(g, t4)] !== void 0) && (d2.fn != null ? d2.fn.test(i4, b, t4, r3, y, f.call(g, e4)) : (i4 === d2.def || i4 === y.skipOptionalPartCharacter) && d2.def !== "" && {
                      c: n.getPlaceholder.call(g, t4, d2, true) || d2.def,
                      pos: t4
                    })) !== false) {
                      var p3 = l3.c !== void 0 ? l3.c : i4, h2 = t4;
                      return p3 = p3 === y.skipOptionalPartCharacter && d2.static === true ? n.getPlaceholder.call(g, t4, d2, true) || d2.def : p3, (l3 = P(l3)) !== true && l3.pos !== void 0 && l3.pos !== t4 && (h2 = l3.pos), l3 !== true && l3.pos === void 0 && l3.c === void 0 ? false : (m.call(g, e4, k.extend({}, s2, {
                        input: u.call(g, p3, d2, h2)
                      }), a3, h2) === false && (l3 = false), false);
                    }
                    return true;
                  }), l3;
                }
                e4.begin !== void 0 && (x = g.isRTL ? e4.end : e4.begin);
                var S = true, _ = k.extend(true, {}, b.validPositions);
                if (y.keepStatic === false && b.excludes[x] !== void 0 && r2 !== true && a3 !== true)
                  for (var w = x; w < (g.isRTL ? e4.begin : e4.end); w++)
                    b.excludes[w] !== void 0 && (b.excludes[w] = void 0, delete b.tests[w]);
                if (typeof y.preValidation == "function" && a3 !== true && l2 !== true && (S = P(S = y.preValidation.call(g, o.getBuffer.call(g), x, t3, f.call(g, e4), y, b, e4, i3 || r2))), S === true) {
                  if (S = E(x, t3, i3), (!i3 || a3 === true) && S === false && l2 !== true) {
                    var M = b.validPositions[x];
                    if (!M || M.match.static !== true || M.match.def !== t3 && t3 !== y.skipOptionalPartCharacter) {
                      if (y.insertMode || b.validPositions[o.seekNext.call(g, x)] === void 0 || e4.end > x) {
                        var O = false;
                        if (b.jitOffset[x] && b.validPositions[o.seekNext.call(g, x)] === void 0 && (S = d.call(g, x + b.jitOffset[x], t3, true, true)) !== false && (r2 !== true && (S.caret = x), O = true), e4.end > x && (b.validPositions[x] = void 0), !O && !o.isMask.call(g, x, y.keepStatic && x === 0)) {
                          for (var T = x + 1, C = o.seekNext.call(g, x, false, x !== 0); T <= C; T++)
                            if ((S = E(T, t3, i3)) !== false) {
                              S = v.call(g, x, S.pos !== void 0 ? S.pos : T) || S, x = T;
                              break;
                            }
                        }
                      }
                    } else
                      S = {
                        caret: o.seekNext.call(g, x)
                      };
                  }
                  S !== false || !y.keepStatic || !c.call(g, o.getBuffer.call(g)) && x !== 0 || i3 || r2 === true ? f.call(g, e4) && b.tests[x] && b.tests[x].length > 1 && y.keepStatic && !i3 && r2 !== true && (S = s.call(g, true)) : S = s.call(g, x, t3, i3, a3, void 0, e4), S === true && (S = {
                    pos: x
                  });
                }
                if (typeof y.postValidation == "function" && a3 !== true && l2 !== true) {
                  var A = y.postValidation.call(g, o.getBuffer.call(g, true), e4.begin !== void 0 ? g.isRTL ? e4.end : e4.begin : e4, t3, S, y, b, i3, p2);
                  A !== void 0 && (S = A === true ? S : A);
                }
                S && S.pos === void 0 && (S.pos = x), S === false || l2 === true ? (o.resetMaskSet.call(g, true), b.validPositions = k.extend(true, {}, _)) : v.call(g, void 0, x, true);
                var D = P(S);
                g.maxLength !== void 0 && (o.getBuffer.call(g).length > g.maxLength && !a3 && (o.resetMaskSet.call(g, true), b.validPositions = k.extend(true, {}, _), D = false));
                return D;
              }
              function p(e4, t3, i3) {
                for (var a3 = this.maskset, r2 = false, o2 = n.getTests.call(this, e4), l2 = 0; l2 < o2.length; l2++) {
                  if (o2[l2].match && (o2[l2].match.nativeDef === t3.match[i3.shiftPositions ? "def" : "nativeDef"] && (!i3.shiftPositions || !t3.match.static) || o2[l2].match.nativeDef === t3.match.nativeDef || i3.regex && !o2[l2].match.static && o2[l2].match.fn.test(t3.input))) {
                    r2 = true;
                    break;
                  }
                  if (o2[l2].match && o2[l2].match.def === t3.match.nativeDef) {
                    r2 = void 0;
                    break;
                  }
                }
                return r2 === false && a3.jitOffset[e4] !== void 0 && (r2 = p.call(this, e4 + a3.jitOffset[e4], t3, i3)), r2;
              }
              function h(e4, t3, i3) {
                var a3, n2, r2 = this, s2 = this.maskset, u2 = this.opts, c2 = this.dependencyLib, f2 = u2.skipOptionalPartCharacter, d2 = r2.isRTL ? i3.slice().reverse() : i3;
                if (u2.skipOptionalPartCharacter = "", e4 === true)
                  o.resetMaskSet.call(r2), s2.tests = {}, e4 = 0, t3 = i3.length, n2 = o.determineNewCaretPosition.call(r2, {
                    begin: 0,
                    end: 0
                  }, false).begin;
                else {
                  for (a3 = e4; a3 < t3; a3++)
                    delete s2.validPositions[a3];
                  n2 = e4;
                }
                var p2 = new c2.Event("keypress");
                for (a3 = e4; a3 < t3; a3++) {
                  p2.keyCode = d2[a3].toString().charCodeAt(0), r2.ignorable = false;
                  var h2 = l.EventHandlers.keypressEvent.call(r2, p2, true, false, false, n2);
                  h2 !== false && h2 !== void 0 && (n2 = h2.forwardPosition);
                }
                u2.skipOptionalPartCharacter = f2;
              }
              function v(e4, t3, i3) {
                var a3 = this, r2 = this.maskset, l2 = this.dependencyLib;
                if (e4 === void 0)
                  for (e4 = t3 - 1; e4 > 0 && !r2.validPositions[e4]; e4--)
                    ;
                for (var s2 = e4; s2 < t3; s2++) {
                  if (r2.validPositions[s2] === void 0 && !o.isMask.call(a3, s2, false)) {
                    if (s2 == 0 ? n.getTest.call(a3, s2) : r2.validPositions[s2 - 1]) {
                      var u2 = n.getTests.call(a3, s2).slice();
                      u2[u2.length - 1].match.def === "" && u2.pop();
                      var c2, f2 = n.determineTestTemplate.call(a3, s2, u2);
                      if (f2 && (f2.match.jit !== true || f2.match.newBlockMarker === "master" && (c2 = r2.validPositions[s2 + 1]) && c2.match.optionalQuantifier === true) && ((f2 = l2.extend({}, f2, {
                        input: n.getPlaceholder.call(a3, s2, f2.match, true) || f2.match.def
                      })).generatedInput = true, m.call(a3, s2, f2, true), i3 !== true)) {
                        var p2 = r2.validPositions[t3].input;
                        return r2.validPositions[t3] = void 0, d.call(a3, t3, p2, true, true);
                      }
                    }
                  }
                }
              }
              function m(e4, t3, i3, a3) {
                var r2 = this, l2 = this.maskset, s2 = this.opts, u2 = this.dependencyLib;
                function c2(e5, t4, i4) {
                  var a4 = t4[e5];
                  if (a4 !== void 0 && a4.match.static === true && a4.match.optionality !== true && (t4[0] === void 0 || t4[0].alternation === void 0)) {
                    var n2 = i4.begin <= e5 - 1 ? t4[e5 - 1] && t4[e5 - 1].match.static === true && t4[e5 - 1] : t4[e5 - 1], r3 = i4.end > e5 + 1 ? t4[e5 + 1] && t4[e5 + 1].match.static === true && t4[e5 + 1] : t4[e5 + 1];
                    return n2 && r3;
                  }
                  return false;
                }
                var f2 = 0, h2 = e4.begin !== void 0 ? e4.begin : e4, v2 = e4.end !== void 0 ? e4.end : e4, m2 = true;
                if (e4.begin > e4.end && (h2 = e4.end, v2 = e4.begin), a3 = a3 !== void 0 ? a3 : h2, h2 !== v2 || s2.insertMode && l2.validPositions[a3] !== void 0 && i3 === void 0 || t3 === void 0 || t3.match.optionalQuantifier || t3.match.optionality) {
                  var g, k = u2.extend(true, {}, l2.validPositions), y = o.getLastValidPosition.call(r2, void 0, true);
                  for (l2.p = h2, g = y; g >= h2; g--)
                    delete l2.validPositions[g], t3 === void 0 && delete l2.tests[g + 1];
                  var b, x, P = a3, E = P;
                  for (t3 && (l2.validPositions[a3] = u2.extend(true, {}, t3), E++, P++), g = t3 ? v2 : v2 - 1; g <= y; g++) {
                    if ((b = k[g]) !== void 0 && b.generatedInput !== true && (g >= v2 || g >= h2 && c2(g, k, {
                      begin: h2,
                      end: v2
                    }))) {
                      for (; n.getTest.call(r2, E).match.def !== ""; ) {
                        if ((x = p.call(r2, E, b, s2)) !== false || b.match.def === "+") {
                          b.match.def === "+" && o.getBuffer.call(r2, true);
                          var S = d.call(r2, E, b.input, b.match.def !== "+", true);
                          if (m2 = S !== false, P = (S.pos || E) + 1, !m2 && x)
                            break;
                        } else
                          m2 = false;
                        if (m2) {
                          t3 === void 0 && b.match.static && g === e4.begin && f2++;
                          break;
                        }
                        if (!m2 && o.getBuffer.call(r2), E > l2.maskLength)
                          break;
                        E++;
                      }
                      n.getTest.call(r2, E).match.def == "" && (m2 = false), E = P;
                    }
                    if (!m2)
                      break;
                  }
                  if (!m2)
                    return l2.validPositions = u2.extend(true, {}, k), o.resetMaskSet.call(r2, true), false;
                } else
                  t3 && n.getTest.call(r2, a3).match.cd === t3.match.cd && (l2.validPositions[a3] = u2.extend(true, {}, t3));
                return o.resetMaskSet.call(r2, true), f2;
              }
            },
            5581: function(e3) {
              e3.exports = JSON.parse('{"BACKSPACE":8,"BACKSPACE_SAFARI":127,"DELETE":46,"DOWN":40,"END":35,"ENTER":13,"ESCAPE":27,"HOME":36,"INSERT":45,"LEFT":37,"PAGE_DOWN":34,"PAGE_UP":33,"RIGHT":39,"SPACE":32,"TAB":9,"UP":38,"X":88,"Z":90,"CONTROL":17,"PAUSE/BREAK":19,"WINDOWS_LEFT":91,"WINDOWS_RIGHT":92,"KEY_229":229}');
            }
          }, t = {};
          function i(a2) {
            var n = t[a2];
            if (n !== void 0)
              return n.exports;
            var r = t[a2] = {
              exports: {}
            };
            return e2[a2](r, r.exports, i), r.exports;
          }
          var a = {};
          return function() {
            var e3, t2 = a;
            Object.defineProperty(t2, "__esModule", {
              value: true
            }), t2.default = void 0, i(3851), i(219), i(207), i(5296);
            var n = ((e3 = i(2394)) && e3.__esModule ? e3 : {
              default: e3
            }).default;
            t2.default = n;
          }(), a;
        }();
      });
    }
  });

  // node_modules/rater-js/index.js
  var require_rater_js = __commonJS({
    "node_modules/rater-js/index.js"(exports, module) {
      (function(f) {
        if (typeof exports === "object" && typeof module !== "undefined") {
          module.exports = f();
        } else if (typeof define === "function" && define.amd) {
          define([], f);
        } else {
          var g;
          if (typeof window !== "undefined") {
            g = window;
          } else if (typeof global !== "undefined") {
            g = global;
          } else if (typeof self !== "undefined") {
            g = self;
          } else {
            g = this;
          }
          g.raterJs = f();
        }
      })(function() {
        var define2, module2, exports2;
        return function() {
          function r(e2, n, t) {
            function o(i2, f) {
              if (!n[i2]) {
                if (!e2[i2]) {
                  var c = typeof __require == "function" && __require;
                  if (!f && c)
                    return c(i2, true);
                  if (u)
                    return u(i2, true);
                  var a = new Error("Cannot find module '" + i2 + "'");
                  throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i2] = { exports: {} };
                e2[i2][0].call(p.exports, function(r2) {
                  var n2 = e2[i2][1][r2];
                  return o(n2 || r2);
                }, p, p.exports, r, e2, n, t);
              }
              return n[i2].exports;
            }
            for (var u = typeof __require == "function" && __require, i = 0; i < t.length; i++)
              o(t[i]);
            return o;
          }
          return r;
        }()({ 1: [function(require2, module3, exports3) {
          "use strict";
          var css2 = require2("./style.css");
          module3.exports = function(options) {
            var showToolTip = true;
            if (typeof options.element === "undefined" || options.element === null) {
              throw new Error("element required");
            }
            if (typeof options.showToolTip !== "undefined") {
              showToolTip = !!options.showToolTip;
            }
            if (typeof options.step !== "undefined") {
              if (options.step <= 0 || options.step > 1) {
                throw new Error("step must be a number between 0 and 1");
              }
            }
            var elem = options.element;
            var reverse = options.reverse;
            var stars = options.max || 5;
            var starSize = options.starSize || 16;
            var step = options.step || 1;
            var onHover = options.onHover;
            var onLeave = options.onLeave;
            var rating = null;
            var myRating;
            elem.classList.add("star-rating");
            var div2 = document.createElement("div");
            div2.classList.add("star-value");
            if (reverse) {
              div2.classList.add("rtl");
            }
            div2.style.backgroundSize = starSize + "px";
            elem.appendChild(div2);
            elem.style.width = starSize * stars + "px";
            elem.style.height = starSize + "px";
            elem.style.backgroundSize = starSize + "px";
            var callback = options.rateCallback;
            var disabled = !!options.readOnly;
            var disableText;
            var isRating = false;
            var isBusyText = options.isBusyText;
            var currentRating;
            var ratingText;
            if (typeof options.disableText !== "undefined") {
              disableText = options.disableText;
            } else {
              disableText = "{rating}/{maxRating}";
            }
            if (typeof options.ratingText !== "undefined") {
              ratingText = options.ratingText;
            } else {
              ratingText = "{rating}/{maxRating}";
            }
            if (options.rating) {
              setRating(options.rating);
            } else {
              var dataRating = elem.dataset.rating;
              if (dataRating) {
                setRating(+dataRating);
              }
            }
            if (!rating) {
              elem.querySelector(".star-value").style.width = "0px";
            }
            if (disabled) {
              disable();
            }
            function onMouseMove(e2) {
              onMove(e2, false);
            }
            function onMove(e2, isTouch) {
              if (disabled === true || isRating === true) {
                return;
              }
              var xCoor = null;
              var percent;
              var width = elem.offsetWidth;
              var parentOffset = elem.getBoundingClientRect();
              if (reverse) {
                if (isTouch) {
                  xCoor = e2.changedTouches[0].pageX - parentOffset.left;
                } else {
                  xCoor = e2.pageX - window.scrollX - parentOffset.left;
                }
                var relXRtl = width - xCoor;
                var valueForDivision = width / 100;
                percent = relXRtl / valueForDivision;
              } else {
                if (isTouch) {
                  xCoor = e2.changedTouches[0].pageX - parentOffset.left;
                } else {
                  xCoor = e2.offsetX;
                }
                percent = xCoor / width * 100;
              }
              if (percent < 101) {
                if (step === 1) {
                  currentRating = Math.ceil(percent / 100 * stars);
                } else {
                  var rat = percent / 100 * stars;
                  for (var i = 0; ; i += step) {
                    if (i >= rat) {
                      currentRating = i;
                      break;
                    }
                  }
                }
                if (currentRating > stars) {
                  currentRating = stars;
                }
                elem.querySelector(".star-value").style.width = currentRating / stars * 100 + "%";
                if (showToolTip) {
                  var toolTip = ratingText.replace("{rating}", currentRating);
                  toolTip = toolTip.replace("{maxRating}", stars);
                  elem.setAttribute("title", toolTip);
                }
                if (typeof onHover === "function") {
                  onHover(currentRating, rating);
                }
              }
            }
            function onStarOut(e2) {
              if (!rating) {
                elem.querySelector(".star-value").style.width = "0%";
                elem.removeAttribute("data-rating");
              } else {
                elem.querySelector(".star-value").style.width = rating / stars * 100 + "%";
                elem.setAttribute("data-rating", rating);
              }
              if (typeof onLeave === "function") {
                onLeave(currentRating, rating);
              }
            }
            function onStarClick(e2) {
              if (disabled === true) {
                return;
              }
              if (isRating === true) {
                return;
              }
              if (typeof callback !== "undefined") {
                isRating = true;
                myRating = currentRating;
                if (typeof isBusyText === "undefined") {
                  elem.removeAttribute("title");
                } else {
                  elem.setAttribute("title", isBusyText);
                }
                elem.classList.add("is-busy");
                callback.call(this, myRating, function() {
                  if (disabled === false) {
                    elem.removeAttribute("title");
                  }
                  isRating = false;
                  elem.classList.remove("is-busy");
                });
              }
            }
            function disable() {
              disabled = true;
              elem.classList.add("disabled");
              if (showToolTip && !!disableText) {
                var toolTip = disableText.replace("{rating}", !!rating ? rating : 0);
                toolTip = toolTip.replace("{maxRating}", stars);
                elem.setAttribute("title", toolTip);
              } else {
                elem.removeAttribute("title");
              }
            }
            function enable() {
              disabled = false;
              elem.removeAttribute("title");
              elem.classList.remove("disabled");
            }
            function setRating(value2) {
              if (typeof value2 === "undefined") {
                throw new Error("Value not set.");
              }
              if (value2 === null) {
                throw new Error("Value cannot be null.");
              }
              if (typeof value2 !== "number") {
                throw new Error("Value must be a number.");
              }
              if (value2 < 0 || value2 > stars) {
                throw new Error("Value too high. Please set a rating of " + stars + " or below.");
              }
              rating = value2;
              elem.querySelector(".star-value").style.width = value2 / stars * 100 + "%";
              elem.setAttribute("data-rating", value2);
            }
            function getRating() {
              return rating;
            }
            function clear() {
              rating = null;
              elem.querySelector(".star-value").style.width = "0px";
              elem.removeAttribute("title");
            }
            function dispose() {
              elem.removeEventListener("mousemove", onMouseMove);
              elem.removeEventListener("mouseleave", onStarOut);
              elem.removeEventListener("click", onStarClick);
              elem.removeEventListener("touchmove", handleMove, false);
              elem.removeEventListener("touchstart", handleStart, false);
              elem.removeEventListener("touchend", handleEnd, false);
              elem.removeEventListener("touchcancel", handleCancel, false);
            }
            elem.addEventListener("mousemove", onMouseMove);
            elem.addEventListener("mouseleave", onStarOut);
            var module4 = {
              setRating,
              getRating,
              disable,
              enable,
              clear,
              dispose,
              get element() {
                return elem;
              }
            };
            function handleMove(e2) {
              e2.preventDefault();
              onMove(e2, true);
            }
            function handleStart(e2) {
              e2.preventDefault();
              onMove(e2, true);
            }
            function handleEnd(evt) {
              evt.preventDefault();
              onMove(evt, true);
              onStarClick.call(module4);
            }
            function handleCancel(e2) {
              e2.preventDefault();
              onStarOut(e2);
            }
            elem.addEventListener("click", onStarClick.bind(module4));
            elem.addEventListener("touchmove", handleMove, false);
            elem.addEventListener("touchstart", handleStart, false);
            elem.addEventListener("touchend", handleEnd, false);
            elem.addEventListener("touchcancel", handleCancel, false);
            return module4;
          };
        }, { "./style.css": 2 }], 2: [function(require2, module3, exports3) {
          var css2 = `.star-rating {
  width: 0;
  position: relative;
  display: inline-block;
  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDguOSIgaGVpZ2h0PSIxMDMuNiIgdmlld0JveD0iMCAwIDEwOC45IDEwMy42Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2UzZTZlNjt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPnN0YXJfMDwvdGl0bGU+PGcgaWQ9IkxheWVyXzIiIGRhdGEtbmFtZT0iTGF5ZXIgMiI+PGcgaWQ9IkxheWVyXzEtMiIgZGF0YS1uYW1lPSJMYXllciAxIj48cG9seWdvbiBjbGFzcz0iY2xzLTEiIHBvaW50cz0iMTA4LjkgMzkuNiA3MS4zIDM0LjEgNTQuNCAwIDM3LjYgMzQuMSAwIDM5LjYgMjcuMiA2Ni4xIDIwLjggMTAzLjYgNTQuNCA4NS45IDg4LjEgMTAzLjYgODEuNyA2Ni4xIDEwOC45IDM5LjYiLz48L2c+PC9nPjwvc3ZnPg0K);
  background-position: 0 0;
  background-repeat: repeat-x;
  cursor: pointer;
}
.star-rating .star-value {
  position: absolute;
  height: 100%;
  width: 100%;
  background: url('data:image/svg+xml;base64,PHN2Zw0KCXhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwOC45IiBoZWlnaHQ9IjEwMy42IiB2aWV3Qm94PSIwIDAgMTA4LjkgMTAzLjYiPg0KCTxkZWZzPg0KCQk8c3R5bGU+LmNscy0xe2ZpbGw6I2YxYzk0Nzt9PC9zdHlsZT4NCgk8L2RlZnM+DQoJPHRpdGxlPnN0YXIxPC90aXRsZT4NCgk8ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj4NCgkJPGcgaWQ9IkxheWVyXzEtMiIgZGF0YS1uYW1lPSJMYXllciAxIj4NCgkJCTxwb2x5Z29uIGNsYXNzPSJjbHMtMSIgcG9pbnRzPSI1NC40IDAgNzEuMyAzNC4xIDEwOC45IDM5LjYgODEuNyA2Ni4xIDg4LjEgMTAzLjYgNTQuNCA4NS45IDIwLjggMTAzLjYgMjcuMiA2Ni4xIDAgMzkuNiAzNy42IDM0LjEgNTQuNCAwIi8+DQoJCTwvZz4NCgk8L2c+DQo8L3N2Zz4NCg==');
  background-repeat: repeat-x;
}
.star-rating.disabled {
  cursor: default;
}
.star-rating.is-busy {
  cursor: wait;
}
.star-rating .star-value.rtl {
  -moz-transform: scaleX(-1);
  -o-transform: scaleX(-1);
  -webkit-transform: scaleX(-1);
  transform: scaleX(-1);
  filter: FlipH;
  -ms-filter: "FlipH";
  right: 0;
  left: auto;
}
`;
          require2("browserify-css").createStyle(css2, { "href": "lib\\style.css" }, { "insertAt": "bottom" });
          module3.exports = css2;
        }, { "browserify-css": 3 }], 3: [function(require2, module3, exports3) {
          "use strict";
          var styleElementsInsertedAtTop = [];
          var insertStyleElement = function(styleElement, options) {
            var head = document.head || document.getElementsByTagName("head")[0];
            var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
            options = options || {};
            options.insertAt = options.insertAt || "bottom";
            if (options.insertAt === "top") {
              if (!lastStyleElementInsertedAtTop) {
                head.insertBefore(styleElement, head.firstChild);
              } else if (lastStyleElementInsertedAtTop.nextSibling) {
                head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
              } else {
                head.appendChild(styleElement);
              }
              styleElementsInsertedAtTop.push(styleElement);
            } else if (options.insertAt === "bottom") {
              head.appendChild(styleElement);
            } else {
              throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
            }
          };
          module3.exports = {
            createLink: function(href, attributes) {
              var head = document.head || document.getElementsByTagName("head")[0];
              var link = document.createElement("link");
              link.href = href;
              link.rel = "stylesheet";
              for (var key in attributes) {
                if (!attributes.hasOwnProperty(key)) {
                  continue;
                }
                var value2 = attributes[key];
                link.setAttribute("data-" + key, value2);
              }
              head.appendChild(link);
            },
            createStyle: function(cssText, attributes, extraOptions) {
              extraOptions = extraOptions || {};
              var style = document.createElement("style");
              style.type = "text/css";
              for (var key in attributes) {
                if (!attributes.hasOwnProperty(key)) {
                  continue;
                }
                var value2 = attributes[key];
                style.setAttribute("data-" + key, value2);
              }
              if (style.sheet) {
                style.innerHTML = cssText;
                style.sheet.cssText = cssText;
                insertStyleElement(style, { insertAt: extraOptions.insertAt });
              } else if (style.styleSheet) {
                insertStyleElement(style, { insertAt: extraOptions.insertAt });
                style.styleSheet.cssText = cssText;
              } else {
                style.appendChild(document.createTextNode(cssText));
                insertStyleElement(style, { insertAt: extraOptions.insertAt });
              }
            }
          };
        }, {}] }, {}, [1])(1);
      });
    }
  });

  // node_modules/intl-tel-input/build/js/intlTelInput.js
  var require_intlTelInput = __commonJS({
    "node_modules/intl-tel-input/build/js/intlTelInput.js"(exports, module) {
      (function(factory) {
        if (typeof module === "object" && module.exports)
          module.exports = factory();
        else
          window.intlTelInput = factory();
      })(function(undefined2) {
        "use strict";
        return function() {
          var allCountries = [["Afghanistan (\u202B\u0627\u0641\u063A\u0627\u0646\u0633\u062A\u0627\u0646\u202C\u200E)", "af", "93"], ["Albania (Shqip\xEBri)", "al", "355"], ["Algeria (\u202B\u0627\u0644\u062C\u0632\u0627\u0626\u0631\u202C\u200E)", "dz", "213"], ["American Samoa", "as", "1", 5, ["684"]], ["Andorra", "ad", "376"], ["Angola", "ao", "244"], ["Anguilla", "ai", "1", 6, ["264"]], ["Antigua and Barbuda", "ag", "1", 7, ["268"]], ["Argentina", "ar", "54"], ["Armenia (\u0540\u0561\u0575\u0561\u057D\u057F\u0561\u0576)", "am", "374"], ["Aruba", "aw", "297"], ["Ascension Island", "ac", "247"], ["Australia", "au", "61", 0], ["Austria (\xD6sterreich)", "at", "43"], ["Azerbaijan (Az\u0259rbaycan)", "az", "994"], ["Bahamas", "bs", "1", 8, ["242"]], ["Bahrain (\u202B\u0627\u0644\u0628\u062D\u0631\u064A\u0646\u202C\u200E)", "bh", "973"], ["Bangladesh (\u09AC\u09BE\u0982\u09B2\u09BE\u09A6\u09C7\u09B6)", "bd", "880"], ["Barbados", "bb", "1", 9, ["246"]], ["Belarus (\u0411\u0435\u043B\u0430\u0440\u0443\u0441\u044C)", "by", "375"], ["Belgium (Belgi\xEB)", "be", "32"], ["Belize", "bz", "501"], ["Benin (B\xE9nin)", "bj", "229"], ["Bermuda", "bm", "1", 10, ["441"]], ["Bhutan (\u0F60\u0F56\u0FB2\u0F74\u0F42)", "bt", "975"], ["Bolivia", "bo", "591"], ["Bosnia and Herzegovina (\u0411\u043E\u0441\u043D\u0430 \u0438 \u0425\u0435\u0440\u0446\u0435\u0433\u043E\u0432\u0438\u043D\u0430)", "ba", "387"], ["Botswana", "bw", "267"], ["Brazil (Brasil)", "br", "55"], ["British Indian Ocean Territory", "io", "246"], ["British Virgin Islands", "vg", "1", 11, ["284"]], ["Brunei", "bn", "673"], ["Bulgaria (\u0411\u044A\u043B\u0433\u0430\u0440\u0438\u044F)", "bg", "359"], ["Burkina Faso", "bf", "226"], ["Burundi (Uburundi)", "bi", "257"], ["Cambodia (\u1780\u1798\u17D2\u1796\u17BB\u1787\u17B6)", "kh", "855"], ["Cameroon (Cameroun)", "cm", "237"], ["Canada", "ca", "1", 1, ["204", "226", "236", "249", "250", "289", "306", "343", "365", "387", "403", "416", "418", "431", "437", "438", "450", "506", "514", "519", "548", "579", "581", "587", "604", "613", "639", "647", "672", "705", "709", "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905"]], ["Cape Verde (Kabu Verdi)", "cv", "238"], ["Caribbean Netherlands", "bq", "599", 1, ["3", "4", "7"]], ["Cayman Islands", "ky", "1", 12, ["345"]], ["Central African Republic (R\xE9publique centrafricaine)", "cf", "236"], ["Chad (Tchad)", "td", "235"], ["Chile", "cl", "56"], ["China (\u4E2D\u56FD)", "cn", "86"], ["Christmas Island", "cx", "61", 2, ["89164"]], ["Cocos (Keeling) Islands", "cc", "61", 1, ["89162"]], ["Colombia", "co", "57"], ["Comoros (\u202B\u062C\u0632\u0631 \u0627\u0644\u0642\u0645\u0631\u202C\u200E)", "km", "269"], ["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)", "cd", "243"], ["Congo (Republic) (Congo-Brazzaville)", "cg", "242"], ["Cook Islands", "ck", "682"], ["Costa Rica", "cr", "506"], ["C\xF4te d\u2019Ivoire", "ci", "225"], ["Croatia (Hrvatska)", "hr", "385"], ["Cuba", "cu", "53"], ["Cura\xE7ao", "cw", "599", 0], ["Cyprus (\u039A\u03CD\u03C0\u03C1\u03BF\u03C2)", "cy", "357"], ["Czech Republic (\u010Cesk\xE1 republika)", "cz", "420"], ["Denmark (Danmark)", "dk", "45"], ["Djibouti", "dj", "253"], ["Dominica", "dm", "1", 13, ["767"]], ["Dominican Republic (Rep\xFAblica Dominicana)", "do", "1", 2, ["809", "829", "849"]], ["Ecuador", "ec", "593"], ["Egypt (\u202B\u0645\u0635\u0631\u202C\u200E)", "eg", "20"], ["El Salvador", "sv", "503"], ["Equatorial Guinea (Guinea Ecuatorial)", "gq", "240"], ["Eritrea", "er", "291"], ["Estonia (Eesti)", "ee", "372"], ["Eswatini", "sz", "268"], ["Ethiopia", "et", "251"], ["Falkland Islands (Islas Malvinas)", "fk", "500"], ["Faroe Islands (F\xF8royar)", "fo", "298"], ["Fiji", "fj", "679"], ["Finland (Suomi)", "fi", "358", 0], ["France", "fr", "33"], ["French Guiana (Guyane fran\xE7aise)", "gf", "594"], ["French Polynesia (Polyn\xE9sie fran\xE7aise)", "pf", "689"], ["Gabon", "ga", "241"], ["Gambia", "gm", "220"], ["Georgia (\u10E1\u10D0\u10E5\u10D0\u10E0\u10D7\u10D5\u10D4\u10DA\u10DD)", "ge", "995"], ["Germany (Deutschland)", "de", "49"], ["Ghana (Gaana)", "gh", "233"], ["Gibraltar", "gi", "350"], ["Greece (\u0395\u03BB\u03BB\u03AC\u03B4\u03B1)", "gr", "30"], ["Greenland (Kalaallit Nunaat)", "gl", "299"], ["Grenada", "gd", "1", 14, ["473"]], ["Guadeloupe", "gp", "590", 0], ["Guam", "gu", "1", 15, ["671"]], ["Guatemala", "gt", "502"], ["Guernsey", "gg", "44", 1, ["1481", "7781", "7839", "7911"]], ["Guinea (Guin\xE9e)", "gn", "224"], ["Guinea-Bissau (Guin\xE9 Bissau)", "gw", "245"], ["Guyana", "gy", "592"], ["Haiti", "ht", "509"], ["Honduras", "hn", "504"], ["Hong Kong (\u9999\u6E2F)", "hk", "852"], ["Hungary (Magyarorsz\xE1g)", "hu", "36"], ["Iceland (\xCDsland)", "is", "354"], ["India (\u092D\u093E\u0930\u0924)", "in", "91"], ["Indonesia", "id", "62"], ["Iran (\u202B\u0627\u06CC\u0631\u0627\u0646\u202C\u200E)", "ir", "98"], ["Iraq (\u202B\u0627\u0644\u0639\u0631\u0627\u0642\u202C\u200E)", "iq", "964"], ["Ireland", "ie", "353"], ["Isle of Man", "im", "44", 2, ["1624", "74576", "7524", "7924", "7624"]], ["Israel (\u202B\u05D9\u05E9\u05E8\u05D0\u05DC\u202C\u200E)", "il", "972"], ["Italy (Italia)", "it", "39", 0], ["Jamaica", "jm", "1", 4, ["876", "658"]], ["Japan (\u65E5\u672C)", "jp", "81"], ["Jersey", "je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"]], ["Jordan (\u202B\u0627\u0644\u0623\u0631\u062F\u0646\u202C\u200E)", "jo", "962"], ["Kazakhstan (\u041A\u0430\u0437\u0430\u0445\u0441\u0442\u0430\u043D)", "kz", "7", 1, ["33", "7"]], ["Kenya", "ke", "254"], ["Kiribati", "ki", "686"], ["Kosovo", "xk", "383"], ["Kuwait (\u202B\u0627\u0644\u0643\u0648\u064A\u062A\u202C\u200E)", "kw", "965"], ["Kyrgyzstan (\u041A\u044B\u0440\u0433\u044B\u0437\u0441\u0442\u0430\u043D)", "kg", "996"], ["Laos (\u0EA5\u0EB2\u0EA7)", "la", "856"], ["Latvia (Latvija)", "lv", "371"], ["Lebanon (\u202B\u0644\u0628\u0646\u0627\u0646\u202C\u200E)", "lb", "961"], ["Lesotho", "ls", "266"], ["Liberia", "lr", "231"], ["Libya (\u202B\u0644\u064A\u0628\u064A\u0627\u202C\u200E)", "ly", "218"], ["Liechtenstein", "li", "423"], ["Lithuania (Lietuva)", "lt", "370"], ["Luxembourg", "lu", "352"], ["Macau (\u6FB3\u9580)", "mo", "853"], ["North Macedonia (\u041C\u0430\u043A\u0435\u0434\u043E\u043D\u0438\u0458\u0430)", "mk", "389"], ["Madagascar (Madagasikara)", "mg", "261"], ["Malawi", "mw", "265"], ["Malaysia", "my", "60"], ["Maldives", "mv", "960"], ["Mali", "ml", "223"], ["Malta", "mt", "356"], ["Marshall Islands", "mh", "692"], ["Martinique", "mq", "596"], ["Mauritania (\u202B\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627\u202C\u200E)", "mr", "222"], ["Mauritius (Moris)", "mu", "230"], ["Mayotte", "yt", "262", 1, ["269", "639"]], ["Mexico (M\xE9xico)", "mx", "52"], ["Micronesia", "fm", "691"], ["Moldova (Republica Moldova)", "md", "373"], ["Monaco", "mc", "377"], ["Mongolia (\u041C\u043E\u043D\u0433\u043E\u043B)", "mn", "976"], ["Montenegro (Crna Gora)", "me", "382"], ["Montserrat", "ms", "1", 16, ["664"]], ["Morocco (\u202B\u0627\u0644\u0645\u063A\u0631\u0628\u202C\u200E)", "ma", "212", 0], ["Mozambique (Mo\xE7ambique)", "mz", "258"], ["Myanmar (Burma) (\u1019\u103C\u1014\u103A\u1019\u102C)", "mm", "95"], ["Namibia (Namibi\xEB)", "na", "264"], ["Nauru", "nr", "674"], ["Nepal (\u0928\u0947\u092A\u093E\u0932)", "np", "977"], ["Netherlands (Nederland)", "nl", "31"], ["New Caledonia (Nouvelle-Cal\xE9donie)", "nc", "687"], ["New Zealand", "nz", "64"], ["Nicaragua", "ni", "505"], ["Niger (Nijar)", "ne", "227"], ["Nigeria", "ng", "234"], ["Niue", "nu", "683"], ["Norfolk Island", "nf", "672"], ["North Korea (\uC870\uC120 \uBBFC\uC8FC\uC8FC\uC758 \uC778\uBBFC \uACF5\uD654\uAD6D)", "kp", "850"], ["Northern Mariana Islands", "mp", "1", 17, ["670"]], ["Norway (Norge)", "no", "47", 0], ["Oman (\u202B\u0639\u064F\u0645\u0627\u0646\u202C\u200E)", "om", "968"], ["Pakistan (\u202B\u067E\u0627\u06A9\u0633\u062A\u0627\u0646\u202C\u200E)", "pk", "92"], ["Palau", "pw", "680"], ["Palestine (\u202B\u0641\u0644\u0633\u0637\u064A\u0646\u202C\u200E)", "ps", "970"], ["Panama (Panam\xE1)", "pa", "507"], ["Papua New Guinea", "pg", "675"], ["Paraguay", "py", "595"], ["Peru (Per\xFA)", "pe", "51"], ["Philippines", "ph", "63"], ["Poland (Polska)", "pl", "48"], ["Portugal", "pt", "351"], ["Puerto Rico", "pr", "1", 3, ["787", "939"]], ["Qatar (\u202B\u0642\u0637\u0631\u202C\u200E)", "qa", "974"], ["R\xE9union (La R\xE9union)", "re", "262", 0], ["Romania (Rom\xE2nia)", "ro", "40"], ["Russia (\u0420\u043E\u0441\u0441\u0438\u044F)", "ru", "7", 0], ["Rwanda", "rw", "250"], ["Saint Barth\xE9lemy", "bl", "590", 1], ["Saint Helena", "sh", "290"], ["Saint Kitts and Nevis", "kn", "1", 18, ["869"]], ["Saint Lucia", "lc", "1", 19, ["758"]], ["Saint Martin (Saint-Martin (partie fran\xE7aise))", "mf", "590", 2], ["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)", "pm", "508"], ["Saint Vincent and the Grenadines", "vc", "1", 20, ["784"]], ["Samoa", "ws", "685"], ["San Marino", "sm", "378"], ["S\xE3o Tom\xE9 and Pr\xEDncipe (S\xE3o Tom\xE9 e Pr\xEDncipe)", "st", "239"], ["Saudi Arabia (\u202B\u0627\u0644\u0645\u0645\u0644\u0643\u0629 \u0627\u0644\u0639\u0631\u0628\u064A\u0629 \u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629\u202C\u200E)", "sa", "966"], ["Senegal (S\xE9n\xE9gal)", "sn", "221"], ["Serbia (\u0421\u0440\u0431\u0438\u0458\u0430)", "rs", "381"], ["Seychelles", "sc", "248"], ["Sierra Leone", "sl", "232"], ["Singapore", "sg", "65"], ["Sint Maarten", "sx", "1", 21, ["721"]], ["Slovakia (Slovensko)", "sk", "421"], ["Slovenia (Slovenija)", "si", "386"], ["Solomon Islands", "sb", "677"], ["Somalia (Soomaaliya)", "so", "252"], ["South Africa", "za", "27"], ["South Korea (\uB300\uD55C\uBBFC\uAD6D)", "kr", "82"], ["South Sudan (\u202B\u062C\u0646\u0648\u0628 \u0627\u0644\u0633\u0648\u062F\u0627\u0646\u202C\u200E)", "ss", "211"], ["Spain (Espa\xF1a)", "es", "34"], ["Sri Lanka (\u0DC1\u0DCA\u200D\u0DBB\u0DD3 \u0DBD\u0D82\u0D9A\u0DCF\u0DC0)", "lk", "94"], ["Sudan (\u202B\u0627\u0644\u0633\u0648\u062F\u0627\u0646\u202C\u200E)", "sd", "249"], ["Suriname", "sr", "597"], ["Svalbard and Jan Mayen", "sj", "47", 1, ["79"]], ["Sweden (Sverige)", "se", "46"], ["Switzerland (Schweiz)", "ch", "41"], ["Syria (\u202B\u0633\u0648\u0631\u064A\u0627\u202C\u200E)", "sy", "963"], ["Taiwan (\u53F0\u7063)", "tw", "886"], ["Tajikistan", "tj", "992"], ["Tanzania", "tz", "255"], ["Thailand (\u0E44\u0E17\u0E22)", "th", "66"], ["Timor-Leste", "tl", "670"], ["Togo", "tg", "228"], ["Tokelau", "tk", "690"], ["Tonga", "to", "676"], ["Trinidad and Tobago", "tt", "1", 22, ["868"]], ["Tunisia (\u202B\u062A\u0648\u0646\u0633\u202C\u200E)", "tn", "216"], ["Turkey (T\xFCrkiye)", "tr", "90"], ["Turkmenistan", "tm", "993"], ["Turks and Caicos Islands", "tc", "1", 23, ["649"]], ["Tuvalu", "tv", "688"], ["U.S. Virgin Islands", "vi", "1", 24, ["340"]], ["Uganda", "ug", "256"], ["Ukraine (\u0423\u043A\u0440\u0430\u0457\u043D\u0430)", "ua", "380"], ["United Arab Emirates (\u202B\u0627\u0644\u0625\u0645\u0627\u0631\u0627\u062A \u0627\u0644\u0639\u0631\u0628\u064A\u0629 \u0627\u0644\u0645\u062A\u062D\u062F\u0629\u202C\u200E)", "ae", "971"], ["United Kingdom", "gb", "44", 0], ["United States", "us", "1", 0], ["Uruguay", "uy", "598"], ["Uzbekistan (O\u02BBzbekiston)", "uz", "998"], ["Vanuatu", "vu", "678"], ["Vatican City (Citt\xE0 del Vaticano)", "va", "39", 1, ["06698"]], ["Venezuela", "ve", "58"], ["Vietnam (Vi\u1EC7t Nam)", "vn", "84"], ["Wallis and Futuna (Wallis-et-Futuna)", "wf", "681"], ["Western Sahara (\u202B\u0627\u0644\u0635\u062D\u0631\u0627\u0621 \u0627\u0644\u063A\u0631\u0628\u064A\u0629\u202C\u200E)", "eh", "212", 1, ["5288", "5289"]], ["Yemen (\u202B\u0627\u0644\u064A\u0645\u0646\u202C\u200E)", "ye", "967"], ["Zambia", "zm", "260"], ["Zimbabwe", "zw", "263"], ["\xC5land Islands", "ax", "358", 1, ["18"]]];
          for (var i = 0; i < allCountries.length; i++) {
            var c = allCountries[i];
            allCountries[i] = {
              name: c[0],
              iso2: c[1],
              dialCode: c[2],
              priority: c[3] || 0,
              areaCodes: c[4] || null
            };
          }
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i2 = 0; i2 < props.length; i2++) {
              var descriptor = props[i2];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          var intlTelInputGlobals = {
            getInstance: function getInstance(input) {
              var id2 = input.getAttribute("data-intl-tel-input-id");
              return window.intlTelInputGlobals.instances[id2];
            },
            instances: {},
            documentReady: function documentReady() {
              return document.readyState === "complete";
            }
          };
          if (typeof window === "object")
            window.intlTelInputGlobals = intlTelInputGlobals;
          var id = 0;
          var defaults = {
            allowDropdown: true,
            autoHideDialCode: true,
            autoPlaceholder: "polite",
            customContainer: "",
            customPlaceholder: null,
            dropdownContainer: null,
            excludeCountries: [],
            formatOnDisplay: true,
            geoIpLookup: null,
            hiddenInput: "",
            initialCountry: "",
            localizedCountries: null,
            nationalMode: true,
            onlyCountries: [],
            placeholderNumberType: "MOBILE",
            preferredCountries: ["us", "gb"],
            separateDialCode: false,
            utilsScript: ""
          };
          var regionlessNanpNumbers = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"];
          var forEachProp = function forEachProp2(obj, callback) {
            var keys = Object.keys(obj);
            for (var i2 = 0; i2 < keys.length; i2++) {
              callback(keys[i2], obj[keys[i2]]);
            }
          };
          var forEachInstance = function forEachInstance2(method) {
            forEachProp(window.intlTelInputGlobals.instances, function(key) {
              window.intlTelInputGlobals.instances[key][method]();
            });
          };
          var Iti = /* @__PURE__ */ function() {
            function Iti2(input, options) {
              var _this = this;
              _classCallCheck(this, Iti2);
              this.id = id++;
              this.telInput = input;
              this.activeItem = null;
              this.highlightedItem = null;
              var customOptions = options || {};
              this.options = {};
              forEachProp(defaults, function(key, value2) {
                _this.options[key] = customOptions.hasOwnProperty(key) ? customOptions[key] : value2;
              });
              this.hadInitialPlaceholder = Boolean(input.getAttribute("placeholder"));
            }
            _createClass(Iti2, [{
              key: "_init",
              value: function _init() {
                var _this2 = this;
                if (this.options.nationalMode)
                  this.options.autoHideDialCode = false;
                if (this.options.separateDialCode) {
                  this.options.autoHideDialCode = this.options.nationalMode = false;
                }
                this.isMobile = /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (this.isMobile) {
                  document.body.classList.add("iti-mobile");
                  if (!this.options.dropdownContainer)
                    this.options.dropdownContainer = document.body;
                }
                if (typeof Promise !== "undefined") {
                  var autoCountryPromise = new Promise(function(resolve, reject) {
                    _this2.resolveAutoCountryPromise = resolve;
                    _this2.rejectAutoCountryPromise = reject;
                  });
                  var utilsScriptPromise = new Promise(function(resolve, reject) {
                    _this2.resolveUtilsScriptPromise = resolve;
                    _this2.rejectUtilsScriptPromise = reject;
                  });
                  this.promise = Promise.all([autoCountryPromise, utilsScriptPromise]);
                } else {
                  this.resolveAutoCountryPromise = this.rejectAutoCountryPromise = function() {
                  };
                  this.resolveUtilsScriptPromise = this.rejectUtilsScriptPromise = function() {
                  };
                }
                this.selectedCountryData = {};
                this._processCountryData();
                this._generateMarkup();
                this._setInitialState();
                this._initListeners();
                this._initRequests();
              }
            }, {
              key: "_processCountryData",
              value: function _processCountryData() {
                this._processAllCountries();
                this._processCountryCodes();
                this._processPreferredCountries();
                if (this.options.localizedCountries)
                  this._translateCountriesByLocale();
                if (this.options.onlyCountries.length || this.options.localizedCountries) {
                  this.countries.sort(this._countryNameSort);
                }
              }
            }, {
              key: "_addCountryCode",
              value: function _addCountryCode(iso2, countryCode, priority) {
                if (countryCode.length > this.countryCodeMaxLen) {
                  this.countryCodeMaxLen = countryCode.length;
                }
                if (!this.countryCodes.hasOwnProperty(countryCode)) {
                  this.countryCodes[countryCode] = [];
                }
                for (var i2 = 0; i2 < this.countryCodes[countryCode].length; i2++) {
                  if (this.countryCodes[countryCode][i2] === iso2)
                    return;
                }
                var index2 = priority !== undefined2 ? priority : this.countryCodes[countryCode].length;
                this.countryCodes[countryCode][index2] = iso2;
              }
            }, {
              key: "_processAllCountries",
              value: function _processAllCountries() {
                if (this.options.onlyCountries.length) {
                  var lowerCaseOnlyCountries = this.options.onlyCountries.map(function(country) {
                    return country.toLowerCase();
                  });
                  this.countries = allCountries.filter(function(country) {
                    return lowerCaseOnlyCountries.indexOf(country.iso2) > -1;
                  });
                } else if (this.options.excludeCountries.length) {
                  var lowerCaseExcludeCountries = this.options.excludeCountries.map(function(country) {
                    return country.toLowerCase();
                  });
                  this.countries = allCountries.filter(function(country) {
                    return lowerCaseExcludeCountries.indexOf(country.iso2) === -1;
                  });
                } else {
                  this.countries = allCountries;
                }
              }
            }, {
              key: "_translateCountriesByLocale",
              value: function _translateCountriesByLocale() {
                for (var i2 = 0; i2 < this.countries.length; i2++) {
                  var iso = this.countries[i2].iso2.toLowerCase();
                  if (this.options.localizedCountries.hasOwnProperty(iso)) {
                    this.countries[i2].name = this.options.localizedCountries[iso];
                  }
                }
              }
            }, {
              key: "_countryNameSort",
              value: function _countryNameSort(a, b) {
                return a.name.localeCompare(b.name);
              }
            }, {
              key: "_processCountryCodes",
              value: function _processCountryCodes() {
                this.countryCodeMaxLen = 0;
                this.dialCodes = {};
                this.countryCodes = {};
                for (var i2 = 0; i2 < this.countries.length; i2++) {
                  var c2 = this.countries[i2];
                  if (!this.dialCodes[c2.dialCode])
                    this.dialCodes[c2.dialCode] = true;
                  this._addCountryCode(c2.iso2, c2.dialCode, c2.priority);
                }
                for (var _i = 0; _i < this.countries.length; _i++) {
                  var _c = this.countries[_i];
                  if (_c.areaCodes) {
                    var rootCountryCode = this.countryCodes[_c.dialCode][0];
                    for (var j = 0; j < _c.areaCodes.length; j++) {
                      var areaCode = _c.areaCodes[j];
                      for (var k = 1; k < areaCode.length; k++) {
                        var partialDialCode = _c.dialCode + areaCode.substr(0, k);
                        this._addCountryCode(rootCountryCode, partialDialCode);
                        this._addCountryCode(_c.iso2, partialDialCode);
                      }
                      this._addCountryCode(_c.iso2, _c.dialCode + areaCode);
                    }
                  }
                }
              }
            }, {
              key: "_processPreferredCountries",
              value: function _processPreferredCountries() {
                this.preferredCountries = [];
                for (var i2 = 0; i2 < this.options.preferredCountries.length; i2++) {
                  var countryCode = this.options.preferredCountries[i2].toLowerCase();
                  var countryData = this._getCountryData(countryCode, false, true);
                  if (countryData)
                    this.preferredCountries.push(countryData);
                }
              }
            }, {
              key: "_createEl",
              value: function _createEl(name, attrs, container) {
                var el = document.createElement(name);
                if (attrs)
                  forEachProp(attrs, function(key, value2) {
                    return el.setAttribute(key, value2);
                  });
                if (container)
                  container.appendChild(el);
                return el;
              }
            }, {
              key: "_generateMarkup",
              value: function _generateMarkup() {
                if (!this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete"))) {
                  this.telInput.setAttribute("autocomplete", "off");
                }
                var parentClass = "iti";
                if (this.options.allowDropdown)
                  parentClass += " iti--allow-dropdown";
                if (this.options.separateDialCode)
                  parentClass += " iti--separate-dial-code";
                if (this.options.customContainer) {
                  parentClass += " ";
                  parentClass += this.options.customContainer;
                }
                var wrapper = this._createEl("div", {
                  "class": parentClass
                });
                this.telInput.parentNode.insertBefore(wrapper, this.telInput);
                this.flagsContainer = this._createEl("div", {
                  "class": "iti__flag-container"
                }, wrapper);
                wrapper.appendChild(this.telInput);
                this.selectedFlag = this._createEl("div", {
                  "class": "iti__selected-flag",
                  role: "combobox",
                  "aria-controls": "iti-".concat(this.id, "__country-listbox"),
                  "aria-owns": "iti-".concat(this.id, "__country-listbox"),
                  "aria-expanded": "false"
                }, this.flagsContainer);
                this.selectedFlagInner = this._createEl("div", {
                  "class": "iti__flag"
                }, this.selectedFlag);
                if (this.options.separateDialCode) {
                  this.selectedDialCode = this._createEl("div", {
                    "class": "iti__selected-dial-code"
                  }, this.selectedFlag);
                }
                if (this.options.allowDropdown) {
                  this.selectedFlag.setAttribute("tabindex", "0");
                  this.dropdownArrow = this._createEl("div", {
                    "class": "iti__arrow"
                  }, this.selectedFlag);
                  this.countryList = this._createEl("ul", {
                    "class": "iti__country-list iti__hide",
                    id: "iti-".concat(this.id, "__country-listbox"),
                    role: "listbox",
                    "aria-label": "List of countries"
                  });
                  if (this.preferredCountries.length) {
                    this._appendListItems(this.preferredCountries, "iti__preferred", true);
                    this._createEl("li", {
                      "class": "iti__divider",
                      role: "separator",
                      "aria-disabled": "true"
                    }, this.countryList);
                  }
                  this._appendListItems(this.countries, "iti__standard");
                  if (this.options.dropdownContainer) {
                    this.dropdown = this._createEl("div", {
                      "class": "iti iti--container"
                    });
                    this.dropdown.appendChild(this.countryList);
                  } else {
                    this.flagsContainer.appendChild(this.countryList);
                  }
                }
                if (this.options.hiddenInput) {
                  var hiddenInputName = this.options.hiddenInput;
                  var name = this.telInput.getAttribute("name");
                  if (name) {
                    var i2 = name.lastIndexOf("[");
                    if (i2 !== -1)
                      hiddenInputName = "".concat(name.substr(0, i2), "[").concat(hiddenInputName, "]");
                  }
                  this.hiddenInput = this._createEl("input", {
                    type: "hidden",
                    name: hiddenInputName
                  });
                  wrapper.appendChild(this.hiddenInput);
                }
              }
            }, {
              key: "_appendListItems",
              value: function _appendListItems(countries, className, preferred) {
                var tmp = "";
                for (var i2 = 0; i2 < countries.length; i2++) {
                  var c2 = countries[i2];
                  var idSuffix = preferred ? "-preferred" : "";
                  tmp += "<li class='iti__country ".concat(className, "' tabIndex='-1' id='iti-").concat(this.id, "__item-").concat(c2.iso2).concat(idSuffix, "' role='option' data-dial-code='").concat(c2.dialCode, "' data-country-code='").concat(c2.iso2, "' aria-selected='false'>");
                  tmp += "<div class='iti__flag-box'><div class='iti__flag iti__".concat(c2.iso2, "'></div></div>");
                  tmp += "<span class='iti__country-name'>".concat(c2.name, "</span>");
                  tmp += "<span class='iti__dial-code'>+".concat(c2.dialCode, "</span>");
                  tmp += "</li>";
                }
                this.countryList.insertAdjacentHTML("beforeend", tmp);
              }
            }, {
              key: "_setInitialState",
              value: function _setInitialState() {
                var attributeValue = this.telInput.getAttribute("value");
                var inputValue = this.telInput.value;
                var useAttribute = attributeValue && attributeValue.charAt(0) === "+" && (!inputValue || inputValue.charAt(0) !== "+");
                var val = useAttribute ? attributeValue : inputValue;
                var dialCode = this._getDialCode(val);
                var isRegionlessNanp = this._isRegionlessNanp(val);
                var _this$options = this.options, initialCountry = _this$options.initialCountry, nationalMode = _this$options.nationalMode, autoHideDialCode = _this$options.autoHideDialCode, separateDialCode = _this$options.separateDialCode;
                if (dialCode && !isRegionlessNanp) {
                  this._updateFlagFromNumber(val);
                } else if (initialCountry !== "auto") {
                  if (initialCountry) {
                    this._setFlag(initialCountry.toLowerCase());
                  } else {
                    if (dialCode && isRegionlessNanp) {
                      this._setFlag("us");
                    } else {
                      this.defaultCountry = this.preferredCountries.length ? this.preferredCountries[0].iso2 : this.countries[0].iso2;
                      if (!val) {
                        this._setFlag(this.defaultCountry);
                      }
                    }
                  }
                  if (!val && !nationalMode && !autoHideDialCode && !separateDialCode) {
                    this.telInput.value = "+".concat(this.selectedCountryData.dialCode);
                  }
                }
                if (val)
                  this._updateValFromNumber(val);
              }
            }, {
              key: "_initListeners",
              value: function _initListeners() {
                this._initKeyListeners();
                if (this.options.autoHideDialCode)
                  this._initBlurListeners();
                if (this.options.allowDropdown)
                  this._initDropdownListeners();
                if (this.hiddenInput)
                  this._initHiddenInputListener();
              }
            }, {
              key: "_initHiddenInputListener",
              value: function _initHiddenInputListener() {
                var _this3 = this;
                this._handleHiddenInputSubmit = function() {
                  _this3.hiddenInput.value = _this3.getNumber();
                };
                if (this.telInput.form)
                  this.telInput.form.addEventListener("submit", this._handleHiddenInputSubmit);
              }
            }, {
              key: "_getClosestLabel",
              value: function _getClosestLabel() {
                var el = this.telInput;
                while (el && el.tagName !== "LABEL") {
                  el = el.parentNode;
                }
                return el;
              }
            }, {
              key: "_initDropdownListeners",
              value: function _initDropdownListeners() {
                var _this4 = this;
                this._handleLabelClick = function(e2) {
                  if (_this4.countryList.classList.contains("iti__hide"))
                    _this4.telInput.focus();
                  else
                    e2.preventDefault();
                };
                var label = this._getClosestLabel();
                if (label)
                  label.addEventListener("click", this._handleLabelClick);
                this._handleClickSelectedFlag = function() {
                  if (_this4.countryList.classList.contains("iti__hide") && !_this4.telInput.disabled && !_this4.telInput.readOnly) {
                    _this4._showDropdown();
                  }
                };
                this.selectedFlag.addEventListener("click", this._handleClickSelectedFlag);
                this._handleFlagsContainerKeydown = function(e2) {
                  var isDropdownHidden = _this4.countryList.classList.contains("iti__hide");
                  if (isDropdownHidden && ["ArrowUp", "Up", "ArrowDown", "Down", " ", "Enter"].indexOf(e2.key) !== -1) {
                    e2.preventDefault();
                    e2.stopPropagation();
                    _this4._showDropdown();
                  }
                  if (e2.key === "Tab")
                    _this4._closeDropdown();
                };
                this.flagsContainer.addEventListener("keydown", this._handleFlagsContainerKeydown);
              }
            }, {
              key: "_initRequests",
              value: function _initRequests() {
                var _this5 = this;
                if (this.options.utilsScript && !window.intlTelInputUtils) {
                  if (window.intlTelInputGlobals.documentReady()) {
                    window.intlTelInputGlobals.loadUtils(this.options.utilsScript);
                  } else {
                    window.addEventListener("load", function() {
                      window.intlTelInputGlobals.loadUtils(_this5.options.utilsScript);
                    });
                  }
                } else
                  this.resolveUtilsScriptPromise();
                if (this.options.initialCountry === "auto")
                  this._loadAutoCountry();
                else
                  this.resolveAutoCountryPromise();
              }
            }, {
              key: "_loadAutoCountry",
              value: function _loadAutoCountry() {
                if (window.intlTelInputGlobals.autoCountry) {
                  this.handleAutoCountry();
                } else if (!window.intlTelInputGlobals.startedLoadingAutoCountry) {
                  window.intlTelInputGlobals.startedLoadingAutoCountry = true;
                  if (typeof this.options.geoIpLookup === "function") {
                    this.options.geoIpLookup(function(countryCode) {
                      window.intlTelInputGlobals.autoCountry = countryCode.toLowerCase();
                      setTimeout(function() {
                        return forEachInstance("handleAutoCountry");
                      });
                    }, function() {
                      return forEachInstance("rejectAutoCountryPromise");
                    });
                  }
                }
              }
            }, {
              key: "_initKeyListeners",
              value: function _initKeyListeners() {
                var _this6 = this;
                this._handleKeyupEvent = function() {
                  if (_this6._updateFlagFromNumber(_this6.telInput.value)) {
                    _this6._triggerCountryChange();
                  }
                };
                this.telInput.addEventListener("keyup", this._handleKeyupEvent);
                this._handleClipboardEvent = function() {
                  setTimeout(_this6._handleKeyupEvent);
                };
                this.telInput.addEventListener("cut", this._handleClipboardEvent);
                this.telInput.addEventListener("paste", this._handleClipboardEvent);
              }
            }, {
              key: "_cap",
              value: function _cap(number) {
                var max = this.telInput.getAttribute("maxlength");
                return max && number.length > max ? number.substr(0, max) : number;
              }
            }, {
              key: "_initBlurListeners",
              value: function _initBlurListeners() {
                var _this7 = this;
                this._handleSubmitOrBlurEvent = function() {
                  _this7._removeEmptyDialCode();
                };
                if (this.telInput.form)
                  this.telInput.form.addEventListener("submit", this._handleSubmitOrBlurEvent);
                this.telInput.addEventListener("blur", this._handleSubmitOrBlurEvent);
              }
            }, {
              key: "_removeEmptyDialCode",
              value: function _removeEmptyDialCode() {
                if (this.telInput.value.charAt(0) === "+") {
                  var numeric = this._getNumeric(this.telInput.value);
                  if (!numeric || this.selectedCountryData.dialCode === numeric) {
                    this.telInput.value = "";
                  }
                }
              }
            }, {
              key: "_getNumeric",
              value: function _getNumeric(s) {
                return s.replace(/\D/g, "");
              }
            }, {
              key: "_trigger",
              value: function _trigger(name) {
                var e2 = document.createEvent("Event");
                e2.initEvent(name, true, true);
                this.telInput.dispatchEvent(e2);
              }
            }, {
              key: "_showDropdown",
              value: function _showDropdown() {
                this.countryList.classList.remove("iti__hide");
                this.selectedFlag.setAttribute("aria-expanded", "true");
                this._setDropdownPosition();
                if (this.activeItem) {
                  this._highlightListItem(this.activeItem, false);
                  this._scrollTo(this.activeItem, true);
                }
                this._bindDropdownListeners();
                this.dropdownArrow.classList.add("iti__arrow--up");
                this._trigger("open:countrydropdown");
              }
            }, {
              key: "_toggleClass",
              value: function _toggleClass(el, className, shouldHaveClass) {
                if (shouldHaveClass && !el.classList.contains(className))
                  el.classList.add(className);
                else if (!shouldHaveClass && el.classList.contains(className))
                  el.classList.remove(className);
              }
            }, {
              key: "_setDropdownPosition",
              value: function _setDropdownPosition() {
                var _this8 = this;
                if (this.options.dropdownContainer) {
                  this.options.dropdownContainer.appendChild(this.dropdown);
                }
                if (!this.isMobile) {
                  var pos = this.telInput.getBoundingClientRect();
                  var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                  var inputTop = pos.top + windowTop;
                  var dropdownHeight = this.countryList.offsetHeight;
                  var dropdownFitsBelow = inputTop + this.telInput.offsetHeight + dropdownHeight < windowTop + window.innerHeight;
                  var dropdownFitsAbove = inputTop - dropdownHeight > windowTop;
                  this._toggleClass(this.countryList, "iti__country-list--dropup", !dropdownFitsBelow && dropdownFitsAbove);
                  if (this.options.dropdownContainer) {
                    var extraTop = !dropdownFitsBelow && dropdownFitsAbove ? 0 : this.telInput.offsetHeight;
                    this.dropdown.style.top = "".concat(inputTop + extraTop, "px");
                    this.dropdown.style.left = "".concat(pos.left + document.body.scrollLeft, "px");
                    this._handleWindowScroll = function() {
                      return _this8._closeDropdown();
                    };
                    window.addEventListener("scroll", this._handleWindowScroll);
                  }
                }
              }
            }, {
              key: "_getClosestListItem",
              value: function _getClosestListItem(target) {
                var el = target;
                while (el && el !== this.countryList && !el.classList.contains("iti__country")) {
                  el = el.parentNode;
                }
                return el === this.countryList ? null : el;
              }
            }, {
              key: "_bindDropdownListeners",
              value: function _bindDropdownListeners() {
                var _this9 = this;
                this._handleMouseoverCountryList = function(e2) {
                  var listItem = _this9._getClosestListItem(e2.target);
                  if (listItem)
                    _this9._highlightListItem(listItem, false);
                };
                this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList);
                this._handleClickCountryList = function(e2) {
                  var listItem = _this9._getClosestListItem(e2.target);
                  if (listItem)
                    _this9._selectListItem(listItem);
                };
                this.countryList.addEventListener("click", this._handleClickCountryList);
                var isOpening = true;
                this._handleClickOffToClose = function() {
                  if (!isOpening)
                    _this9._closeDropdown();
                  isOpening = false;
                };
                document.documentElement.addEventListener("click", this._handleClickOffToClose);
                var query = "";
                var queryTimer = null;
                this._handleKeydownOnDropdown = function(e2) {
                  e2.preventDefault();
                  if (e2.key === "ArrowUp" || e2.key === "Up" || e2.key === "ArrowDown" || e2.key === "Down")
                    _this9._handleUpDownKey(e2.key);
                  else if (e2.key === "Enter")
                    _this9._handleEnterKey();
                  else if (e2.key === "Escape")
                    _this9._closeDropdown();
                  else if (/^[a-zA-Z--- ]$/.test(e2.key)) {
                    if (queryTimer)
                      clearTimeout(queryTimer);
                    query += e2.key.toLowerCase();
                    _this9._searchForCountry(query);
                    queryTimer = setTimeout(function() {
                      query = "";
                    }, 1e3);
                  }
                };
                document.addEventListener("keydown", this._handleKeydownOnDropdown);
              }
            }, {
              key: "_handleUpDownKey",
              value: function _handleUpDownKey(key) {
                var next2 = key === "ArrowUp" || key === "Up" ? this.highlightedItem.previousElementSibling : this.highlightedItem.nextElementSibling;
                if (next2) {
                  if (next2.classList.contains("iti__divider")) {
                    next2 = key === "ArrowUp" || key === "Up" ? next2.previousElementSibling : next2.nextElementSibling;
                  }
                  this._highlightListItem(next2, true);
                }
              }
            }, {
              key: "_handleEnterKey",
              value: function _handleEnterKey() {
                if (this.highlightedItem)
                  this._selectListItem(this.highlightedItem);
              }
            }, {
              key: "_searchForCountry",
              value: function _searchForCountry(query) {
                for (var i2 = 0; i2 < this.countries.length; i2++) {
                  if (this._startsWith(this.countries[i2].name, query)) {
                    var listItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(this.countries[i2].iso2));
                    this._highlightListItem(listItem, false);
                    this._scrollTo(listItem, true);
                    break;
                  }
                }
              }
            }, {
              key: "_startsWith",
              value: function _startsWith(a, b) {
                return a.substr(0, b.length).toLowerCase() === b;
              }
            }, {
              key: "_updateValFromNumber",
              value: function _updateValFromNumber(originalNumber) {
                var number = originalNumber;
                if (this.options.formatOnDisplay && window.intlTelInputUtils && this.selectedCountryData) {
                  var useNational = !this.options.separateDialCode && (this.options.nationalMode || number.charAt(0) !== "+");
                  var _intlTelInputUtils$nu = intlTelInputUtils.numberFormat, NATIONAL = _intlTelInputUtils$nu.NATIONAL, INTERNATIONAL = _intlTelInputUtils$nu.INTERNATIONAL;
                  var format = useNational ? NATIONAL : INTERNATIONAL;
                  number = intlTelInputUtils.formatNumber(number, this.selectedCountryData.iso2, format);
                }
                number = this._beforeSetNumber(number);
                this.telInput.value = number;
              }
            }, {
              key: "_updateFlagFromNumber",
              value: function _updateFlagFromNumber(originalNumber) {
                var number = originalNumber;
                var selectedDialCode = this.selectedCountryData.dialCode;
                var isNanp = selectedDialCode === "1";
                if (number && this.options.nationalMode && isNanp && number.charAt(0) !== "+") {
                  if (number.charAt(0) !== "1")
                    number = "1".concat(number);
                  number = "+".concat(number);
                }
                if (this.options.separateDialCode && selectedDialCode && number.charAt(0) !== "+") {
                  number = "+".concat(selectedDialCode).concat(number);
                }
                var dialCode = this._getDialCode(number, true);
                var numeric = this._getNumeric(number);
                var countryCode = null;
                if (dialCode) {
                  var countryCodes = this.countryCodes[this._getNumeric(dialCode)];
                  var alreadySelected = countryCodes.indexOf(this.selectedCountryData.iso2) !== -1 && numeric.length <= dialCode.length - 1;
                  var isRegionlessNanpNumber = selectedDialCode === "1" && this._isRegionlessNanp(numeric);
                  if (!isRegionlessNanpNumber && !alreadySelected) {
                    for (var j = 0; j < countryCodes.length; j++) {
                      if (countryCodes[j]) {
                        countryCode = countryCodes[j];
                        break;
                      }
                    }
                  }
                } else if (number.charAt(0) === "+" && numeric.length) {
                  countryCode = "";
                } else if (!number || number === "+") {
                  countryCode = this.defaultCountry;
                }
                if (countryCode !== null) {
                  return this._setFlag(countryCode);
                }
                return false;
              }
            }, {
              key: "_isRegionlessNanp",
              value: function _isRegionlessNanp(number) {
                var numeric = this._getNumeric(number);
                if (numeric.charAt(0) === "1") {
                  var areaCode = numeric.substr(1, 3);
                  return regionlessNanpNumbers.indexOf(areaCode) !== -1;
                }
                return false;
              }
            }, {
              key: "_highlightListItem",
              value: function _highlightListItem(listItem, shouldFocus) {
                var prevItem = this.highlightedItem;
                if (prevItem)
                  prevItem.classList.remove("iti__highlight");
                this.highlightedItem = listItem;
                this.highlightedItem.classList.add("iti__highlight");
                if (shouldFocus)
                  this.highlightedItem.focus();
              }
            }, {
              key: "_getCountryData",
              value: function _getCountryData(countryCode, ignoreOnlyCountriesOption, allowFail) {
                var countryList = ignoreOnlyCountriesOption ? allCountries : this.countries;
                for (var i2 = 0; i2 < countryList.length; i2++) {
                  if (countryList[i2].iso2 === countryCode) {
                    return countryList[i2];
                  }
                }
                if (allowFail) {
                  return null;
                }
                throw new Error("No country data for '".concat(countryCode, "'"));
              }
            }, {
              key: "_setFlag",
              value: function _setFlag(countryCode) {
                var prevCountry = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
                this.selectedCountryData = countryCode ? this._getCountryData(countryCode, false, false) : {};
                if (this.selectedCountryData.iso2) {
                  this.defaultCountry = this.selectedCountryData.iso2;
                }
                this.selectedFlagInner.setAttribute("class", "iti__flag iti__".concat(countryCode));
                var title = countryCode ? "".concat(this.selectedCountryData.name, ": +").concat(this.selectedCountryData.dialCode) : "Unknown";
                this.selectedFlag.setAttribute("title", title);
                if (this.options.separateDialCode) {
                  var dialCode = this.selectedCountryData.dialCode ? "+".concat(this.selectedCountryData.dialCode) : "";
                  this.selectedDialCode.innerHTML = dialCode;
                  var selectedFlagWidth = this.selectedFlag.offsetWidth || this._getHiddenSelectedFlagWidth();
                  this.telInput.style.paddingLeft = "".concat(selectedFlagWidth + 6, "px");
                }
                this._updatePlaceholder();
                if (this.options.allowDropdown) {
                  var prevItem = this.activeItem;
                  if (prevItem) {
                    prevItem.classList.remove("iti__active");
                    prevItem.setAttribute("aria-selected", "false");
                  }
                  if (countryCode) {
                    var nextItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode, "-preferred")) || this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode));
                    nextItem.setAttribute("aria-selected", "true");
                    nextItem.classList.add("iti__active");
                    this.activeItem = nextItem;
                    this.selectedFlag.setAttribute("aria-activedescendant", nextItem.getAttribute("id"));
                  }
                }
                return prevCountry.iso2 !== countryCode;
              }
            }, {
              key: "_getHiddenSelectedFlagWidth",
              value: function _getHiddenSelectedFlagWidth() {
                var containerClone = this.telInput.parentNode.cloneNode();
                containerClone.style.visibility = "hidden";
                document.body.appendChild(containerClone);
                var flagsContainerClone = this.flagsContainer.cloneNode();
                containerClone.appendChild(flagsContainerClone);
                var selectedFlagClone = this.selectedFlag.cloneNode(true);
                flagsContainerClone.appendChild(selectedFlagClone);
                var width = selectedFlagClone.offsetWidth;
                containerClone.parentNode.removeChild(containerClone);
                return width;
              }
            }, {
              key: "_updatePlaceholder",
              value: function _updatePlaceholder() {
                var shouldSetPlaceholder = this.options.autoPlaceholder === "aggressive" || !this.hadInitialPlaceholder && this.options.autoPlaceholder === "polite";
                if (window.intlTelInputUtils && shouldSetPlaceholder) {
                  var numberType = intlTelInputUtils.numberType[this.options.placeholderNumberType];
                  var placeholder = this.selectedCountryData.iso2 ? intlTelInputUtils.getExampleNumber(this.selectedCountryData.iso2, this.options.nationalMode, numberType) : "";
                  placeholder = this._beforeSetNumber(placeholder);
                  if (typeof this.options.customPlaceholder === "function") {
                    placeholder = this.options.customPlaceholder(placeholder, this.selectedCountryData);
                  }
                  this.telInput.setAttribute("placeholder", placeholder);
                }
              }
            }, {
              key: "_selectListItem",
              value: function _selectListItem(listItem) {
                var flagChanged = this._setFlag(listItem.getAttribute("data-country-code"));
                this._closeDropdown();
                this._updateDialCode(listItem.getAttribute("data-dial-code"), true);
                this.telInput.focus();
                var len = this.telInput.value.length;
                this.telInput.setSelectionRange(len, len);
                if (flagChanged) {
                  this._triggerCountryChange();
                }
              }
            }, {
              key: "_closeDropdown",
              value: function _closeDropdown() {
                this.countryList.classList.add("iti__hide");
                this.selectedFlag.setAttribute("aria-expanded", "false");
                this.dropdownArrow.classList.remove("iti__arrow--up");
                document.removeEventListener("keydown", this._handleKeydownOnDropdown);
                document.documentElement.removeEventListener("click", this._handleClickOffToClose);
                this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList);
                this.countryList.removeEventListener("click", this._handleClickCountryList);
                if (this.options.dropdownContainer) {
                  if (!this.isMobile)
                    window.removeEventListener("scroll", this._handleWindowScroll);
                  if (this.dropdown.parentNode)
                    this.dropdown.parentNode.removeChild(this.dropdown);
                }
                this._trigger("close:countrydropdown");
              }
            }, {
              key: "_scrollTo",
              value: function _scrollTo(element, middle) {
                var container = this.countryList;
                var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                var containerHeight = container.offsetHeight;
                var containerTop = container.getBoundingClientRect().top + windowTop;
                var containerBottom = containerTop + containerHeight;
                var elementHeight = element.offsetHeight;
                var elementTop = element.getBoundingClientRect().top + windowTop;
                var elementBottom = elementTop + elementHeight;
                var newScrollTop = elementTop - containerTop + container.scrollTop;
                var middleOffset = containerHeight / 2 - elementHeight / 2;
                if (elementTop < containerTop) {
                  if (middle)
                    newScrollTop -= middleOffset;
                  container.scrollTop = newScrollTop;
                } else if (elementBottom > containerBottom) {
                  if (middle)
                    newScrollTop += middleOffset;
                  var heightDifference = containerHeight - elementHeight;
                  container.scrollTop = newScrollTop - heightDifference;
                }
              }
            }, {
              key: "_updateDialCode",
              value: function _updateDialCode(newDialCodeBare, hasSelectedListItem) {
                var inputVal = this.telInput.value;
                var newDialCode = "+".concat(newDialCodeBare);
                var newNumber;
                if (inputVal.charAt(0) === "+") {
                  var prevDialCode = this._getDialCode(inputVal);
                  if (prevDialCode) {
                    newNumber = inputVal.replace(prevDialCode, newDialCode);
                  } else {
                    newNumber = newDialCode;
                  }
                } else if (this.options.nationalMode || this.options.separateDialCode) {
                  return;
                } else {
                  if (inputVal) {
                    newNumber = newDialCode + inputVal;
                  } else if (hasSelectedListItem || !this.options.autoHideDialCode) {
                    newNumber = newDialCode;
                  } else {
                    return;
                  }
                }
                this.telInput.value = newNumber;
              }
            }, {
              key: "_getDialCode",
              value: function _getDialCode(number, includeAreaCode) {
                var dialCode = "";
                if (number.charAt(0) === "+") {
                  var numericChars = "";
                  for (var i2 = 0; i2 < number.length; i2++) {
                    var c2 = number.charAt(i2);
                    if (!isNaN(parseInt(c2, 10))) {
                      numericChars += c2;
                      if (includeAreaCode) {
                        if (this.countryCodes[numericChars]) {
                          dialCode = number.substr(0, i2 + 1);
                        }
                      } else {
                        if (this.dialCodes[numericChars]) {
                          dialCode = number.substr(0, i2 + 1);
                          break;
                        }
                      }
                      if (numericChars.length === this.countryCodeMaxLen) {
                        break;
                      }
                    }
                  }
                }
                return dialCode;
              }
            }, {
              key: "_getFullNumber",
              value: function _getFullNumber() {
                var val = this.telInput.value.trim();
                var dialCode = this.selectedCountryData.dialCode;
                var prefix;
                var numericVal = this._getNumeric(val);
                if (this.options.separateDialCode && val.charAt(0) !== "+" && dialCode && numericVal) {
                  prefix = "+".concat(dialCode);
                } else {
                  prefix = "";
                }
                return prefix + val;
              }
            }, {
              key: "_beforeSetNumber",
              value: function _beforeSetNumber(originalNumber) {
                var number = originalNumber;
                if (this.options.separateDialCode) {
                  var dialCode = this._getDialCode(number);
                  if (dialCode) {
                    dialCode = "+".concat(this.selectedCountryData.dialCode);
                    var start = number[dialCode.length] === " " || number[dialCode.length] === "-" ? dialCode.length + 1 : dialCode.length;
                    number = number.substr(start);
                  }
                }
                return this._cap(number);
              }
            }, {
              key: "_triggerCountryChange",
              value: function _triggerCountryChange() {
                this._trigger("countrychange");
              }
            }, {
              key: "handleAutoCountry",
              value: function handleAutoCountry() {
                if (this.options.initialCountry === "auto") {
                  this.defaultCountry = window.intlTelInputGlobals.autoCountry;
                  if (!this.telInput.value) {
                    this.setCountry(this.defaultCountry);
                  }
                  this.resolveAutoCountryPromise();
                }
              }
            }, {
              key: "handleUtils",
              value: function handleUtils() {
                if (window.intlTelInputUtils) {
                  if (this.telInput.value) {
                    this._updateValFromNumber(this.telInput.value);
                  }
                  this._updatePlaceholder();
                }
                this.resolveUtilsScriptPromise();
              }
            }, {
              key: "destroy",
              value: function destroy2() {
                var form3 = this.telInput.form;
                if (this.options.allowDropdown) {
                  this._closeDropdown();
                  this.selectedFlag.removeEventListener("click", this._handleClickSelectedFlag);
                  this.flagsContainer.removeEventListener("keydown", this._handleFlagsContainerKeydown);
                  var label = this._getClosestLabel();
                  if (label)
                    label.removeEventListener("click", this._handleLabelClick);
                }
                if (this.hiddenInput && form3)
                  form3.removeEventListener("submit", this._handleHiddenInputSubmit);
                if (this.options.autoHideDialCode) {
                  if (form3)
                    form3.removeEventListener("submit", this._handleSubmitOrBlurEvent);
                  this.telInput.removeEventListener("blur", this._handleSubmitOrBlurEvent);
                }
                this.telInput.removeEventListener("keyup", this._handleKeyupEvent);
                this.telInput.removeEventListener("cut", this._handleClipboardEvent);
                this.telInput.removeEventListener("paste", this._handleClipboardEvent);
                this.telInput.removeAttribute("data-intl-tel-input-id");
                var wrapper = this.telInput.parentNode;
                wrapper.parentNode.insertBefore(this.telInput, wrapper);
                wrapper.parentNode.removeChild(wrapper);
                delete window.intlTelInputGlobals.instances[this.id];
              }
            }, {
              key: "getExtension",
              value: function getExtension() {
                if (window.intlTelInputUtils) {
                  return intlTelInputUtils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2);
                }
                return "";
              }
            }, {
              key: "getNumber",
              value: function getNumber(format) {
                if (window.intlTelInputUtils) {
                  var iso2 = this.selectedCountryData.iso2;
                  return intlTelInputUtils.formatNumber(this._getFullNumber(), iso2, format);
                }
                return "";
              }
            }, {
              key: "getNumberType",
              value: function getNumberType() {
                if (window.intlTelInputUtils) {
                  return intlTelInputUtils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2);
                }
                return -99;
              }
            }, {
              key: "getSelectedCountryData",
              value: function getSelectedCountryData() {
                return this.selectedCountryData;
              }
            }, {
              key: "getValidationError",
              value: function getValidationError() {
                if (window.intlTelInputUtils) {
                  var iso2 = this.selectedCountryData.iso2;
                  return intlTelInputUtils.getValidationError(this._getFullNumber(), iso2);
                }
                return -99;
              }
            }, {
              key: "isValidNumber",
              value: function isValidNumber() {
                var val = this._getFullNumber().trim();
                var countryCode = this.options.nationalMode ? this.selectedCountryData.iso2 : "";
                return window.intlTelInputUtils ? intlTelInputUtils.isValidNumber(val, countryCode) : null;
              }
            }, {
              key: "setCountry",
              value: function setCountry(originalCountryCode) {
                var countryCode = originalCountryCode.toLowerCase();
                if (!this.selectedFlagInner.classList.contains("iti__".concat(countryCode))) {
                  this._setFlag(countryCode);
                  this._updateDialCode(this.selectedCountryData.dialCode, false);
                  this._triggerCountryChange();
                }
              }
            }, {
              key: "setNumber",
              value: function setNumber(number) {
                var flagChanged = this._updateFlagFromNumber(number);
                this._updateValFromNumber(number);
                if (flagChanged) {
                  this._triggerCountryChange();
                }
              }
            }, {
              key: "setPlaceholderNumberType",
              value: function setPlaceholderNumberType(type) {
                this.options.placeholderNumberType = type;
                this._updatePlaceholder();
              }
            }]);
            return Iti2;
          }();
          intlTelInputGlobals.getCountryData = function() {
            return allCountries;
          };
          var injectScript = function injectScript2(path, handleSuccess, handleFailure) {
            var script = document.createElement("script");
            script.onload = function() {
              forEachInstance("handleUtils");
              if (handleSuccess)
                handleSuccess();
            };
            script.onerror = function() {
              forEachInstance("rejectUtilsScriptPromise");
              if (handleFailure)
                handleFailure();
            };
            script.className = "iti-load-utils";
            script.async = true;
            script.src = path;
            document.body.appendChild(script);
          };
          intlTelInputGlobals.loadUtils = function(path) {
            if (!window.intlTelInputUtils && !window.intlTelInputGlobals.startedLoadingUtilsScript) {
              window.intlTelInputGlobals.startedLoadingUtilsScript = true;
              if (typeof Promise !== "undefined") {
                return new Promise(function(resolve, reject) {
                  return injectScript(path, resolve, reject);
                });
              }
              injectScript(path);
            }
            return null;
          };
          intlTelInputGlobals.defaults = defaults;
          intlTelInputGlobals.version = "17.0.19";
          return function(input, options) {
            var iti = new Iti(input, options);
            iti._init();
            input.setAttribute("data-intl-tel-input-id", iti.id);
            window.intlTelInputGlobals.instances[iti.id] = iti;
            return iti;
          };
        }();
      });
    }
  });

  // node_modules/intl-tel-input/index.js
  var require_intl_tel_input = __commonJS({
    "node_modules/intl-tel-input/index.js"(exports, module) {
      module.exports = require_intlTelInput();
    }
  });

  // node_modules/accordion-js/dist/accordion.min.js
  var require_accordion_min = __commonJS({
    "node_modules/accordion-js/dist/accordion.min.js"(exports, module) {
      "use strict";
      !function(e2) {
        var t = 0, n = function e3(n2, s) {
          var i = this, o = this, a = false;
          if (Array.isArray(n2))
            return !!n2.length && n2.map(function(t2) {
              return new e3(t2, s);
            });
          var r = { init: function() {
            this.options = Object.assign({ duration: 600, ariaEnabled: true, collapse: true, showMultiple: false, onlyChildNodes: true, openOnInit: [], elementClass: "ac", triggerClass: "ac-trigger", panelClass: "ac-panel", activeClass: "is-active", beforeOpen: function() {
            }, onOpen: function() {
            }, beforeClose: function() {
            }, onClose: function() {
            } }, s);
            var e4 = typeof n2 == "string";
            this.container = e4 ? document.querySelector(n2) : n2, this.createDefinitions(), o.attachEvents();
          }, createDefinitions: function() {
            var e4 = this, n3 = this.options, s2 = n3.elementClass, i2 = n3.openOnInit, o2 = n3.onlyChildNodes ? this.container.childNodes : this.container.querySelectorAll(".".concat(s2));
            this.elements = Array.from(o2).filter(function(e5) {
              return e5.classList && e5.classList.contains(s2);
            }), this.firstElement = this.elements[0], this.lastElement = this.elements[this.elements.length - 1], this.elements.filter(function(e5) {
              return !e5.classList.contains("js-enabled");
            }).forEach(function(n4) {
              n4.classList.add("js-enabled"), e4.generateIDs(n4), e4.setARIA(n4), e4.setTransition(n4);
              var s3 = e4.elements.indexOf(n4);
              t++, i2.includes(s3) ? e4.showElement(n4, false) : e4.closeElement(n4, false);
            });
          }, setTransition: function(e4) {
            var t2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], n3 = this.options, s2 = n3.duration, i2 = n3.panelClass, o2 = e4.querySelector(".".concat(i2)), a2 = c("transitionDuration");
            o2.style[a2] = t2 ? null : "".concat(s2, "ms");
          }, generateIDs: function(e4) {
            var n3 = this.options, s2 = n3.triggerClass, i2 = n3.panelClass, o2 = e4.querySelector(".".concat(s2)), a2 = e4.querySelector(".".concat(i2));
            e4.setAttribute("id", "ac-".concat(t)), o2.setAttribute("id", "ac-trigger-".concat(t)), a2.setAttribute("id", "ac-panel-".concat(t));
          }, removeIDs: function(e4) {
            var t2 = this.options, n3 = t2.triggerClass, s2 = t2.panelClass, i2 = e4.querySelector(".".concat(n3)), o2 = e4.querySelector(".".concat(s2));
            e4.removeAttribute("id"), i2.removeAttribute("id"), o2.removeAttribute("id");
          }, setARIA: function(e4) {
            var n3 = this.options, s2 = n3.ariaEnabled, i2 = n3.triggerClass, o2 = n3.panelClass;
            if (s2) {
              var a2 = e4.querySelector(".".concat(i2)), r2 = e4.querySelector(".".concat(o2));
              a2.setAttribute("role", "button"), a2.setAttribute("aria-controls", "ac-panel-".concat(t)), a2.setAttribute("aria-disabled", false), a2.setAttribute("aria-expanded", false), r2.setAttribute("role", "region"), r2.setAttribute("aria-labelledby", "ac-trigger-".concat(t));
            }
          }, updateARIA: function(e4, t2) {
            var n3 = t2.ariaExpanded, s2 = t2.ariaDisabled, i2 = this.options, o2 = i2.ariaEnabled, a2 = i2.triggerClass;
            if (o2) {
              var r2 = e4.querySelector(".".concat(a2));
              r2.setAttribute("aria-expanded", n3), r2.setAttribute("aria-disabled", s2);
            }
          }, removeARIA: function(e4) {
            var t2 = this.options, n3 = t2.ariaEnabled, s2 = t2.triggerClass, i2 = t2.panelClass;
            if (n3) {
              var o2 = e4.querySelector(".".concat(s2)), a2 = e4.querySelector(".".concat(i2));
              o2.removeAttribute("role"), o2.removeAttribute("aria-controls"), o2.removeAttribute("aria-disabled"), o2.removeAttribute("aria-expanded"), a2.removeAttribute("role"), a2.removeAttribute("aria-labelledby");
            }
          }, focus: function(e4, t2) {
            e4.preventDefault();
            var n3 = this.options.triggerClass;
            t2.querySelector(".".concat(n3)).focus();
          }, focusFirstElement: function(e4) {
            this.focus(e4, this.firstElement), this.currFocusedIdx = 0;
          }, focusLastElement: function(e4) {
            this.focus(e4, this.lastElement), this.currFocusedIdx = this.elements.length - 1;
          }, focusNextElement: function(e4) {
            var t2 = this.currFocusedIdx + 1;
            if (t2 > this.elements.length - 1)
              return this.focusFirstElement(e4);
            this.focus(e4, this.elements[t2]), this.currFocusedIdx = t2;
          }, focusPrevElement: function(e4) {
            var t2 = this.currFocusedIdx - 1;
            if (t2 < 0)
              return this.focusLastElement(e4);
            this.focus(e4, this.elements[t2]), this.currFocusedIdx = t2;
          }, showElement: function(e4) {
            var t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], n3 = this.options, s2 = n3.panelClass, i2 = n3.activeClass, o2 = n3.collapse, a2 = n3.beforeOpen;
            t2 && a2(e4);
            var r2 = e4.querySelector(".".concat(s2)), c2 = r2.scrollHeight;
            e4.classList.add(i2), requestAnimationFrame(function() {
              requestAnimationFrame(function() {
                r2.style.height = t2 ? "".concat(c2, "px") : "auto";
              });
            }), this.updateARIA(e4, { ariaExpanded: true, ariaDisabled: !o2 });
          }, closeElement: function(e4) {
            var t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], n3 = this.options, s2 = n3.panelClass, i2 = n3.activeClass, o2 = n3.beforeClose, a2 = e4.querySelector(".".concat(s2)), r2 = a2.scrollHeight;
            e4.classList.remove(i2), t2 ? (o2(e4), requestAnimationFrame(function() {
              a2.style.height = "".concat(r2, "px"), requestAnimationFrame(function() {
                a2.style.height = 0;
              });
            })) : a2.style.height = 0, this.updateARIA(e4, { ariaExpanded: false, ariaDisabled: false });
          }, toggleElement: function(e4) {
            var t2 = this.options, n3 = t2.activeClass, s2 = t2.collapse, i2 = e4.classList.contains(n3);
            if (!i2 || s2)
              return i2 ? this.closeElement(e4) : this.showElement(e4);
          }, closeElements: function() {
            var e4 = this, t2 = this.options, n3 = t2.activeClass;
            t2.showMultiple || this.elements.forEach(function(t3, s2) {
              t3.classList.contains(n3) && s2 !== e4.currFocusedIdx && e4.closeElement(t3);
            });
          }, handleClick: function(e4) {
            var t2 = this, n3 = e4.currentTarget;
            this.elements.forEach(function(s2, i2) {
              s2.contains(n3) && e4.target.nodeName !== "A" && (t2.currFocusedIdx = i2, t2.closeElements(), t2.focus(e4, s2), t2.toggleElement(s2));
            });
          }, handleKeydown: function(e4) {
            var t2 = 38, n3 = 40, s2 = 36, i2 = 35;
            switch (e4.keyCode) {
              case t2:
                return this.focusPrevElement(e4);
              case n3:
                return this.focusNextElement(e4);
              case s2:
                return this.focusFirstElement(e4);
              case i2:
                return this.focusLastElement(e4);
              default:
                return null;
            }
          }, handleTransitionEnd: function(e4) {
            if (e4.propertyName === "height") {
              var t2 = this.options, n3 = t2.onOpen, s2 = t2.onClose, i2 = e4.currentTarget, o2 = parseInt(i2.style.height), a2 = this.elements.find(function(e5) {
                return e5.contains(i2);
              });
              o2 > 0 ? (i2.style.height = "auto", n3(a2)) : s2(a2);
            }
          } };
          this.attachEvents = function() {
            if (!a) {
              var e4 = r.options, t2 = e4.triggerClass, n3 = e4.panelClass;
              r.handleClick = r.handleClick.bind(r), r.handleKeydown = r.handleKeydown.bind(r), r.handleTransitionEnd = r.handleTransitionEnd.bind(r), r.elements.forEach(function(e5) {
                var s2 = e5.querySelector(".".concat(t2)), i2 = e5.querySelector(".".concat(n3));
                s2.addEventListener("click", r.handleClick), s2.addEventListener("keydown", r.handleKeydown), i2.addEventListener("webkitTransitionEnd", r.handleTransitionEnd), i2.addEventListener("transitionend", r.handleTransitionEnd);
              }), a = true;
            }
          }, this.detachEvents = function() {
            if (a) {
              var e4 = r.options, t2 = e4.triggerClass, n3 = e4.panelClass;
              r.elements.forEach(function(e5) {
                var s2 = e5.querySelector(".".concat(t2)), i2 = e5.querySelector(".".concat(n3));
                s2.removeEventListener("click", r.handleClick), s2.removeEventListener("keydown", r.handleKeydown), i2.removeEventListener("webkitTransitionEnd", r.handleTransitionEnd), i2.removeEventListener("transitionend", r.handleTransitionEnd);
              }), a = false;
            }
          }, this.toggle = function(e4) {
            var t2 = r.elements[e4];
            t2 && r.toggleElement(t2);
          }, this.open = function(e4) {
            var t2 = r.elements[e4];
            t2 && r.showElement(t2);
          }, this.openAll = function() {
            var e4 = r.options, t2 = e4.activeClass, n3 = e4.onOpen;
            r.elements.forEach(function(e5) {
              e5.classList.contains(t2) || (r.showElement(e5, false), n3(e5));
            });
          }, this.close = function(e4) {
            var t2 = r.elements[e4];
            t2 && r.closeElement(t2);
          }, this.closeAll = function() {
            var e4 = r.options, t2 = e4.activeClass, n3 = e4.onClose;
            r.elements.forEach(function(e5) {
              e5.classList.contains(t2) && (r.closeElement(e5, false), n3(e5));
            });
          }, this.destroy = function() {
            i.detachEvents(), i.openAll(), r.elements.forEach(function(e4) {
              r.removeIDs(e4), r.removeARIA(e4), r.setTransition(e4, true);
            }), a = true;
          }, this.update = function() {
            r.createDefinitions(), i.detachEvents(), i.attachEvents();
          };
          var c = function(e4) {
            return typeof document.documentElement.style[e4] == "string" ? e4 : (e4 = l(e4), e4 = "webkit".concat(e4));
          }, l = function(e4) {
            return e4.charAt(0).toUpperCase() + e4.slice(1);
          };
          r.init();
        };
        typeof module != "undefined" && module.exports !== void 0 ? module.exports = n : e2.Accordion = n;
      }(window);
    }
  });

  // node_modules/nouislider/dist/nouislider.js
  var require_nouislider = __commonJS({
    "node_modules/nouislider/dist/nouislider.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.noUiSlider = {}));
      })(exports, function(exports2) {
        "use strict";
        exports2.PipsMode = void 0;
        (function(PipsMode) {
          PipsMode["Range"] = "range";
          PipsMode["Steps"] = "steps";
          PipsMode["Positions"] = "positions";
          PipsMode["Count"] = "count";
          PipsMode["Values"] = "values";
        })(exports2.PipsMode || (exports2.PipsMode = {}));
        exports2.PipsType = void 0;
        (function(PipsType) {
          PipsType[PipsType["None"] = -1] = "None";
          PipsType[PipsType["NoValue"] = 0] = "NoValue";
          PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
          PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
        })(exports2.PipsType || (exports2.PipsType = {}));
        function isValidFormatter(entry) {
          return isValidPartialFormatter(entry) && typeof entry.from === "function";
        }
        function isValidPartialFormatter(entry) {
          return typeof entry === "object" && typeof entry.to === "function";
        }
        function removeElement(el) {
          el.parentElement.removeChild(el);
        }
        function isSet(value2) {
          return value2 !== null && value2 !== void 0;
        }
        function preventDefault3(e2) {
          e2.preventDefault();
        }
        function unique(array) {
          return array.filter(function(a) {
            return !this[a] ? this[a] = true : false;
          }, {});
        }
        function closest2(value2, to) {
          return Math.round(value2 / to) * to;
        }
        function offset2(elem, orientation) {
          var rect = elem.getBoundingClientRect();
          var doc = elem.ownerDocument;
          var docElem = doc.documentElement;
          var pageOffset = getPageOffset(doc);
          if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
            pageOffset.x = 0;
          }
          return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
        }
        function isNumeric(a) {
          return typeof a === "number" && !isNaN(a) && isFinite(a);
        }
        function addClassFor(element, className, duration) {
          if (duration > 0) {
            addClass2(element, className);
            setTimeout(function() {
              removeClass2(element, className);
            }, duration);
          }
        }
        function limit(a) {
          return Math.max(Math.min(a, 100), 0);
        }
        function asArray(a) {
          return Array.isArray(a) ? a : [a];
        }
        function countDecimals(numStr) {
          numStr = String(numStr);
          var pieces = numStr.split(".");
          return pieces.length > 1 ? pieces[1].length : 0;
        }
        function addClass2(el, className) {
          if (el.classList && !/\s/.test(className)) {
            el.classList.add(className);
          } else {
            el.className += " " + className;
          }
        }
        function removeClass2(el, className) {
          if (el.classList && !/\s/.test(className)) {
            el.classList.remove(className);
          } else {
            el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
          }
        }
        function hasClass2(el, className) {
          return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
        }
        function getPageOffset(doc) {
          var supportPageOffset = window.pageXOffset !== void 0;
          var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
          var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
          var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
          return {
            x,
            y
          };
        }
        function getActions() {
          return window.navigator.pointerEnabled ? {
            start: "pointerdown",
            move: "pointermove",
            end: "pointerup"
          } : window.navigator.msPointerEnabled ? {
            start: "MSPointerDown",
            move: "MSPointerMove",
            end: "MSPointerUp"
          } : {
            start: "mousedown touchstart",
            move: "mousemove touchmove",
            end: "mouseup touchend"
          };
        }
        function getSupportsPassive() {
          var supportsPassive = false;
          try {
            var opts = Object.defineProperty({}, "passive", {
              get: function() {
                supportsPassive = true;
              }
            });
            window.addEventListener("test", null, opts);
          } catch (e2) {
          }
          return supportsPassive;
        }
        function getSupportsTouchActionNone() {
          return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
        }
        function subRangeRatio(pa, pb) {
          return 100 / (pb - pa);
        }
        function fromPercentage(range, value2, startRange) {
          return value2 * 100 / (range[startRange + 1] - range[startRange]);
        }
        function toPercentage(range, value2) {
          return fromPercentage(range, range[0] < 0 ? value2 + Math.abs(range[0]) : value2 - range[0], 0);
        }
        function isPercentage(range, value2) {
          return value2 * (range[1] - range[0]) / 100 + range[0];
        }
        function getJ(value2, arr) {
          var j = 1;
          while (value2 >= arr[j]) {
            j += 1;
          }
          return j;
        }
        function toStepping(xVal, xPct, value2) {
          if (value2 >= xVal.slice(-1)[0]) {
            return 100;
          }
          var j = getJ(value2, xVal);
          var va = xVal[j - 1];
          var vb = xVal[j];
          var pa = xPct[j - 1];
          var pb = xPct[j];
          return pa + toPercentage([va, vb], value2) / subRangeRatio(pa, pb);
        }
        function fromStepping(xVal, xPct, value2) {
          if (value2 >= 100) {
            return xVal.slice(-1)[0];
          }
          var j = getJ(value2, xPct);
          var va = xVal[j - 1];
          var vb = xVal[j];
          var pa = xPct[j - 1];
          var pb = xPct[j];
          return isPercentage([va, vb], (value2 - pa) * subRangeRatio(pa, pb));
        }
        function getStep(xPct, xSteps, snap, value2) {
          if (value2 === 100) {
            return value2;
          }
          var j = getJ(value2, xPct);
          var a = xPct[j - 1];
          var b = xPct[j];
          if (snap) {
            if (value2 - a > (b - a) / 2) {
              return b;
            }
            return a;
          }
          if (!xSteps[j - 1]) {
            return value2;
          }
          return xPct[j - 1] + closest2(value2 - xPct[j - 1], xSteps[j - 1]);
        }
        var Spectrum = function() {
          function Spectrum2(entry, snap, singleStep) {
            this.xPct = [];
            this.xVal = [];
            this.xSteps = [];
            this.xNumSteps = [];
            this.xHighestCompleteStep = [];
            this.xSteps = [singleStep || false];
            this.xNumSteps = [false];
            this.snap = snap;
            var index2;
            var ordered = [];
            Object.keys(entry).forEach(function(index3) {
              ordered.push([asArray(entry[index3]), index3]);
            });
            ordered.sort(function(a, b) {
              return a[0][0] - b[0][0];
            });
            for (index2 = 0; index2 < ordered.length; index2++) {
              this.handleEntryPoint(ordered[index2][1], ordered[index2][0]);
            }
            this.xNumSteps = this.xSteps.slice(0);
            for (index2 = 0; index2 < this.xNumSteps.length; index2++) {
              this.handleStepPoint(index2, this.xNumSteps[index2]);
            }
          }
          Spectrum2.prototype.getDistance = function(value2) {
            var distances = [];
            for (var index2 = 0; index2 < this.xNumSteps.length - 1; index2++) {
              distances[index2] = fromPercentage(this.xVal, value2, index2);
            }
            return distances;
          };
          Spectrum2.prototype.getAbsoluteDistance = function(value2, distances, direction) {
            var xPct_index = 0;
            if (value2 < this.xPct[this.xPct.length - 1]) {
              while (value2 > this.xPct[xPct_index + 1]) {
                xPct_index++;
              }
            } else if (value2 === this.xPct[this.xPct.length - 1]) {
              xPct_index = this.xPct.length - 2;
            }
            if (!direction && value2 === this.xPct[xPct_index + 1]) {
              xPct_index++;
            }
            if (distances === null) {
              distances = [];
            }
            var start_factor;
            var rest_factor = 1;
            var rest_rel_distance = distances[xPct_index];
            var range_pct = 0;
            var rel_range_distance = 0;
            var abs_distance_counter = 0;
            var range_counter = 0;
            if (direction) {
              start_factor = (value2 - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            } else {
              start_factor = (this.xPct[xPct_index + 1] - value2) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            }
            while (rest_rel_distance > 0) {
              range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
              if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                rel_range_distance = range_pct * start_factor;
                rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                start_factor = 1;
              } else {
                rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor;
                rest_factor = 0;
              }
              if (direction) {
                abs_distance_counter = abs_distance_counter - rel_range_distance;
                if (this.xPct.length + range_counter >= 1) {
                  range_counter--;
                }
              } else {
                abs_distance_counter = abs_distance_counter + rel_range_distance;
                if (this.xPct.length - range_counter >= 1) {
                  range_counter++;
                }
              }
              rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
            }
            return value2 + abs_distance_counter;
          };
          Spectrum2.prototype.toStepping = function(value2) {
            value2 = toStepping(this.xVal, this.xPct, value2);
            return value2;
          };
          Spectrum2.prototype.fromStepping = function(value2) {
            return fromStepping(this.xVal, this.xPct, value2);
          };
          Spectrum2.prototype.getStep = function(value2) {
            value2 = getStep(this.xPct, this.xSteps, this.snap, value2);
            return value2;
          };
          Spectrum2.prototype.getDefaultStep = function(value2, isDown, size) {
            var j = getJ(value2, this.xPct);
            if (value2 === 100 || isDown && value2 === this.xPct[j - 1]) {
              j = Math.max(j - 1, 1);
            }
            return (this.xVal[j] - this.xVal[j - 1]) / size;
          };
          Spectrum2.prototype.getNearbySteps = function(value2) {
            var j = getJ(value2, this.xPct);
            return {
              stepBefore: {
                startValue: this.xVal[j - 2],
                step: this.xNumSteps[j - 2],
                highestStep: this.xHighestCompleteStep[j - 2]
              },
              thisStep: {
                startValue: this.xVal[j - 1],
                step: this.xNumSteps[j - 1],
                highestStep: this.xHighestCompleteStep[j - 1]
              },
              stepAfter: {
                startValue: this.xVal[j],
                step: this.xNumSteps[j],
                highestStep: this.xHighestCompleteStep[j]
              }
            };
          };
          Spectrum2.prototype.countStepDecimals = function() {
            var stepDecimals = this.xNumSteps.map(countDecimals);
            return Math.max.apply(null, stepDecimals);
          };
          Spectrum2.prototype.hasNoSize = function() {
            return this.xVal[0] === this.xVal[this.xVal.length - 1];
          };
          Spectrum2.prototype.convert = function(value2) {
            return this.getStep(this.toStepping(value2));
          };
          Spectrum2.prototype.handleEntryPoint = function(index2, value2) {
            var percentage;
            if (index2 === "min") {
              percentage = 0;
            } else if (index2 === "max") {
              percentage = 100;
            } else {
              percentage = parseFloat(index2);
            }
            if (!isNumeric(percentage) || !isNumeric(value2[0])) {
              throw new Error("noUiSlider: 'range' value isn't numeric.");
            }
            this.xPct.push(percentage);
            this.xVal.push(value2[0]);
            var value1 = Number(value2[1]);
            if (!percentage) {
              if (!isNaN(value1)) {
                this.xSteps[0] = value1;
              }
            } else {
              this.xSteps.push(isNaN(value1) ? false : value1);
            }
            this.xHighestCompleteStep.push(0);
          };
          Spectrum2.prototype.handleStepPoint = function(i, n) {
            if (!n) {
              return;
            }
            if (this.xVal[i] === this.xVal[i + 1]) {
              this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];
              return;
            }
            this.xSteps[i] = fromPercentage([this.xVal[i], this.xVal[i + 1]], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);
            var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];
            var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
            var step = this.xVal[i] + this.xNumSteps[i] * highestStep;
            this.xHighestCompleteStep[i] = step;
          };
          return Spectrum2;
        }();
        var defaultFormatter = {
          to: function(value2) {
            return value2 === void 0 ? "" : value2.toFixed(2);
          },
          from: Number
        };
        var cssClasses = {
          target: "target",
          base: "base",
          origin: "origin",
          handle: "handle",
          handleLower: "handle-lower",
          handleUpper: "handle-upper",
          touchArea: "touch-area",
          horizontal: "horizontal",
          vertical: "vertical",
          background: "background",
          connect: "connect",
          connects: "connects",
          ltr: "ltr",
          rtl: "rtl",
          textDirectionLtr: "txt-dir-ltr",
          textDirectionRtl: "txt-dir-rtl",
          draggable: "draggable",
          drag: "state-drag",
          tap: "state-tap",
          active: "active",
          tooltip: "tooltip",
          pips: "pips",
          pipsHorizontal: "pips-horizontal",
          pipsVertical: "pips-vertical",
          marker: "marker",
          markerHorizontal: "marker-horizontal",
          markerVertical: "marker-vertical",
          markerNormal: "marker-normal",
          markerLarge: "marker-large",
          markerSub: "marker-sub",
          value: "value",
          valueHorizontal: "value-horizontal",
          valueVertical: "value-vertical",
          valueNormal: "value-normal",
          valueLarge: "value-large",
          valueSub: "value-sub"
        };
        var INTERNAL_EVENT_NS = {
          tooltips: ".__tooltips",
          aria: ".__aria"
        };
        function testStep(parsed, entry) {
          if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'step' is not numeric.");
          }
          parsed.singleStep = entry;
        }
        function testKeyboardPageMultiplier(parsed, entry) {
          if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
          }
          parsed.keyboardPageMultiplier = entry;
        }
        function testKeyboardMultiplier(parsed, entry) {
          if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
          }
          parsed.keyboardMultiplier = entry;
        }
        function testKeyboardDefaultStep(parsed, entry) {
          if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
          }
          parsed.keyboardDefaultStep = entry;
        }
        function testRange(parsed, entry) {
          if (typeof entry !== "object" || Array.isArray(entry)) {
            throw new Error("noUiSlider: 'range' is not an object.");
          }
          if (entry.min === void 0 || entry.max === void 0) {
            throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
          }
          parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
        }
        function testStart(parsed, entry) {
          entry = asArray(entry);
          if (!Array.isArray(entry) || !entry.length) {
            throw new Error("noUiSlider: 'start' option is incorrect.");
          }
          parsed.handles = entry.length;
          parsed.start = entry;
        }
        function testSnap(parsed, entry) {
          if (typeof entry !== "boolean") {
            throw new Error("noUiSlider: 'snap' option must be a boolean.");
          }
          parsed.snap = entry;
        }
        function testAnimate(parsed, entry) {
          if (typeof entry !== "boolean") {
            throw new Error("noUiSlider: 'animate' option must be a boolean.");
          }
          parsed.animate = entry;
        }
        function testAnimationDuration(parsed, entry) {
          if (typeof entry !== "number") {
            throw new Error("noUiSlider: 'animationDuration' option must be a number.");
          }
          parsed.animationDuration = entry;
        }
        function testConnect(parsed, entry) {
          var connect = [false];
          var i;
          if (entry === "lower") {
            entry = [true, false];
          } else if (entry === "upper") {
            entry = [false, true];
          }
          if (entry === true || entry === false) {
            for (i = 1; i < parsed.handles; i++) {
              connect.push(entry);
            }
            connect.push(false);
          } else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
            throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
          } else {
            connect = entry;
          }
          parsed.connect = connect;
        }
        function testOrientation(parsed, entry) {
          switch (entry) {
            case "horizontal":
              parsed.ort = 0;
              break;
            case "vertical":
              parsed.ort = 1;
              break;
            default:
              throw new Error("noUiSlider: 'orientation' option is invalid.");
          }
        }
        function testMargin(parsed, entry) {
          if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'margin' option must be numeric.");
          }
          if (entry === 0) {
            return;
          }
          parsed.margin = parsed.spectrum.getDistance(entry);
        }
        function testLimit(parsed, entry) {
          if (!isNumeric(entry)) {
            throw new Error("noUiSlider: 'limit' option must be numeric.");
          }
          parsed.limit = parsed.spectrum.getDistance(entry);
          if (!parsed.limit || parsed.handles < 2) {
            throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
          }
        }
        function testPadding(parsed, entry) {
          var index2;
          if (!isNumeric(entry) && !Array.isArray(entry)) {
            throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
          }
          if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
            throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
          }
          if (entry === 0) {
            return;
          }
          if (!Array.isArray(entry)) {
            entry = [entry, entry];
          }
          parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];
          for (index2 = 0; index2 < parsed.spectrum.xNumSteps.length - 1; index2++) {
            if (parsed.padding[0][index2] < 0 || parsed.padding[1][index2] < 0) {
              throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
            }
          }
          var totalPadding = entry[0] + entry[1];
          var firstValue = parsed.spectrum.xVal[0];
          var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
          if (totalPadding / (lastValue - firstValue) > 1) {
            throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
          }
        }
        function testDirection(parsed, entry) {
          switch (entry) {
            case "ltr":
              parsed.dir = 0;
              break;
            case "rtl":
              parsed.dir = 1;
              break;
            default:
              throw new Error("noUiSlider: 'direction' option was not recognized.");
          }
        }
        function testBehaviour(parsed, entry) {
          if (typeof entry !== "string") {
            throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
          }
          var tap = entry.indexOf("tap") >= 0;
          var drag = entry.indexOf("drag") >= 0;
          var fixed = entry.indexOf("fixed") >= 0;
          var snap = entry.indexOf("snap") >= 0;
          var hover = entry.indexOf("hover") >= 0;
          var unconstrained = entry.indexOf("unconstrained") >= 0;
          var dragAll = entry.indexOf("drag-all") >= 0;
          var smoothSteps = entry.indexOf("smooth-steps") >= 0;
          if (fixed) {
            if (parsed.handles !== 2) {
              throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
            }
            testMargin(parsed, parsed.start[1] - parsed.start[0]);
          }
          if (unconstrained && (parsed.margin || parsed.limit)) {
            throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
          }
          parsed.events = {
            tap: tap || snap,
            drag,
            dragAll,
            smoothSteps,
            fixed,
            snap,
            hover,
            unconstrained
          };
        }
        function testTooltips(parsed, entry) {
          if (entry === false) {
            return;
          }
          if (entry === true || isValidPartialFormatter(entry)) {
            parsed.tooltips = [];
            for (var i = 0; i < parsed.handles; i++) {
              parsed.tooltips.push(entry);
            }
          } else {
            entry = asArray(entry);
            if (entry.length !== parsed.handles) {
              throw new Error("noUiSlider: must pass a formatter for all handles.");
            }
            entry.forEach(function(formatter) {
              if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
                throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
              }
            });
            parsed.tooltips = entry;
          }
        }
        function testHandleAttributes(parsed, entry) {
          if (entry.length !== parsed.handles) {
            throw new Error("noUiSlider: must pass a attributes for all handles.");
          }
          parsed.handleAttributes = entry;
        }
        function testAriaFormat(parsed, entry) {
          if (!isValidPartialFormatter(entry)) {
            throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
          }
          parsed.ariaFormat = entry;
        }
        function testFormat(parsed, entry) {
          if (!isValidFormatter(entry)) {
            throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
          }
          parsed.format = entry;
        }
        function testKeyboardSupport(parsed, entry) {
          if (typeof entry !== "boolean") {
            throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
          }
          parsed.keyboardSupport = entry;
        }
        function testDocumentElement(parsed, entry) {
          parsed.documentElement = entry;
        }
        function testCssPrefix(parsed, entry) {
          if (typeof entry !== "string" && entry !== false) {
            throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
          }
          parsed.cssPrefix = entry;
        }
        function testCssClasses(parsed, entry) {
          if (typeof entry !== "object") {
            throw new Error("noUiSlider: 'cssClasses' must be an object.");
          }
          if (typeof parsed.cssPrefix === "string") {
            parsed.cssClasses = {};
            Object.keys(entry).forEach(function(key) {
              parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
            });
          } else {
            parsed.cssClasses = entry;
          }
        }
        function testOptions(options) {
          var parsed = {
            margin: null,
            limit: null,
            padding: null,
            animate: true,
            animationDuration: 300,
            ariaFormat: defaultFormatter,
            format: defaultFormatter
          };
          var tests = {
            step: { r: false, t: testStep },
            keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
            keyboardMultiplier: { r: false, t: testKeyboardMultiplier },
            keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
            start: { r: true, t: testStart },
            connect: { r: true, t: testConnect },
            direction: { r: true, t: testDirection },
            snap: { r: false, t: testSnap },
            animate: { r: false, t: testAnimate },
            animationDuration: { r: false, t: testAnimationDuration },
            range: { r: true, t: testRange },
            orientation: { r: false, t: testOrientation },
            margin: { r: false, t: testMargin },
            limit: { r: false, t: testLimit },
            padding: { r: false, t: testPadding },
            behaviour: { r: true, t: testBehaviour },
            ariaFormat: { r: false, t: testAriaFormat },
            format: { r: false, t: testFormat },
            tooltips: { r: false, t: testTooltips },
            keyboardSupport: { r: true, t: testKeyboardSupport },
            documentElement: { r: false, t: testDocumentElement },
            cssPrefix: { r: true, t: testCssPrefix },
            cssClasses: { r: true, t: testCssClasses },
            handleAttributes: { r: false, t: testHandleAttributes }
          };
          var defaults = {
            connect: false,
            direction: "ltr",
            behaviour: "tap",
            orientation: "horizontal",
            keyboardSupport: true,
            cssPrefix: "noUi-",
            cssClasses,
            keyboardPageMultiplier: 5,
            keyboardMultiplier: 1,
            keyboardDefaultStep: 10
          };
          if (options.format && !options.ariaFormat) {
            options.ariaFormat = options.format;
          }
          Object.keys(tests).forEach(function(name) {
            if (!isSet(options[name]) && defaults[name] === void 0) {
              if (tests[name].r) {
                throw new Error("noUiSlider: '" + name + "' is required.");
              }
              return;
            }
            tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
          });
          parsed.pips = options.pips;
          var d = document.createElement("div");
          var msPrefix = d.style.msTransform !== void 0;
          var noPrefix = d.style.transform !== void 0;
          parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
          var styles2 = [
            ["left", "top"],
            ["right", "bottom"]
          ];
          parsed.style = styles2[parsed.dir][parsed.ort];
          return parsed;
        }
        function scope(target, options, originalOptions) {
          var actions = getActions();
          var supportsTouchActionNone = getSupportsTouchActionNone();
          var supportsPassive = supportsTouchActionNone && getSupportsPassive();
          var scope_Target = target;
          var scope_Base;
          var scope_Handles;
          var scope_Connects;
          var scope_Pips;
          var scope_Tooltips;
          var scope_Spectrum = options.spectrum;
          var scope_Values = [];
          var scope_Locations = [];
          var scope_HandleNumbers = [];
          var scope_ActiveHandlesCount = 0;
          var scope_Events = {};
          var scope_Document = target.ownerDocument;
          var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
          var scope_Body = scope_Document.body;
          var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
          function addNodeTo(addTarget, className) {
            var div2 = scope_Document.createElement("div");
            if (className) {
              addClass2(div2, className);
            }
            addTarget.appendChild(div2);
            return div2;
          }
          function addOrigin(base, handleNumber) {
            var origin = addNodeTo(base, options.cssClasses.origin);
            var handle = addNodeTo(origin, options.cssClasses.handle);
            addNodeTo(handle, options.cssClasses.touchArea);
            handle.setAttribute("data-handle", String(handleNumber));
            if (options.keyboardSupport) {
              handle.setAttribute("tabindex", "0");
              handle.addEventListener("keydown", function(event2) {
                return eventKeydown(event2, handleNumber);
              });
            }
            if (options.handleAttributes !== void 0) {
              var attributes_1 = options.handleAttributes[handleNumber];
              Object.keys(attributes_1).forEach(function(attribute) {
                handle.setAttribute(attribute, attributes_1[attribute]);
              });
            }
            handle.setAttribute("role", "slider");
            handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
            if (handleNumber === 0) {
              addClass2(handle, options.cssClasses.handleLower);
            } else if (handleNumber === options.handles - 1) {
              addClass2(handle, options.cssClasses.handleUpper);
            }
            return origin;
          }
          function addConnect(base, add) {
            if (!add) {
              return false;
            }
            return addNodeTo(base, options.cssClasses.connect);
          }
          function addElements(connectOptions, base) {
            var connectBase = addNodeTo(base, options.cssClasses.connects);
            scope_Handles = [];
            scope_Connects = [];
            scope_Connects.push(addConnect(connectBase, connectOptions[0]));
            for (var i = 0; i < options.handles; i++) {
              scope_Handles.push(addOrigin(base, i));
              scope_HandleNumbers[i] = i;
              scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
            }
          }
          function addSlider(addTarget) {
            addClass2(addTarget, options.cssClasses.target);
            if (options.dir === 0) {
              addClass2(addTarget, options.cssClasses.ltr);
            } else {
              addClass2(addTarget, options.cssClasses.rtl);
            }
            if (options.ort === 0) {
              addClass2(addTarget, options.cssClasses.horizontal);
            } else {
              addClass2(addTarget, options.cssClasses.vertical);
            }
            var textDirection = getComputedStyle(addTarget).direction;
            if (textDirection === "rtl") {
              addClass2(addTarget, options.cssClasses.textDirectionRtl);
            } else {
              addClass2(addTarget, options.cssClasses.textDirectionLtr);
            }
            return addNodeTo(addTarget, options.cssClasses.base);
          }
          function addTooltip(handle, handleNumber) {
            if (!options.tooltips || !options.tooltips[handleNumber]) {
              return false;
            }
            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
          }
          function isSliderDisabled() {
            return scope_Target.hasAttribute("disabled");
          }
          function isHandleDisabled(handleNumber) {
            var handleOrigin = scope_Handles[handleNumber];
            return handleOrigin.hasAttribute("disabled");
          }
          function removeTooltips() {
            if (scope_Tooltips) {
              removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
              scope_Tooltips.forEach(function(tooltip) {
                if (tooltip) {
                  removeElement(tooltip);
                }
              });
              scope_Tooltips = null;
            }
          }
          function tooltips() {
            removeTooltips();
            scope_Tooltips = scope_Handles.map(addTooltip);
            bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function(values, handleNumber, unencoded) {
              if (!scope_Tooltips || !options.tooltips) {
                return;
              }
              if (scope_Tooltips[handleNumber] === false) {
                return;
              }
              var formattedValue = values[handleNumber];
              if (options.tooltips[handleNumber] !== true) {
                formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
              }
              scope_Tooltips[handleNumber].innerHTML = formattedValue;
            });
          }
          function aria() {
            removeEvent("update" + INTERNAL_EVENT_NS.aria);
            bindEvent("update" + INTERNAL_EVENT_NS.aria, function(values, handleNumber, unencoded, tap, positions) {
              scope_HandleNumbers.forEach(function(index2) {
                var handle = scope_Handles[index2];
                var min = checkHandlePosition(scope_Locations, index2, 0, true, true, true);
                var max = checkHandlePosition(scope_Locations, index2, 100, true, true, true);
                var now2 = positions[index2];
                var text2 = String(options.ariaFormat.to(unencoded[index2]));
                min = scope_Spectrum.fromStepping(min).toFixed(1);
                max = scope_Spectrum.fromStepping(max).toFixed(1);
                now2 = scope_Spectrum.fromStepping(now2).toFixed(1);
                handle.children[0].setAttribute("aria-valuemin", min);
                handle.children[0].setAttribute("aria-valuemax", max);
                handle.children[0].setAttribute("aria-valuenow", now2);
                handle.children[0].setAttribute("aria-valuetext", text2);
              });
            });
          }
          function getGroup(pips2) {
            if (pips2.mode === exports2.PipsMode.Range || pips2.mode === exports2.PipsMode.Steps) {
              return scope_Spectrum.xVal;
            }
            if (pips2.mode === exports2.PipsMode.Count) {
              if (pips2.values < 2) {
                throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
              }
              var interval = pips2.values - 1;
              var spread = 100 / interval;
              var values = [];
              while (interval--) {
                values[interval] = interval * spread;
              }
              values.push(100);
              return mapToRange(values, pips2.stepped);
            }
            if (pips2.mode === exports2.PipsMode.Positions) {
              return mapToRange(pips2.values, pips2.stepped);
            }
            if (pips2.mode === exports2.PipsMode.Values) {
              if (pips2.stepped) {
                return pips2.values.map(function(value2) {
                  return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value2)));
                });
              }
              return pips2.values;
            }
            return [];
          }
          function mapToRange(values, stepped) {
            return values.map(function(value2) {
              return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value2) : value2);
            });
          }
          function generateSpread(pips2) {
            function safeIncrement(value2, increment) {
              return Number((value2 + increment).toFixed(7));
            }
            var group = getGroup(pips2);
            var indexes = {};
            var firstInRange = scope_Spectrum.xVal[0];
            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
            var ignoreFirst = false;
            var ignoreLast = false;
            var prevPct = 0;
            group = unique(group.slice().sort(function(a, b) {
              return a - b;
            }));
            if (group[0] !== firstInRange) {
              group.unshift(firstInRange);
              ignoreFirst = true;
            }
            if (group[group.length - 1] !== lastInRange) {
              group.push(lastInRange);
              ignoreLast = true;
            }
            group.forEach(function(current, index2) {
              var step;
              var i;
              var q;
              var low = current;
              var high = group[index2 + 1];
              var newPct;
              var pctDifference;
              var pctPos;
              var type;
              var steps;
              var realSteps;
              var stepSize;
              var isSteps = pips2.mode === exports2.PipsMode.Steps;
              if (isSteps) {
                step = scope_Spectrum.xNumSteps[index2];
              }
              if (!step) {
                step = high - low;
              }
              if (high === void 0) {
                high = low;
              }
              step = Math.max(step, 1e-7);
              for (i = low; i <= high; i = safeIncrement(i, step)) {
                newPct = scope_Spectrum.toStepping(i);
                pctDifference = newPct - prevPct;
                steps = pctDifference / (pips2.density || 1);
                realSteps = Math.round(steps);
                stepSize = pctDifference / realSteps;
                for (q = 1; q <= realSteps; q += 1) {
                  pctPos = prevPct + q * stepSize;
                  indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
                }
                type = group.indexOf(i) > -1 ? exports2.PipsType.LargeValue : isSteps ? exports2.PipsType.SmallValue : exports2.PipsType.NoValue;
                if (!index2 && ignoreFirst && i !== high) {
                  type = 0;
                }
                if (!(i === high && ignoreLast)) {
                  indexes[newPct.toFixed(5)] = [i, type];
                }
                prevPct = newPct;
              }
            });
            return indexes;
          }
          function addMarking(spread, filterFunc, formatter) {
            var _a, _b;
            var element = scope_Document.createElement("div");
            var valueSizeClasses = (_a = {}, _a[exports2.PipsType.None] = "", _a[exports2.PipsType.NoValue] = options.cssClasses.valueNormal, _a[exports2.PipsType.LargeValue] = options.cssClasses.valueLarge, _a[exports2.PipsType.SmallValue] = options.cssClasses.valueSub, _a);
            var markerSizeClasses = (_b = {}, _b[exports2.PipsType.None] = "", _b[exports2.PipsType.NoValue] = options.cssClasses.markerNormal, _b[exports2.PipsType.LargeValue] = options.cssClasses.markerLarge, _b[exports2.PipsType.SmallValue] = options.cssClasses.markerSub, _b);
            var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
            var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
            addClass2(element, options.cssClasses.pips);
            addClass2(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
            function getClasses(type, source) {
              var a = source === options.cssClasses.value;
              var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
              var sizeClasses = a ? valueSizeClasses : markerSizeClasses;
              return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
            }
            function addSpread(offset3, value2, type) {
              type = filterFunc ? filterFunc(value2, type) : type;
              if (type === exports2.PipsType.None) {
                return;
              }
              var node = addNodeTo(element, false);
              node.className = getClasses(type, options.cssClasses.marker);
              node.style[options.style] = offset3 + "%";
              if (type > exports2.PipsType.NoValue) {
                node = addNodeTo(element, false);
                node.className = getClasses(type, options.cssClasses.value);
                node.setAttribute("data-value", String(value2));
                node.style[options.style] = offset3 + "%";
                node.innerHTML = String(formatter.to(value2));
              }
            }
            Object.keys(spread).forEach(function(offset3) {
              addSpread(offset3, spread[offset3][0], spread[offset3][1]);
            });
            return element;
          }
          function removePips() {
            if (scope_Pips) {
              removeElement(scope_Pips);
              scope_Pips = null;
            }
          }
          function pips(pips2) {
            removePips();
            var spread = generateSpread(pips2);
            var filter2 = pips2.filter;
            var format = pips2.format || {
              to: function(value2) {
                return String(Math.round(value2));
              }
            };
            scope_Pips = scope_Target.appendChild(addMarking(spread, filter2, format));
            return scope_Pips;
          }
          function baseSize() {
            var rect = scope_Base.getBoundingClientRect();
            var alt = "offset" + ["Width", "Height"][options.ort];
            return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
          }
          function attachEvent(events2, element, callback, data) {
            var method = function(event2) {
              var e2 = fixEvent(event2, data.pageOffset, data.target || element);
              if (!e2) {
                return false;
              }
              if (isSliderDisabled() && !data.doNotReject) {
                return false;
              }
              if (hasClass2(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
                return false;
              }
              if (events2 === actions.start && e2.buttons !== void 0 && e2.buttons > 1) {
                return false;
              }
              if (data.hover && e2.buttons) {
                return false;
              }
              if (!supportsPassive) {
                e2.preventDefault();
              }
              e2.calcPoint = e2.points[options.ort];
              callback(e2, data);
              return;
            };
            var methods = [];
            events2.split(" ").forEach(function(eventName) {
              element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
              methods.push([eventName, method]);
            });
            return methods;
          }
          function fixEvent(e2, pageOffset, eventTarget) {
            var touch2 = e2.type.indexOf("touch") === 0;
            var mouse = e2.type.indexOf("mouse") === 0;
            var pointer = e2.type.indexOf("pointer") === 0;
            var x = 0;
            var y = 0;
            if (e2.type.indexOf("MSPointer") === 0) {
              pointer = true;
            }
            if (e2.type === "mousedown" && !e2.buttons && !e2.touches) {
              return false;
            }
            if (touch2) {
              var isTouchOnTarget = function(checkTouch) {
                var target2 = checkTouch.target;
                return target2 === eventTarget || eventTarget.contains(target2) || e2.composed && e2.composedPath().shift() === eventTarget;
              };
              if (e2.type === "touchstart") {
                var targetTouches = Array.prototype.filter.call(e2.touches, isTouchOnTarget);
                if (targetTouches.length > 1) {
                  return false;
                }
                x = targetTouches[0].pageX;
                y = targetTouches[0].pageY;
              } else {
                var targetTouch = Array.prototype.find.call(e2.changedTouches, isTouchOnTarget);
                if (!targetTouch) {
                  return false;
                }
                x = targetTouch.pageX;
                y = targetTouch.pageY;
              }
            }
            pageOffset = pageOffset || getPageOffset(scope_Document);
            if (mouse || pointer) {
              x = e2.clientX + pageOffset.x;
              y = e2.clientY + pageOffset.y;
            }
            e2.pageOffset = pageOffset;
            e2.points = [x, y];
            e2.cursor = mouse || pointer;
            return e2;
          }
          function calcPointToPercentage(calcPoint) {
            var location2 = calcPoint - offset2(scope_Base, options.ort);
            var proposal = location2 * 100 / baseSize();
            proposal = limit(proposal);
            return options.dir ? 100 - proposal : proposal;
          }
          function getClosestHandle(clickedPosition) {
            var smallestDifference = 100;
            var handleNumber = false;
            scope_Handles.forEach(function(handle, index2) {
              if (isHandleDisabled(index2)) {
                return;
              }
              var handlePosition = scope_Locations[index2];
              var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
              var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
              var isCloser = differenceWithThisHandle < smallestDifference;
              var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
              if (isCloser || isCloserAfter || clickAtEdge) {
                handleNumber = index2;
                smallestDifference = differenceWithThisHandle;
              }
            });
            return handleNumber;
          }
          function documentLeave(event2, data) {
            if (event2.type === "mouseout" && event2.target.nodeName === "HTML" && event2.relatedTarget === null) {
              eventEnd(event2, data);
            }
          }
          function eventMove(event2, data) {
            if (navigator.appVersion.indexOf("MSIE 9") === -1 && event2.buttons === 0 && data.buttonsProperty !== 0) {
              return eventEnd(event2, data);
            }
            var movement = (options.dir ? -1 : 1) * (event2.calcPoint - data.startCalcPoint);
            var proposal = movement * 100 / data.baseSize;
            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
          }
          function eventEnd(event2, data) {
            if (data.handle) {
              removeClass2(data.handle, options.cssClasses.active);
              scope_ActiveHandlesCount -= 1;
            }
            data.listeners.forEach(function(c) {
              scope_DocumentElement.removeEventListener(c[0], c[1]);
            });
            if (scope_ActiveHandlesCount === 0) {
              removeClass2(scope_Target, options.cssClasses.drag);
              setZindex();
              if (event2.cursor) {
                scope_Body.style.cursor = "";
                scope_Body.removeEventListener("selectstart", preventDefault3);
              }
            }
            if (options.events.smoothSteps) {
              data.handleNumbers.forEach(function(handleNumber) {
                setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);
              });
              data.handleNumbers.forEach(function(handleNumber) {
                fireEvent("update", handleNumber);
              });
            }
            data.handleNumbers.forEach(function(handleNumber) {
              fireEvent("change", handleNumber);
              fireEvent("set", handleNumber);
              fireEvent("end", handleNumber);
            });
          }
          function eventStart(event2, data) {
            if (data.handleNumbers.some(isHandleDisabled)) {
              return;
            }
            var handle;
            if (data.handleNumbers.length === 1) {
              var handleOrigin = scope_Handles[data.handleNumbers[0]];
              handle = handleOrigin.children[0];
              scope_ActiveHandlesCount += 1;
              addClass2(handle, options.cssClasses.active);
            }
            event2.stopPropagation();
            var listeners2 = [];
            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
              target: event2.target,
              handle,
              connect: data.connect,
              listeners: listeners2,
              startCalcPoint: event2.calcPoint,
              baseSize: baseSize(),
              pageOffset: event2.pageOffset,
              handleNumbers: data.handleNumbers,
              buttonsProperty: event2.buttons,
              locations: scope_Locations.slice()
            });
            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
              target: event2.target,
              handle,
              listeners: listeners2,
              doNotReject: true,
              handleNumbers: data.handleNumbers
            });
            var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
              target: event2.target,
              handle,
              listeners: listeners2,
              doNotReject: true,
              handleNumbers: data.handleNumbers
            });
            listeners2.push.apply(listeners2, moveEvent.concat(endEvent, outEvent));
            if (event2.cursor) {
              scope_Body.style.cursor = getComputedStyle(event2.target).cursor;
              if (scope_Handles.length > 1) {
                addClass2(scope_Target, options.cssClasses.drag);
              }
              scope_Body.addEventListener("selectstart", preventDefault3, false);
            }
            data.handleNumbers.forEach(function(handleNumber) {
              fireEvent("start", handleNumber);
            });
          }
          function eventTap(event2) {
            event2.stopPropagation();
            var proposal = calcPointToPercentage(event2.calcPoint);
            var handleNumber = getClosestHandle(proposal);
            if (handleNumber === false) {
              return;
            }
            if (!options.events.snap) {
              addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }
            setHandle(handleNumber, proposal, true, true);
            setZindex();
            fireEvent("slide", handleNumber, true);
            fireEvent("update", handleNumber, true);
            if (!options.events.snap) {
              fireEvent("change", handleNumber, true);
              fireEvent("set", handleNumber, true);
            } else {
              eventStart(event2, { handleNumbers: [handleNumber] });
            }
          }
          function eventHover(event2) {
            var proposal = calcPointToPercentage(event2.calcPoint);
            var to = scope_Spectrum.getStep(proposal);
            var value2 = scope_Spectrum.fromStepping(to);
            Object.keys(scope_Events).forEach(function(targetEvent) {
              if (targetEvent.split(".")[0] === "hover") {
                scope_Events[targetEvent].forEach(function(callback) {
                  callback.call(scope_Self, value2);
                });
              }
            });
          }
          function eventKeydown(event2, handleNumber) {
            if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
              return false;
            }
            var horizontalKeys = ["Left", "Right"];
            var verticalKeys = ["Down", "Up"];
            var largeStepKeys = ["PageDown", "PageUp"];
            var edgeKeys = ["Home", "End"];
            if (options.dir && !options.ort) {
              horizontalKeys.reverse();
            } else if (options.ort && !options.dir) {
              verticalKeys.reverse();
              largeStepKeys.reverse();
            }
            var key = event2.key.replace("Arrow", "");
            var isLargeDown = key === largeStepKeys[0];
            var isLargeUp = key === largeStepKeys[1];
            var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
            var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
            var isMin = key === edgeKeys[0];
            var isMax = key === edgeKeys[1];
            if (!isDown && !isUp && !isMin && !isMax) {
              return true;
            }
            event2.preventDefault();
            var to;
            if (isUp || isDown) {
              var direction = isDown ? 0 : 1;
              var steps = getNextStepsForHandle(handleNumber);
              var step = steps[direction];
              if (step === null) {
                return false;
              }
              if (step === false) {
                step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
              }
              if (isLargeUp || isLargeDown) {
                step *= options.keyboardPageMultiplier;
              } else {
                step *= options.keyboardMultiplier;
              }
              step = Math.max(step, 1e-7);
              step = (isDown ? -1 : 1) * step;
              to = scope_Values[handleNumber] + step;
            } else if (isMax) {
              to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
            } else {
              to = options.spectrum.xVal[0];
            }
            setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
            fireEvent("slide", handleNumber);
            fireEvent("update", handleNumber);
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);
            return false;
          }
          function bindSliderEvents(behaviour) {
            if (!behaviour.fixed) {
              scope_Handles.forEach(function(handle, index2) {
                attachEvent(actions.start, handle.children[0], eventStart, {
                  handleNumbers: [index2]
                });
              });
            }
            if (behaviour.tap) {
              attachEvent(actions.start, scope_Base, eventTap, {});
            }
            if (behaviour.hover) {
              attachEvent(actions.move, scope_Base, eventHover, {
                hover: true
              });
            }
            if (behaviour.drag) {
              scope_Connects.forEach(function(connect, index2) {
                if (connect === false || index2 === 0 || index2 === scope_Connects.length - 1) {
                  return;
                }
                var handleBefore = scope_Handles[index2 - 1];
                var handleAfter = scope_Handles[index2];
                var eventHolders = [connect];
                var handlesToDrag = [handleBefore, handleAfter];
                var handleNumbersToDrag = [index2 - 1, index2];
                addClass2(connect, options.cssClasses.draggable);
                if (behaviour.fixed) {
                  eventHolders.push(handleBefore.children[0]);
                  eventHolders.push(handleAfter.children[0]);
                }
                if (behaviour.dragAll) {
                  handlesToDrag = scope_Handles;
                  handleNumbersToDrag = scope_HandleNumbers;
                }
                eventHolders.forEach(function(eventHolder) {
                  attachEvent(actions.start, eventHolder, eventStart, {
                    handles: handlesToDrag,
                    handleNumbers: handleNumbersToDrag,
                    connect
                  });
                });
              });
            }
          }
          function bindEvent(namespacedEvent, callback) {
            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
            scope_Events[namespacedEvent].push(callback);
            if (namespacedEvent.split(".")[0] === "update") {
              scope_Handles.forEach(function(a, index2) {
                fireEvent("update", index2);
              });
            }
          }
          function isInternalNamespace(namespace) {
            return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
          }
          function removeEvent(namespacedEvent) {
            var event2 = namespacedEvent && namespacedEvent.split(".")[0];
            var namespace = event2 ? namespacedEvent.substring(event2.length) : namespacedEvent;
            Object.keys(scope_Events).forEach(function(bind3) {
              var tEvent = bind3.split(".")[0];
              var tNamespace = bind3.substring(tEvent.length);
              if ((!event2 || event2 === tEvent) && (!namespace || namespace === tNamespace)) {
                if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                  delete scope_Events[bind3];
                }
              }
            });
          }
          function fireEvent(eventName, handleNumber, tap) {
            Object.keys(scope_Events).forEach(function(targetEvent) {
              var eventType = targetEvent.split(".")[0];
              if (eventName === eventType) {
                scope_Events[targetEvent].forEach(function(callback) {
                  callback.call(scope_Self, scope_Values.map(options.format.to), handleNumber, scope_Values.slice(), tap || false, scope_Locations.slice(), scope_Self);
                });
              }
            });
          }
          function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue, smoothSteps) {
            var distance;
            if (scope_Handles.length > 1 && !options.events.unconstrained) {
              if (lookBackward && handleNumber > 0) {
                distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
                to = Math.max(to, distance);
              }
              if (lookForward && handleNumber < scope_Handles.length - 1) {
                distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
                to = Math.min(to, distance);
              }
            }
            if (scope_Handles.length > 1 && options.limit) {
              if (lookBackward && handleNumber > 0) {
                distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
                to = Math.min(to, distance);
              }
              if (lookForward && handleNumber < scope_Handles.length - 1) {
                distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
                to = Math.max(to, distance);
              }
            }
            if (options.padding) {
              if (handleNumber === 0) {
                distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
                to = Math.max(to, distance);
              }
              if (handleNumber === scope_Handles.length - 1) {
                distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
                to = Math.min(to, distance);
              }
            }
            if (!smoothSteps) {
              to = scope_Spectrum.getStep(to);
            }
            to = limit(to);
            if (to === reference[handleNumber] && !getValue) {
              return false;
            }
            return to;
          }
          function inRuleOrder(v, a) {
            var o = options.ort;
            return (o ? a : v) + ", " + (o ? v : a);
          }
          function moveHandles(upward, proposal, locations, handleNumbers, connect) {
            var proposals = locations.slice();
            var firstHandle = handleNumbers[0];
            var smoothSteps = options.events.smoothSteps;
            var b = [!upward, upward];
            var f = [upward, !upward];
            handleNumbers = handleNumbers.slice();
            if (upward) {
              handleNumbers.reverse();
            }
            if (handleNumbers.length > 1) {
              handleNumbers.forEach(function(handleNumber, o) {
                var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false, smoothSteps);
                if (to === false) {
                  proposal = 0;
                } else {
                  proposal = to - proposals[handleNumber];
                  proposals[handleNumber] = to;
                }
              });
            } else {
              b = f = [true];
            }
            var state = false;
            handleNumbers.forEach(function(handleNumber, o) {
              state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o], false, smoothSteps) || state;
            });
            if (state) {
              handleNumbers.forEach(function(handleNumber) {
                fireEvent("update", handleNumber);
                fireEvent("slide", handleNumber);
              });
              if (connect != void 0) {
                fireEvent("drag", firstHandle);
              }
            }
          }
          function transformDirection(a, b) {
            return options.dir ? 100 - a - b : a;
          }
          function updateHandlePosition(handleNumber, to) {
            scope_Locations[handleNumber] = to;
            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
            var translation = transformDirection(to, 0) - scope_DirOffset;
            var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
            scope_Handles[handleNumber].style[options.transformRule] = translateRule;
            updateConnect(handleNumber);
            updateConnect(handleNumber + 1);
          }
          function setZindex() {
            scope_HandleNumbers.forEach(function(handleNumber) {
              var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
              var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
              scope_Handles[handleNumber].style.zIndex = String(zIndex);
            });
          }
          function setHandle(handleNumber, to, lookBackward, lookForward, exactInput, smoothSteps) {
            if (!exactInput) {
              to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false, smoothSteps);
            }
            if (to === false) {
              return false;
            }
            updateHandlePosition(handleNumber, to);
            return true;
          }
          function updateConnect(index2) {
            if (!scope_Connects[index2]) {
              return;
            }
            var l = 0;
            var h = 100;
            if (index2 !== 0) {
              l = scope_Locations[index2 - 1];
            }
            if (index2 !== scope_Connects.length - 1) {
              h = scope_Locations[index2];
            }
            var connectWidth = h - l;
            var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
            var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
            scope_Connects[index2].style[options.transformRule] = translateRule + " " + scaleRule;
          }
          function resolveToValue(to, handleNumber) {
            if (to === null || to === false || to === void 0) {
              return scope_Locations[handleNumber];
            }
            if (typeof to === "number") {
              to = String(to);
            }
            to = options.format.from(to);
            if (to !== false) {
              to = scope_Spectrum.toStepping(to);
            }
            if (to === false || isNaN(to)) {
              return scope_Locations[handleNumber];
            }
            return to;
          }
          function valueSet(input, fireSetEvent, exactInput) {
            var values = asArray(input);
            var isInit = scope_Locations[0] === void 0;
            fireSetEvent = fireSetEvent === void 0 ? true : fireSetEvent;
            if (options.animate && !isInit) {
              addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }
            scope_HandleNumbers.forEach(function(handleNumber) {
              setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
            });
            var i = scope_HandleNumbers.length === 1 ? 0 : 1;
            if (isInit && scope_Spectrum.hasNoSize()) {
              exactInput = true;
              scope_Locations[0] = 0;
              if (scope_HandleNumbers.length > 1) {
                var space_1 = 100 / (scope_HandleNumbers.length - 1);
                scope_HandleNumbers.forEach(function(handleNumber) {
                  scope_Locations[handleNumber] = handleNumber * space_1;
                });
              }
            }
            for (; i < scope_HandleNumbers.length; ++i) {
              scope_HandleNumbers.forEach(function(handleNumber) {
                setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
              });
            }
            setZindex();
            scope_HandleNumbers.forEach(function(handleNumber) {
              fireEvent("update", handleNumber);
              if (values[handleNumber] !== null && fireSetEvent) {
                fireEvent("set", handleNumber);
              }
            });
          }
          function valueReset(fireSetEvent) {
            valueSet(options.start, fireSetEvent);
          }
          function valueSetHandle(handleNumber, value2, fireSetEvent, exactInput) {
            handleNumber = Number(handleNumber);
            if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
              throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
            }
            setHandle(handleNumber, resolveToValue(value2, handleNumber), true, true, exactInput);
            fireEvent("update", handleNumber);
            if (fireSetEvent) {
              fireEvent("set", handleNumber);
            }
          }
          function valueGet(unencoded) {
            if (unencoded === void 0) {
              unencoded = false;
            }
            if (unencoded) {
              return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
            }
            var values = scope_Values.map(options.format.to);
            if (values.length === 1) {
              return values[0];
            }
            return values;
          }
          function destroy2() {
            removeEvent(INTERNAL_EVENT_NS.aria);
            removeEvent(INTERNAL_EVENT_NS.tooltips);
            Object.keys(options.cssClasses).forEach(function(key) {
              removeClass2(scope_Target, options.cssClasses[key]);
            });
            while (scope_Target.firstChild) {
              scope_Target.removeChild(scope_Target.firstChild);
            }
            delete scope_Target.noUiSlider;
          }
          function getNextStepsForHandle(handleNumber) {
            var location2 = scope_Locations[handleNumber];
            var nearbySteps = scope_Spectrum.getNearbySteps(location2);
            var value2 = scope_Values[handleNumber];
            var increment = nearbySteps.thisStep.step;
            var decrement = null;
            if (options.snap) {
              return [
                value2 - nearbySteps.stepBefore.startValue || null,
                nearbySteps.stepAfter.startValue - value2 || null
              ];
            }
            if (increment !== false) {
              if (value2 + increment > nearbySteps.stepAfter.startValue) {
                increment = nearbySteps.stepAfter.startValue - value2;
              }
            }
            if (value2 > nearbySteps.thisStep.startValue) {
              decrement = nearbySteps.thisStep.step;
            } else if (nearbySteps.stepBefore.step === false) {
              decrement = false;
            } else {
              decrement = value2 - nearbySteps.stepBefore.highestStep;
            }
            if (location2 === 100) {
              increment = null;
            } else if (location2 === 0) {
              decrement = null;
            }
            var stepDecimals = scope_Spectrum.countStepDecimals();
            if (increment !== null && increment !== false) {
              increment = Number(increment.toFixed(stepDecimals));
            }
            if (decrement !== null && decrement !== false) {
              decrement = Number(decrement.toFixed(stepDecimals));
            }
            return [decrement, increment];
          }
          function getNextSteps() {
            return scope_HandleNumbers.map(getNextStepsForHandle);
          }
          function updateOptions(optionsToUpdate, fireSetEvent) {
            var v = valueGet();
            var updateAble = [
              "margin",
              "limit",
              "padding",
              "range",
              "animate",
              "snap",
              "step",
              "format",
              "pips",
              "tooltips"
            ];
            updateAble.forEach(function(name) {
              if (optionsToUpdate[name] !== void 0) {
                originalOptions[name] = optionsToUpdate[name];
              }
            });
            var newOptions = testOptions(originalOptions);
            updateAble.forEach(function(name) {
              if (optionsToUpdate[name] !== void 0) {
                options[name] = newOptions[name];
              }
            });
            scope_Spectrum = newOptions.spectrum;
            options.margin = newOptions.margin;
            options.limit = newOptions.limit;
            options.padding = newOptions.padding;
            if (options.pips) {
              pips(options.pips);
            } else {
              removePips();
            }
            if (options.tooltips) {
              tooltips();
            } else {
              removeTooltips();
            }
            scope_Locations = [];
            valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);
          }
          function setupSlider() {
            scope_Base = addSlider(scope_Target);
            addElements(options.connect, scope_Base);
            bindSliderEvents(options.events);
            valueSet(options.start);
            if (options.pips) {
              pips(options.pips);
            }
            if (options.tooltips) {
              tooltips();
            }
            aria();
          }
          setupSlider();
          var scope_Self = {
            destroy: destroy2,
            steps: getNextSteps,
            on: bindEvent,
            off: removeEvent,
            get: valueGet,
            set: valueSet,
            setHandle: valueSetHandle,
            reset: valueReset,
            __moveHandles: function(upward, proposal, handleNumbers) {
              moveHandles(upward, proposal, scope_Locations, handleNumbers);
            },
            options: originalOptions,
            updateOptions,
            target: scope_Target,
            removePips,
            removeTooltips,
            getPositions: function() {
              return scope_Locations.slice();
            },
            getTooltips: function() {
              return scope_Tooltips;
            },
            getOrigins: function() {
              return scope_Handles;
            },
            pips
          };
          return scope_Self;
        }
        function initialize(target, originalOptions) {
          if (!target || !target.nodeName) {
            throw new Error("noUiSlider: create requires a single element, got: " + target);
          }
          if (target.noUiSlider) {
            throw new Error("noUiSlider: Slider was already initialized.");
          }
          var options = testOptions(originalOptions);
          var api = scope(target, options, originalOptions);
          target.noUiSlider = api;
          return api;
        }
        var nouislider = {
          __spectrum: Spectrum,
          cssClasses,
          create: initialize
        };
        exports2.create = initialize;
        exports2.cssClasses = cssClasses;
        exports2["default"] = nouislider;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/fslightbox/index.js
  var require_fslightbox = __commonJS({
    "node_modules/fslightbox/index.js"(exports, module) {
      !function(e2, t) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = t();
        else if (typeof define == "function" && define.amd)
          define([], t);
        else {
          var n = t();
          for (var o in n)
            (typeof exports == "object" ? exports : e2)[o] = n[o];
        }
      }(window, function() {
        return function(e2) {
          var t = {};
          function n(o) {
            if (t[o])
              return t[o].exports;
            var r = t[o] = { i: o, l: false, exports: {} };
            return e2[o].call(r.exports, r, r.exports, n), r.l = true, r.exports;
          }
          return n.m = e2, n.c = t, n.d = function(e3, t2, o) {
            n.o(e3, t2) || Object.defineProperty(e3, t2, { enumerable: true, get: o });
          }, n.r = function(e3) {
            typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
          }, n.t = function(e3, t2) {
            if (1 & t2 && (e3 = n(e3)), 8 & t2)
              return e3;
            if (4 & t2 && typeof e3 == "object" && e3 && e3.__esModule)
              return e3;
            var o = Object.create(null);
            if (n.r(o), Object.defineProperty(o, "default", { enumerable: true, value: e3 }), 2 & t2 && typeof e3 != "string")
              for (var r in e3)
                n.d(o, r, function(t3) {
                  return e3[t3];
                }.bind(null, r));
            return o;
          }, n.n = function(e3) {
            var t2 = e3 && e3.__esModule ? function() {
              return e3.default;
            } : function() {
              return e3;
            };
            return n.d(t2, "a", t2), t2;
          }, n.o = function(e3, t2) {
            return Object.prototype.hasOwnProperty.call(e3, t2);
          }, n.p = "", n(n.s = 0);
        }([function(e2, t, n) {
          "use strict";
          n.r(t);
          var o, r = "fslightbox-", i = "".concat(r, "styles"), s = "".concat(r, "cursor-grabbing"), c = "".concat(r, "full-dimension"), a = "".concat(r, "flex-centered"), l = "".concat(r, "open"), u = "".concat(r, "transform-transition"), d = "".concat(r, "absoluted"), p = "".concat(r, "slide-btn"), f = "".concat(p, "-container"), h = "".concat(r, "fade-in"), m = "".concat(r, "fade-out"), g = h + "-strong", v = m + "-strong", b = "".concat(r, "opacity-"), x = "".concat(b, "1"), y = "".concat(r, "source");
          function S(e3) {
            return (S = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          (typeof document == "undefined" ? "undefined" : S(document)) === "object" && ((o = document.createElement("style")).className = i, o.appendChild(document.createTextNode(".fslightbox-absoluted{position:absolute;top:0;left:0}.fslightbox-fade-in{animation:fslightbox-fade-in .3s cubic-bezier(0,0,.7,1)}.fslightbox-fade-out{animation:fslightbox-fade-out .3s ease}.fslightbox-fade-in-strong{animation:fslightbox-fade-in-strong .3s cubic-bezier(0,0,.7,1)}.fslightbox-fade-out-strong{animation:fslightbox-fade-out-strong .3s ease}@keyframes fslightbox-fade-in{from{opacity:.65}to{opacity:1}}@keyframes fslightbox-fade-out{from{opacity:.35}to{opacity:0}}@keyframes fslightbox-fade-in-strong{from{opacity:.3}to{opacity:1}}@keyframes fslightbox-fade-out-strong{from{opacity:1}to{opacity:0}}.fslightbox-cursor-grabbing{cursor:grabbing}.fslightbox-full-dimension{width:100%;height:100%}.fslightbox-open{overflow:hidden;height:100%}.fslightbox-flex-centered{display:flex;justify-content:center;align-items:center}.fslightbox-opacity-0{opacity:0!important}.fslightbox-opacity-1{opacity:1!important}.fslightbox-scrollbarfix{padding-right:17px}.fslightbox-transform-transition{transition:transform .3s}.fslightbox-container{font-family:Arial,sans-serif;position:fixed;top:0;left:0;background:linear-gradient(rgba(30,30,30,.9),#000 1810%);touch-action:pinch-zoom;z-index:1000000000;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.fslightbox-container *{box-sizing:border-box}.fslightbox-svg-path{transition:fill .15s ease;fill:#ddd}.fslightbox-nav{height:45px;width:100%;position:absolute;top:0;left:0}.fslightbox-slide-number-container{display:flex;justify-content:center;align-items:center;position:relative;height:100%;font-size:15px;color:#d7d7d7;z-index:0;max-width:55px;text-align:left}.fslightbox-slide-number-container .fslightbox-flex-centered{height:100%}.fslightbox-slash{display:block;margin:0 5px;width:1px;height:12px;transform:rotate(15deg);background:#fff}.fslightbox-toolbar{position:absolute;z-index:3;right:0;top:0;height:100%;display:flex;background:rgba(35,35,35,.65)}.fslightbox-toolbar-button{height:100%;width:45px;cursor:pointer}.fslightbox-toolbar-button:hover .fslightbox-svg-path{fill:#fff}.fslightbox-slide-btn-container{display:flex;align-items:center;padding:12px 12px 12px 6px;position:absolute;top:50%;cursor:pointer;z-index:3;transform:translateY(-50%)}@media (min-width:476px){.fslightbox-slide-btn-container{padding:22px 22px 22px 6px}}@media (min-width:768px){.fslightbox-slide-btn-container{padding:30px 30px 30px 6px}}.fslightbox-slide-btn-container:hover .fslightbox-svg-path{fill:#f1f1f1}.fslightbox-slide-btn{padding:9px;font-size:26px;background:rgba(35,35,35,.65)}@media (min-width:768px){.fslightbox-slide-btn{padding:10px}}@media (min-width:1600px){.fslightbox-slide-btn{padding:11px}}.fslightbox-slide-btn-container-previous{left:0}@media (max-width:475.99px){.fslightbox-slide-btn-container-previous{padding-left:3px}}.fslightbox-slide-btn-container-next{right:0;padding-left:12px;padding-right:3px}@media (min-width:476px){.fslightbox-slide-btn-container-next{padding-left:22px}}@media (min-width:768px){.fslightbox-slide-btn-container-next{padding-left:30px}}@media (min-width:476px){.fslightbox-slide-btn-container-next{padding-right:6px}}.fslightbox-down-event-detector{position:absolute;z-index:1}.fslightbox-slide-swiping-hoverer{z-index:4}.fslightbox-invalid-file-wrapper{font-size:22px;color:#eaebeb;margin:auto}.fslightbox-video{object-fit:cover}.fslightbox-youtube-iframe{border:0}.fslightbox-loader{display:block;margin:auto;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:67px;height:67px}.fslightbox-loader div{box-sizing:border-box;display:block;position:absolute;width:54px;height:54px;margin:6px;border:5px solid;border-color:#999 transparent transparent transparent;border-radius:50%;animation:fslightbox-loader 1.2s cubic-bezier(.5,0,.5,1) infinite}.fslightbox-loader div:nth-child(1){animation-delay:-.45s}.fslightbox-loader div:nth-child(2){animation-delay:-.3s}.fslightbox-loader div:nth-child(3){animation-delay:-.15s}@keyframes fslightbox-loader{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.fslightbox-source{position:relative;z-index:2;opacity:0}")), document.head.appendChild(o));
          function w(e3) {
            var t2, n2 = e3.props, o2 = 0, r2 = {};
            this.getSourceTypeFromLocalStorageByUrl = function(e4) {
              return t2[e4] ? t2[e4] : i2(e4);
            }, this.handleReceivedSourceTypeForUrl = function(e4, n3) {
              r2[n3] === false && (o2--, e4 !== "invalid" ? r2[n3] = e4 : delete r2[n3], o2 === 0 && (!function(e5, t3) {
                for (var n4 in t3)
                  e5[n4] = t3[n4];
              }(t2, r2), localStorage.setItem("fslightbox-types", JSON.stringify(t2))));
            };
            var i2 = function(e4) {
              o2++, r2[e4] = false;
            };
            n2.disableLocalStorage ? (this.getSourceTypeFromLocalStorageByUrl = function() {
            }, this.handleReceivedSourceTypeForUrl = function() {
            }) : (t2 = JSON.parse(localStorage.getItem("fslightbox-types"))) || (t2 = {}, this.getSourceTypeFromLocalStorageByUrl = i2);
          }
          function L(e3, t2, n2, o2) {
            var r2 = e3.data, i2 = e3.elements.sources, s2 = n2 / o2, c2 = 0;
            this.adjustSize = function() {
              if ((c2 = r2.maxSourceWidth / s2) < r2.maxSourceHeight)
                return n2 < r2.maxSourceWidth && (c2 = o2), a2();
              c2 = o2 > r2.maxSourceHeight ? r2.maxSourceHeight : o2, a2();
            };
            var a2 = function() {
              i2[t2].style.width = c2 * s2 + "px", i2[t2].style.height = c2 + "px";
            };
          }
          function C(e3, t2) {
            var n2 = this, o2 = e3.collections.sourceSizers, r2 = e3.elements, i2 = r2.sourceAnimationWrappers, s2 = r2.sourceMainWrappers, c2 = r2.sources, a2 = e3.resolve;
            function l2(e4, n3) {
              o2[t2] = a2(L, [t2, e4, n3]), o2[t2].adjustSize();
            }
            this.runActions = function(e4, o3) {
              c2[t2].classList.add(x), i2[t2].classList.add(g), s2[t2].removeChild(s2[t2].firstChild), l2(e4, o3), n2.runActions = l2;
            };
          }
          function F(e3, t2) {
            var n2, o2 = this, r2 = e3.elements.sources, i2 = e3.props, s2 = (0, e3.resolve)(C, [t2]);
            this.handleImageLoad = function(e4) {
              var t3 = e4.target, n3 = t3.naturalWidth, o3 = t3.naturalHeight;
              s2.runActions(n3, o3);
            }, this.handleVideoLoad = function(e4) {
              var t3 = e4.target, o3 = t3.videoWidth, r3 = t3.videoHeight;
              n2 = true, s2.runActions(o3, r3);
            }, this.handleNotMetaDatedVideoLoad = function() {
              n2 || o2.handleYoutubeLoad();
            }, this.handleYoutubeLoad = function() {
              var e4 = 1920, t3 = 1080;
              i2.maxYoutubeDimensions && (e4 = i2.maxYoutubeDimensions.width, t3 = i2.maxYoutubeDimensions.height), s2.runActions(e4, t3);
            }, this.handleCustomLoad = function() {
              setTimeout(function() {
                var e4 = r2[t2];
                s2.runActions(e4.offsetWidth, e4.offsetHeight);
              });
            };
          }
          function A(e3, t2, n2) {
            var o2 = e3.elements.sources, r2 = e3.props.customClasses, i2 = r2[t2] ? r2[t2] : "";
            o2[t2].className = n2 + " " + i2;
          }
          function I(e3, t2) {
            var n2 = e3.elements.sources, o2 = e3.props.customAttributes;
            for (var r2 in o2[t2])
              n2[t2].setAttribute(r2, o2[t2][r2]);
          }
          function T(e3, t2) {
            var n2 = e3.collections.sourceLoadHandlers, o2 = e3.elements, r2 = o2.sources, i2 = o2.sourceAnimationWrappers, s2 = e3.props.sources;
            r2[t2] = document.createElement("img"), A(e3, t2, y), r2[t2].src = s2[t2], r2[t2].onload = n2[t2].handleImageLoad, I(e3, t2), i2[t2].appendChild(r2[t2]);
          }
          function E(e3, t2) {
            var n2 = e3.collections.sourceLoadHandlers, o2 = e3.elements, r2 = o2.sources, i2 = o2.sourceAnimationWrappers, s2 = e3.props, c2 = s2.sources, a2 = s2.videosPosters;
            r2[t2] = document.createElement("video"), A(e3, t2, y), r2[t2].src = c2[t2], r2[t2].onloadedmetadata = function(e4) {
              n2[t2].handleVideoLoad(e4);
            }, r2[t2].controls = true, I(e3, t2), a2[t2] && (r2[t2].poster = a2[t2]);
            var l2 = document.createElement("source");
            l2.src = c2[t2], r2[t2].appendChild(l2), setTimeout(n2[t2].handleNotMetaDatedVideoLoad, 3e3), i2[t2].appendChild(r2[t2]);
          }
          function N(e3, t2) {
            var n2 = e3.collections.sourceLoadHandlers, o2 = e3.elements, i2 = o2.sources, s2 = o2.sourceAnimationWrappers, c2 = e3.props.sources;
            i2[t2] = document.createElement("iframe"), A(e3, t2, "".concat(y, " ").concat(r, "youtube-iframe")), i2[t2].src = "https://www.youtube.com/embed/".concat(c2[t2].match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/)[2], "?enablejsapi=1"), i2[t2].allowFullscreen = true, I(e3, t2), s2[t2].appendChild(i2[t2]), n2[t2].handleYoutubeLoad();
          }
          function W(e3, t2) {
            var n2 = e3.collections.sourceLoadHandlers, o2 = e3.elements, r2 = o2.sources, i2 = o2.sourceAnimationWrappers, s2 = e3.props.sources;
            r2[t2] = s2[t2], A(e3, t2, "".concat(r2[t2].className, " ").concat(y)), i2[t2].appendChild(r2[t2]), n2[t2].handleCustomLoad();
          }
          function z(e3, t2) {
            var n2 = e3.elements, o2 = n2.sources, i2 = n2.sourceAnimationWrappers, s2 = n2.sourceMainWrappers;
            e3.props.sources;
            o2[t2] = document.createElement("div"), o2[t2].className = "".concat(r, "invalid-file-wrapper ").concat(a), o2[t2].innerHTML = "Invalid source", i2[t2].classList.add(g), i2[t2].appendChild(o2[t2]), s2[t2].removeChild(s2[t2].firstChild);
          }
          function M(e3) {
            var t2 = e3.collections, n2 = t2.sourceLoadHandlers, o2 = t2.sourcesRenderFunctions, r2 = e3.core.sourceDisplayFacade, i2 = e3.resolve;
            this.runActionsForSourceTypeAndIndex = function(t3, s2) {
              var c2;
              switch (t3 !== "invalid" && (n2[s2] = i2(F, [s2])), t3) {
                case "image":
                  c2 = T;
                  break;
                case "video":
                  c2 = E;
                  break;
                case "youtube":
                  c2 = N;
                  break;
                case "custom":
                  c2 = W;
                  break;
                default:
                  c2 = z;
              }
              o2[s2] = function() {
                return c2(e3, s2);
              }, r2.displaySourcesWhichShouldBeDisplayed();
            };
          }
          function P() {
            var e3, t2, n2, o2 = { isUrlYoutubeOne: function(e4) {
              var t3 = document.createElement("a");
              return t3.href = e4, t3.hostname === "www.youtube.com";
            }, getTypeFromResponseContentType: function(e4) {
              return e4.slice(0, e4.indexOf("/"));
            } };
            function r2() {
              if (n2.readyState !== 4) {
                if (n2.readyState === 2) {
                  var e4;
                  switch (o2.getTypeFromResponseContentType(n2.getResponseHeader("content-type"))) {
                    case "image":
                      e4 = "image";
                      break;
                    case "video":
                      e4 = "video";
                      break;
                    default:
                      e4 = "invalid";
                  }
                  n2.onreadystatechange = null, n2.abort(), t2(e4);
                }
              } else
                t2("invalid");
            }
            this.setUrlToCheck = function(t3) {
              e3 = t3;
            }, this.getSourceType = function(i2) {
              if (o2.isUrlYoutubeOne(e3))
                return i2("youtube");
              t2 = i2, (n2 = new XMLHttpRequest()).onreadystatechange = r2, n2.open("GET", e3, true), n2.send();
            };
          }
          function H(e3, t2, n2) {
            var o2 = e3.props, r2 = o2.types, i2 = o2.type, s2 = o2.sources, c2 = e3.resolve;
            this.getTypeSetByClientForIndex = function(e4) {
              var t3;
              return r2 && r2[e4] ? t3 = r2[e4] : i2 && (t3 = i2), t3;
            }, this.retrieveTypeWithXhrForIndex = function(e4) {
              var o3 = c2(P);
              o3.setUrlToCheck(s2[e4]), o3.getSourceType(function(o4) {
                t2.handleReceivedSourceTypeForUrl(o4, s2[e4]), n2.runActionsForSourceTypeAndIndex(o4, e4);
              });
            };
          }
          function k(e3, t2) {
            var n2 = e3.componentsServices.hideSourceLoaderIfNotYetCollection, o2 = e3.elements, r2 = o2.sourceWrappersContainer, i2 = o2.sourceMainWrappers;
            i2[t2] = document.createElement("div"), i2[t2].className = "".concat(d, " ").concat(c, " ").concat(a), i2[t2].innerHTML = '<div class="fslightbox-loader"><div></div><div></div><div></div><div></div></div>';
            var s2 = i2[t2].firstChild;
            n2[t2] = function() {
              i2[t2].contains(s2) && i2[t2].removeChild(s2);
            }, r2.appendChild(i2[t2]), function(e4, t3) {
              var n3 = e4.elements, o3 = n3.sourceMainWrappers, r3 = n3.sourceAnimationWrappers;
              r3[t3] = document.createElement("div"), o3[t3].appendChild(r3[t3]);
            }(e3, t2);
          }
          function O(e3, t2, n2, o2) {
            var i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            i2.setAttributeNS(null, "width", t2), i2.setAttributeNS(null, "height", t2), i2.setAttributeNS(null, "viewBox", n2);
            var s2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
            return s2.setAttributeNS(null, "class", "".concat(r, "svg-path")), s2.setAttributeNS(null, "d", o2), i2.appendChild(s2), e3.appendChild(i2), i2;
          }
          function R(e3, t2) {
            var n2 = document.createElement("div");
            return n2.className = "".concat(r, "toolbar-button ").concat(a), n2.title = t2, e3.appendChild(n2), n2;
          }
          function D(e3, t2) {
            var n2 = document.createElement("div");
            n2.className = "".concat(r, "toolbar"), t2.appendChild(n2), function(e4, t3) {
              var n3 = e4.componentsServices, o2 = e4.core.fullscreenToggler, r2 = e4.data, i2 = "M4.5 11H3v4h4v-1.5H4.5V11zM3 7h1.5V4.5H7V3H3v4zm10.5 6.5H11V15h4v-4h-1.5v2.5zM11 3v1.5h2.5V7H15V3h-4z", s2 = R(t3);
              s2.title = "Enter fullscreen";
              var c2 = O(s2, "20px", "0 0 18 18", i2);
              n3.enterFullscreen = function() {
                r2.isFullscreenOpen = true, s2.title = "Exit fullscreen", c2.setAttributeNS(null, "width", "24px"), c2.setAttributeNS(null, "height", "24px"), c2.setAttributeNS(null, "viewBox", "0 0 950 1024"), c2.firstChild.setAttributeNS(null, "d", "M682 342h128v84h-212v-212h84v128zM598 810v-212h212v84h-128v128h-84zM342 342v-128h84v212h-212v-84h128zM214 682v-84h212v212h-84v-128h-128z");
              }, n3.exitFullscreen = function() {
                r2.isFullscreenOpen = false, s2.title = "Enter fullscreen", c2.setAttributeNS(null, "width", "20px"), c2.setAttributeNS(null, "height", "20px"), c2.setAttributeNS(null, "viewBox", "0 0 18 18"), c2.firstChild.setAttributeNS(null, "d", i2);
              }, s2.onclick = function() {
                r2.isFullscreenOpen ? o2.exitFullscreen() : o2.enterFullscreen();
              };
            }(e3, n2), function(e4, t3) {
              var n3 = R(t3, "Close");
              n3.onclick = e4.core.lightboxCloser.closeLightbox, O(n3, "20px", "0 0 24 24", "M 4.7070312 3.2929688 L 3.2929688 4.7070312 L 10.585938 12 L 3.2929688 19.292969 L 4.7070312 20.707031 L 12 13.414062 L 19.292969 20.707031 L 20.707031 19.292969 L 13.414062 12 L 20.707031 4.7070312 L 19.292969 3.2929688 L 12 10.585938 L 4.7070312 3.2929688 z");
            }(e3, n2);
          }
          function j(e3) {
            var t2 = e3.props.sources, n2 = e3.elements.container, o2 = document.createElement("div");
            o2.className = "".concat(r, "nav"), n2.appendChild(o2), D(e3, o2), t2.length > 1 && function(e4, t3) {
              var n3 = e4.componentsServices, o3 = e4.props.sources, i2 = (e4.stageIndexes, document.createElement("div"));
              i2.className = "".concat(r, "slide-number-container");
              var s2 = document.createElement("div");
              s2.className = a;
              var c2 = document.createElement("span");
              n3.setSlideNumber = function(e5) {
                return c2.innerHTML = e5;
              };
              var l2 = document.createElement("span");
              l2.className = "".concat(r, "slash");
              var u2 = document.createElement("div");
              u2.innerHTML = o3.length, i2.appendChild(s2), s2.appendChild(c2), s2.appendChild(l2), s2.appendChild(u2), t3.appendChild(i2), setTimeout(function() {
                s2.offsetWidth > 55 && (i2.style.justifyContent = "flex-start");
              });
            }(e3, o2);
          }
          function X(e3, t2) {
            var n2 = this, o2 = e3.elements.sourceMainWrappers, r2 = e3.props, i2 = 0;
            this.byValue = function(e4) {
              return i2 = e4, n2;
            }, this.negative = function() {
              s2(-c2());
            }, this.zero = function() {
              s2(0);
            }, this.positive = function() {
              s2(c2());
            };
            var s2 = function(e4) {
              o2[t2].style.transform = "translateX(".concat(e4 + i2, "px)"), i2 = 0;
            }, c2 = function() {
              return (1 + r2.slideDistance) * innerWidth;
            };
          }
          function B(e3, t2, n2, o2) {
            var r2 = e3.elements.container, i2 = n2.charAt(0).toUpperCase() + n2.slice(1), s2 = document.createElement("div");
            s2.className = "".concat(f, " ").concat(f, "-").concat(n2), s2.title = "".concat(i2, " slide"), s2.onclick = t2, function(e4, t3) {
              var n3 = document.createElement("div");
              n3.className = "".concat(p, " ").concat(a), O(n3, "20px", "0 0 20 20", t3), e4.appendChild(n3);
            }(s2, o2), r2.appendChild(s2);
          }
          function U(e3, t2) {
            var n2 = e3.classList;
            n2.contains(t2) && n2.remove(t2);
          }
          function V(e3) {
            var t2 = this, n2 = e3.core, o2 = n2.eventsDispatcher, r2 = n2.fullscreenToggler, i2 = n2.globalEventsController, s2 = n2.scrollbarRecompensor, c2 = e3.data, a2 = e3.elements, u2 = e3.props, d2 = e3.sourcePointerProps;
            this.isLightboxFadingOut = false, this.runActions = function() {
              t2.isLightboxFadingOut = true, a2.container.classList.add(v), i2.removeListeners(), u2.exitFullscreenOnClose && c2.isFullscreenOpen && r2.exitFullscreen(), setTimeout(function() {
                t2.isLightboxFadingOut = false, d2.isPointering = false, a2.container.classList.remove(v), document.documentElement.classList.remove(l), s2.removeRecompense(), document.body.removeChild(a2.container), o2.dispatch("onClose");
              }, 270);
            };
          }
          function Y(e3) {
            var t2, n2, o2, r2 = e3.collections.sourceMainWrappersTransformers, i2 = e3.componentsServices, s2 = e3.core, c2 = s2.classFacade, a2 = s2.slideIndexChanger, l2 = s2.sourceDisplayFacade, d2 = s2.stageManager, p2 = e3.elements.sourceAnimationWrappers, f2 = e3.stageIndexes, v2 = (t2 = function() {
              c2.removeFromEachElementClassIfContains("sourceAnimationWrappers", m);
            }, n2 = 300, o2 = [], function() {
              o2.push(true), setTimeout(function() {
                o2.pop(), o2.length || t2();
              }, n2);
            });
            a2.changeTo = function(e4) {
              f2.current = e4, d2.updateStageIndexes(), i2.setSlideNumber(e4 + 1), l2.displaySourcesWhichShouldBeDisplayed();
            }, a2.jumpTo = function(e4) {
              var t3 = f2.current;
              a2.changeTo(e4), c2.removeFromEachElementClassIfContains("sourceMainWrappers", u), U(p2[t3], g), U(p2[t3], h), p2[t3].classList.add(m), U(p2[e4], g), U(p2[e4], m), p2[e4].classList.add(h), v2(), r2[e4].zero(), setTimeout(function() {
                t3 !== f2.current && r2[t3].negative();
              }, 270);
            };
          }
          function _(e3) {
            var t2 = e3.core, n2 = t2.lightboxCloser, o2 = t2.fullscreenToggler, r2 = t2.slideChangeFacade;
            this.listener = function(e4) {
              switch (e4.key) {
                case "Escape":
                  n2.closeLightbox();
                  break;
                case "ArrowLeft":
                  r2.changeToPrevious();
                  break;
                case "ArrowRight":
                  r2.changeToNext();
                  break;
                case "F11":
                  e4.preventDefault(), o2.enterFullscreen();
              }
            };
          }
          function q(e3) {
            var t2 = e3.collections.sourceMainWrappersTransformers, n2 = e3.elements, o2 = e3.sourcePointerProps, r2 = e3.stageIndexes;
            function i2(e4, n3) {
              t2[e4].byValue(o2.swipedX)[n3]();
            }
            this.runActionsForEvent = function(e4) {
              var t3, c2, a2;
              n2.container.contains(n2.slideSwipingHoverer) || n2.container.appendChild(n2.slideSwipingHoverer), t3 = n2.container, c2 = s, (a2 = t3.classList).contains(c2) || a2.add(c2), o2.swipedX = e4.screenX - o2.downScreenX, i2(r2.current, "zero"), r2.previous !== void 0 && o2.swipedX > 0 ? i2(r2.previous, "negative") : r2.next !== void 0 && o2.swipedX < 0 && i2(r2.next, "positive");
            };
          }
          function J(e3) {
            var t2 = e3.props.sources, n2 = e3.resolve, o2 = e3.sourcePointerProps, r2 = n2(q);
            t2.length === 1 ? this.listener = function() {
              o2.swipedX = 1;
            } : this.listener = function(e4) {
              o2.isPointering && r2.runActionsForEvent(e4);
            };
          }
          function G(e3) {
            var t2 = e3.collections.sourceMainWrappersTransformers, n2 = e3.core.slideIndexChanger, o2 = e3.elements.sourceMainWrappers, r2 = e3.stageIndexes;
            this.runPositiveSwipedXActions = function() {
              r2.previous === void 0 || (i2("positive"), n2.changeTo(r2.previous)), i2("zero");
            }, this.runNegativeSwipedXActions = function() {
              r2.next === void 0 || (i2("negative"), n2.changeTo(r2.next)), i2("zero");
            };
            var i2 = function(e4) {
              o2[r2.current].classList.add(u), t2[r2.current][e4]();
            };
          }
          function $2(e3, t2) {
            e3.contains(t2) && e3.removeChild(t2);
          }
          function K(e3) {
            var t2 = e3.core.lightboxCloser, n2 = e3.elements, o2 = e3.resolve, r2 = e3.sourcePointerProps, i2 = o2(G);
            this.runNoSwipeActions = function() {
              $2(n2.container, n2.slideSwipingHoverer), r2.isSourceDownEventTarget || t2.closeLightbox(), r2.isPointering = false;
            }, this.runActions = function() {
              r2.swipedX > 0 ? i2.runPositiveSwipedXActions() : i2.runNegativeSwipedXActions(), $2(n2.container, n2.slideSwipingHoverer), n2.container.classList.remove(s), r2.isPointering = false;
            };
          }
          function Q(e3) {
            var t2 = e3.resolve, n2 = e3.sourcePointerProps, o2 = t2(K);
            this.listener = function() {
              n2.isPointering && (n2.swipedX ? o2.runActions() : o2.runNoSwipeActions());
            };
          }
          function Z(e3) {
            var t2, n2, o2;
            n2 = (t2 = e3).core.classFacade, o2 = t2.elements, n2.removeFromEachElementClassIfContains = function(e4, t3) {
              for (var n3 = 0; n3 < o2[e4].length; n3++)
                U(o2[e4][n3], t3);
            }, function(e4) {
              var t3 = e4.core.eventsDispatcher, n3 = e4.props;
              t3.dispatch = function(e5) {
                n3[e5] && n3[e5]();
              };
            }(e3), function(e4) {
              var t3 = e4.componentsServices, n3 = e4.core.fullscreenToggler;
              n3.enterFullscreen = function() {
                t3.enterFullscreen();
                var e5 = document.documentElement;
                e5.requestFullscreen ? e5.requestFullscreen() : e5.mozRequestFullScreen ? e5.mozRequestFullScreen() : e5.webkitRequestFullscreen ? e5.webkitRequestFullscreen() : e5.msRequestFullscreen && e5.msRequestFullscreen();
              }, n3.exitFullscreen = function() {
                t3.exitFullscreen(), document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen();
              };
            }(e3), function(e4) {
              var t3 = e4.core, n3 = t3.globalEventsController, o3 = t3.windowResizeActioner, r2 = e4.resolve, i2 = r2(_), s2 = r2(J), c2 = r2(Q);
              n3.attachListeners = function() {
                document.addEventListener("pointermove", s2.listener), document.addEventListener("pointerup", c2.listener), addEventListener("resize", o3.runActions), document.addEventListener("keydown", i2.listener);
              }, n3.removeListeners = function() {
                document.removeEventListener("pointermove", s2.listener), document.removeEventListener("pointerup", c2.listener), removeEventListener("resize", o3.runActions), document.removeEventListener("keydown", i2.listener);
              };
            }(e3), function(e4) {
              var t3 = e4.core.lightboxCloser, n3 = (0, e4.resolve)(V);
              t3.closeLightbox = function() {
                n3.isLightboxFadingOut || n3.runActions();
              };
            }(e3), ne(e3), function(e4) {
              var t3 = e4.data, n3 = e4.core.scrollbarRecompensor;
              function o3() {
                document.body.offsetHeight > innerHeight && (document.body.style.marginRight = t3.scrollbarWidth + "px");
              }
              n3.addRecompense = function() {
                document.readyState === "complete" ? o3() : addEventListener("load", function() {
                  o3(), n3.addRecompense = o3;
                });
              }, n3.removeRecompense = function() {
                document.body.style.removeProperty("margin-right");
              };
            }(e3), function(e4) {
              var t3 = e4.core, n3 = t3.slideChangeFacade, o3 = t3.slideIndexChanger, r2 = t3.stageManager;
              e4.props.sources.length > 1 ? (n3.changeToPrevious = function() {
                o3.jumpTo(r2.getPreviousSlideIndex());
              }, n3.changeToNext = function() {
                o3.jumpTo(r2.getNextSlideIndex());
              }) : (n3.changeToPrevious = function() {
              }, n3.changeToNext = function() {
              });
            }(e3), Y(e3), function(e4) {
              var t3 = e4.core, n3 = t3.classFacade, o3 = t3.sourcesPointerDown, r2 = e4.elements.sources, i2 = e4.sourcePointerProps, s2 = e4.stageIndexes;
              o3.listener = function(e5) {
                e5.target.tagName !== "VIDEO" && e5.preventDefault(), i2.isPointering = true, i2.downScreenX = e5.screenX, i2.swipedX = 0;
                var t4 = r2[s2.current];
                t4 && t4.contains(e5.target) ? i2.isSourceDownEventTarget = true : i2.isSourceDownEventTarget = false, n3.removeFromEachElementClassIfContains("sourceMainWrappers", u);
              };
            }(e3), function(e4) {
              var t3 = e4.collections.sourcesRenderFunctions, n3 = e4.core.sourceDisplayFacade, o3 = e4.props, r2 = e4.stageIndexes;
              function i2(e5) {
                t3[e5] && (t3[e5](), delete t3[e5]);
              }
              n3.displaySourcesWhichShouldBeDisplayed = function() {
                if (o3.loadOnlyCurrentSource)
                  i2(r2.current);
                else
                  for (var e5 in r2)
                    i2(r2[e5]);
              };
            }(e3), function(e4) {
              var t3 = e4.stageIndexes, n3 = e4.core.stageManager, o3 = e4.props.sources.length - 1;
              n3.getPreviousSlideIndex = function() {
                return t3.current === 0 ? o3 : t3.current - 1;
              }, n3.getNextSlideIndex = function() {
                return t3.current === o3 ? 0 : t3.current + 1;
              }, n3.updateStageIndexes = o3 === 0 ? function() {
              } : o3 === 1 ? function() {
                t3.current === 0 ? (t3.next = 1, delete t3.previous) : (t3.previous = 0, delete t3.next);
              } : function() {
                t3.previous = n3.getPreviousSlideIndex(), t3.next = n3.getNextSlideIndex();
              }, n3.isSourceInStage = o3 <= 2 ? function() {
                return true;
              } : function(e5) {
                var n4 = t3.current;
                if (n4 === 0 && e5 === o3 || n4 === o3 && e5 === 0)
                  return true;
                var r2 = n4 - e5;
                return r2 === -1 || r2 === 0 || r2 === 1;
              };
            }(e3), function(e4) {
              var t3 = e4.collections, n3 = t3.sourceMainWrappersTransformers, o3 = t3.sourceSizers, r2 = e4.core.windowResizeActioner, i2 = e4.data, s2 = e4.elements.sourceMainWrappers, c2 = e4.props, a2 = e4.stageIndexes;
              r2.runActions = function() {
                innerWidth < 992 ? i2.maxSourceWidth = innerWidth : i2.maxSourceWidth = 0.9 * innerWidth, i2.maxSourceHeight = 0.9 * innerHeight;
                for (var e5 = 0; e5 < c2.sources.length; e5++)
                  U(s2[e5], u), e5 !== a2.current && n3[e5].negative(), o3[e5] && o3[e5].adjustSize();
              };
            }(e3);
          }
          function ee(e3) {
            var t2 = e3.props.disableLocalStorage;
            if (!t2) {
              var n2 = localStorage.getItem("fslightbox-scrollbar-width");
              if (n2)
                return n2;
            }
            var o2 = function() {
              var e4 = document.createElement("div"), t3 = e4.style;
              return t3.visibility = "hidden", t3.width = "100px", t3.msOverflowStyle = "scrollbar", t3.overflow = "scroll", e4;
            }(), r2 = function() {
              var e4 = document.createElement("div");
              return e4.style.width = "100%", e4;
            }();
            document.body.appendChild(o2);
            var i2 = o2.offsetWidth;
            o2.appendChild(r2);
            var s2 = r2.offsetWidth;
            document.body.removeChild(o2);
            var c2 = i2 - s2;
            return t2 || localStorage.setItem("fslightbox-scrollbar-width", c2.toString()), c2;
          }
          function te(e3) {
            var t2 = e3.core.eventsDispatcher, n2 = e3.data, o2 = e3.elements, i2 = e3.props.sources;
            n2.isInitialized = true, n2.scrollbarWidth = ee(e3), function(e4) {
              for (var t3 = e4.collections.sourceMainWrappersTransformers, n3 = e4.props.sources, o3 = e4.resolve, r2 = 0; r2 < n3.length; r2++)
                t3[r2] = o3(X, [r2]);
            }(e3), Z(e3), o2.container = document.createElement("div"), o2.container.className = "".concat(r, "container ").concat(c, " ").concat(g), function(e4) {
              var t3 = e4.elements;
              t3.slideSwipingHoverer = document.createElement("div"), t3.slideSwipingHoverer.className = "".concat(r, "slide-swiping-hoverer ").concat(c, " ").concat(d);
            }(e3), j(e3), function(e4) {
              var t3 = e4.core.sourcesPointerDown, n3 = e4.elements, o3 = e4.props.sources, r2 = document.createElement("div");
              r2.className = "".concat(d, " ").concat(c), n3.container.appendChild(r2), r2.addEventListener("pointerdown", t3.listener), n3.sourceWrappersContainer = r2;
              for (var i3 = 0; i3 < o3.length; i3++)
                k(e4, i3);
            }(e3), i2.length > 1 && function(e4) {
              var t3 = e4.core.slideChangeFacade;
              B(e4, t3.changeToPrevious, "previous", "M18.271,9.212H3.615l4.184-4.184c0.306-0.306,0.306-0.801,0-1.107c-0.306-0.306-0.801-0.306-1.107,0L1.21,9.403C1.194,9.417,1.174,9.421,1.158,9.437c-0.181,0.181-0.242,0.425-0.209,0.66c0.005,0.038,0.012,0.071,0.022,0.109c0.028,0.098,0.075,0.188,0.142,0.271c0.021,0.026,0.021,0.061,0.045,0.085c0.015,0.016,0.034,0.02,0.05,0.033l5.484,5.483c0.306,0.307,0.801,0.307,1.107,0c0.306-0.305,0.306-0.801,0-1.105l-4.184-4.185h14.656c0.436,0,0.788-0.353,0.788-0.788S18.707,9.212,18.271,9.212z"), B(e4, t3.changeToNext, "next", "M1.729,9.212h14.656l-4.184-4.184c-0.307-0.306-0.307-0.801,0-1.107c0.305-0.306,0.801-0.306,1.106,0l5.481,5.482c0.018,0.014,0.037,0.019,0.053,0.034c0.181,0.181,0.242,0.425,0.209,0.66c-0.004,0.038-0.012,0.071-0.021,0.109c-0.028,0.098-0.075,0.188-0.143,0.271c-0.021,0.026-0.021,0.061-0.045,0.085c-0.015,0.016-0.034,0.02-0.051,0.033l-5.483,5.483c-0.306,0.307-0.802,0.307-1.106,0c-0.307-0.305-0.307-0.801,0-1.105l4.184-4.185H1.729c-0.436,0-0.788-0.353-0.788-0.788S1.293,9.212,1.729,9.212z");
            }(e3), function(e4) {
              for (var t3 = e4.props.sources, n3 = e4.resolve, o3 = n3(w), r2 = n3(M), i3 = n3(H, [o3, r2]), s2 = 0; s2 < t3.length; s2++)
                if (typeof t3[s2] == "string") {
                  var c2 = i3.getTypeSetByClientForIndex(s2);
                  if (c2)
                    r2.runActionsForSourceTypeAndIndex(c2, s2);
                  else {
                    var a2 = o3.getSourceTypeFromLocalStorageByUrl(t3[s2]);
                    a2 ? r2.runActionsForSourceTypeAndIndex(a2, s2) : i3.retrieveTypeWithXhrForIndex(s2);
                  }
                } else
                  r2.runActionsForSourceTypeAndIndex("custom", s2);
            }(e3), t2.dispatch("onInit");
          }
          function ne(e3) {
            var t2 = e3.collections.sourceMainWrappersTransformers, n2 = e3.componentsServices, o2 = e3.core, r2 = o2.eventsDispatcher, i2 = o2.lightboxOpener, s2 = o2.globalEventsController, c2 = o2.scrollbarRecompensor, a2 = o2.sourceDisplayFacade, u2 = o2.stageManager, d2 = o2.windowResizeActioner, p2 = e3.data, f2 = e3.elements, h2 = e3.stageIndexes;
            i2.open = function() {
              var o3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              h2.current = o3, p2.isInitialized ? r2.dispatch("onShow") : te(e3), u2.updateStageIndexes(), a2.displaySourcesWhichShouldBeDisplayed(), n2.setSlideNumber(o3 + 1), document.body.appendChild(f2.container), document.documentElement.classList.add(l), c2.addRecompense(), s2.attachListeners(), d2.runActions(), t2[h2.current].zero(), r2.dispatch("onOpen");
            };
          }
          function oe(e3, t2, n2) {
            return (oe = re() ? Reflect.construct : function(e4, t3, n3) {
              var o2 = [null];
              o2.push.apply(o2, t3);
              var r2 = new (Function.bind.apply(e4, o2))();
              return n3 && ie(r2, n3.prototype), r2;
            }).apply(null, arguments);
          }
          function re() {
            if (typeof Reflect == "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy == "function")
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (e3) {
              return false;
            }
          }
          function ie(e3, t2) {
            return (ie = Object.setPrototypeOf || function(e4, t3) {
              return e4.__proto__ = t3, e4;
            })(e3, t2);
          }
          function se(e3) {
            return function(e4) {
              if (Array.isArray(e4))
                return ce(e4);
            }(e3) || function(e4) {
              if (typeof Symbol != "undefined" && Symbol.iterator in Object(e4))
                return Array.from(e4);
            }(e3) || function(e4, t2) {
              if (!e4)
                return;
              if (typeof e4 == "string")
                return ce(e4, t2);
              var n2 = Object.prototype.toString.call(e4).slice(8, -1);
              n2 === "Object" && e4.constructor && (n2 = e4.constructor.name);
              if (n2 === "Map" || n2 === "Set")
                return Array.from(e4);
              if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
                return ce(e4, t2);
            }(e3) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function ce(e3, t2) {
            (t2 == null || t2 > e3.length) && (t2 = e3.length);
            for (var n2 = 0, o2 = new Array(t2); n2 < t2; n2++)
              o2[n2] = e3[n2];
            return o2;
          }
          function ae() {
            for (var e3 = document.getElementsByTagName("a"), t2 = function(t3) {
              if (!e3[t3].hasAttribute("data-fslightbox"))
                return "continue";
              var n3 = e3[t3].getAttribute("data-fslightbox"), o3 = e3[t3].getAttribute("href");
              fsLightboxInstances[n3] || (fsLightboxInstances[n3] = new FsLightbox());
              var r2 = null;
              o3.charAt(0) === "#" ? (r2 = document.getElementById(o3.substring(1)).cloneNode(true)).removeAttribute("id") : r2 = o3, fsLightboxInstances[n3].props.sources.push(r2), fsLightboxInstances[n3].elements.a.push(e3[t3]);
              var i2 = fsLightboxInstances[n3].props.sources.length - 1;
              e3[t3].onclick = function(e4) {
                e4.preventDefault(), fsLightboxInstances[n3].open(i2);
              }, d2("types", "data-type"), d2("videosPosters", "data-video-poster"), d2("customClasses", "data-class"), d2("customClasses", "data-custom-class");
              for (var s2 = ["href", "data-fslightbox", "data-type", "data-video-poster", "data-class", "data-custom-class"], c2 = e3[t3].attributes, a2 = fsLightboxInstances[n3].props.customAttributes, l2 = 0; l2 < c2.length; l2++)
                if (s2.indexOf(c2[l2].name) === -1 && c2[l2].name.substr(0, 5) === "data-") {
                  a2[i2] || (a2[i2] = {});
                  var u2 = c2[l2].name.substr(5);
                  a2[i2][u2] = c2[l2].value;
                }
              function d2(o4, r3) {
                e3[t3].hasAttribute(r3) && (fsLightboxInstances[n3].props[o4][i2] = e3[t3].getAttribute(r3));
              }
            }, n2 = 0; n2 < e3.length; n2++)
              t2(n2);
            var o2 = Object.keys(fsLightboxInstances);
            window.fsLightbox = fsLightboxInstances[o2[o2.length - 1]];
          }
          window.FsLightbox = function() {
            var e3 = this;
            this.props = { sources: [], customAttributes: [], customClasses: [], types: [], videosPosters: [], slideDistance: 0.3 }, this.data = { isInitialized: false, isFullscreenOpen: false, maxSourceWidth: 0, maxSourceHeight: 0, scrollbarWidth: 0 }, this.sourcePointerProps = { downScreenX: null, isPointering: false, isSourceDownEventTarget: false, swipedX: 0 }, this.stageIndexes = {}, this.elements = { a: [], container: null, slideSwipingHoverer: null, sourceWrappersContainer: null, sources: [], sourceMainWrappers: [], sourceAnimationWrappers: [] }, this.componentsServices = { enterFullscreen: null, exitFullscreen: null, hideSourceLoaderIfNotYetCollection: [], setSlideNumber: function() {
            } }, this.resolve = function(t2) {
              var n2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
              return n2.unshift(e3), oe(t2, se(n2));
            }, this.collections = { sourceMainWrappersTransformers: [], sourceLoadHandlers: [], sourcesRenderFunctions: [], sourceSizers: [] }, this.core = { classFacade: {}, eventsDispatcher: {}, fullscreenToggler: {}, globalEventsController: {}, lightboxCloser: {}, lightboxOpener: {}, lightboxUpdater: {}, scrollbarRecompensor: {}, slideChangeFacade: {}, slideIndexChanger: {}, sourcesPointerDown: {}, sourceDisplayFacade: {}, stageManager: {}, windowResizeActioner: {} }, ne(this), this.open = function(t2) {
              return e3.core.lightboxOpener.open(t2);
            }, this.close = function() {
              return e3.core.lightboxCloser.closeLightbox();
            };
          }, window.fsLightboxInstances = {}, ae(), window.refreshFsLightbox = function() {
            for (var e3 in fsLightboxInstances) {
              var t2 = fsLightboxInstances[e3].props;
              fsLightboxInstances[e3] = new FsLightbox(), fsLightboxInstances[e3].props = t2, fsLightboxInstances[e3].props.sources = [], fsLightboxInstances[e3].elements.a = [];
            }
            ae();
          };
        }]);
      });
    }
  });

  // src/js/helpers.js
  var emailReg = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
  var phonePattern = "+7 999 999-99-99";
  var viewWidth = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  var viewHeight = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
  var valueToLocalString = (value2) => {
    return new Intl.NumberFormat().format(Math.ceil(Number(value2)));
  };
  var handleCartPopup = (urlParam) => {
    if (urlParam === "addItemToBasket") {
      const popupButton = document.querySelector(".header__nav-item--cart");
      popupButton.setAttribute("data-is-js", "true");
      !!popupButton && popupButton.click("test");
    }
  };
  var convertToDateFormat = (number) => {
    return number < 10 ? "0" + number : number;
  };
  var getTodayDate = () => {
    const today = new Date();
    const yyyy = today.getFullYear();
    const mm = convertToDateFormat(today.getMonth() + 1);
    const dd = convertToDateFormat(today.getDate());
    return `${dd}.${mm}.${yyyy}`;
  };

  // src/components/header/header.js
  var import_axios = __toModule(require_axios2());

  // node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js
  function get(element) {
    return getComputedStyle(element);
  }
  function set(element, obj) {
    for (var key in obj) {
      var val = obj[key];
      if (typeof val === "number") {
        val = val + "px";
      }
      element.style[key] = val;
    }
    return element;
  }
  function div(className) {
    var div2 = document.createElement("div");
    div2.className = className;
    return div2;
  }
  var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
  function matches(element, query) {
    if (!elMatches) {
      throw new Error("No element matching method supported");
    }
    return elMatches.call(element, query);
  }
  function remove(element) {
    if (element.remove) {
      element.remove();
    } else {
      if (element.parentNode) {
        element.parentNode.removeChild(element);
      }
    }
  }
  function queryChildren(element, selector) {
    return Array.prototype.filter.call(element.children, function(child) {
      return matches(child, selector);
    });
  }
  var cls = {
    main: "ps",
    rtl: "ps__rtl",
    element: {
      thumb: function(x) {
        return "ps__thumb-" + x;
      },
      rail: function(x) {
        return "ps__rail-" + x;
      },
      consuming: "ps__child--consume"
    },
    state: {
      focus: "ps--focus",
      clicking: "ps--clicking",
      active: function(x) {
        return "ps--active-" + x;
      },
      scrolling: function(x) {
        return "ps--scrolling-" + x;
      }
    }
  };
  var scrollingClassTimeout = { x: null, y: null };
  function addScrollingClass(i, x) {
    var classList = i.element.classList;
    var className = cls.state.scrolling(x);
    if (classList.contains(className)) {
      clearTimeout(scrollingClassTimeout[x]);
    } else {
      classList.add(className);
    }
  }
  function removeScrollingClass(i, x) {
    scrollingClassTimeout[x] = setTimeout(function() {
      return i.isAlive && i.element.classList.remove(cls.state.scrolling(x));
    }, i.settings.scrollingThreshold);
  }
  function setScrollingClassInstantly(i, x) {
    addScrollingClass(i, x);
    removeScrollingClass(i, x);
  }
  var EventElement = function EventElement2(element) {
    this.element = element;
    this.handlers = {};
  };
  var prototypeAccessors = { isEmpty: { configurable: true } };
  EventElement.prototype.bind = function bind(eventName, handler) {
    if (typeof this.handlers[eventName] === "undefined") {
      this.handlers[eventName] = [];
    }
    this.handlers[eventName].push(handler);
    this.element.addEventListener(eventName, handler, false);
  };
  EventElement.prototype.unbind = function unbind(eventName, target) {
    var this$1 = this;
    this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
      if (target && handler !== target) {
        return true;
      }
      this$1.element.removeEventListener(eventName, handler, false);
      return false;
    });
  };
  EventElement.prototype.unbindAll = function unbindAll() {
    for (var name in this.handlers) {
      this.unbind(name);
    }
  };
  prototypeAccessors.isEmpty.get = function() {
    var this$1 = this;
    return Object.keys(this.handlers).every(function(key) {
      return this$1.handlers[key].length === 0;
    });
  };
  Object.defineProperties(EventElement.prototype, prototypeAccessors);
  var EventManager = function EventManager2() {
    this.eventElements = [];
  };
  EventManager.prototype.eventElement = function eventElement(element) {
    var ee = this.eventElements.filter(function(ee2) {
      return ee2.element === element;
    })[0];
    if (!ee) {
      ee = new EventElement(element);
      this.eventElements.push(ee);
    }
    return ee;
  };
  EventManager.prototype.bind = function bind2(element, eventName, handler) {
    this.eventElement(element).bind(eventName, handler);
  };
  EventManager.prototype.unbind = function unbind2(element, eventName, handler) {
    var ee = this.eventElement(element);
    ee.unbind(eventName, handler);
    if (ee.isEmpty) {
      this.eventElements.splice(this.eventElements.indexOf(ee), 1);
    }
  };
  EventManager.prototype.unbindAll = function unbindAll2() {
    this.eventElements.forEach(function(e2) {
      return e2.unbindAll();
    });
    this.eventElements = [];
  };
  EventManager.prototype.once = function once(element, eventName, handler) {
    var ee = this.eventElement(element);
    var onceHandler = function(evt) {
      ee.unbind(eventName, onceHandler);
      handler(evt);
    };
    ee.bind(eventName, onceHandler);
  };
  function createEvent(name) {
    if (typeof window.CustomEvent === "function") {
      return new CustomEvent(name);
    } else {
      var evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(name, false, false, void 0);
      return evt;
    }
  }
  function processScrollDiff(i, axis, diff, useScrollingClass, forceFireReachEvent) {
    if (useScrollingClass === void 0)
      useScrollingClass = true;
    if (forceFireReachEvent === void 0)
      forceFireReachEvent = false;
    var fields;
    if (axis === "top") {
      fields = [
        "contentHeight",
        "containerHeight",
        "scrollTop",
        "y",
        "up",
        "down"
      ];
    } else if (axis === "left") {
      fields = [
        "contentWidth",
        "containerWidth",
        "scrollLeft",
        "x",
        "left",
        "right"
      ];
    } else {
      throw new Error("A proper axis should be provided");
    }
    processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
  }
  function processScrollDiff$1(i, diff, ref, useScrollingClass, forceFireReachEvent) {
    var contentHeight = ref[0];
    var containerHeight = ref[1];
    var scrollTop = ref[2];
    var y = ref[3];
    var up = ref[4];
    var down = ref[5];
    if (useScrollingClass === void 0)
      useScrollingClass = true;
    if (forceFireReachEvent === void 0)
      forceFireReachEvent = false;
    var element = i.element;
    i.reach[y] = null;
    if (element[scrollTop] < 1) {
      i.reach[y] = "start";
    }
    if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
      i.reach[y] = "end";
    }
    if (diff) {
      element.dispatchEvent(createEvent("ps-scroll-" + y));
      if (diff < 0) {
        element.dispatchEvent(createEvent("ps-scroll-" + up));
      } else if (diff > 0) {
        element.dispatchEvent(createEvent("ps-scroll-" + down));
      }
      if (useScrollingClass) {
        setScrollingClassInstantly(i, y);
      }
    }
    if (i.reach[y] && (diff || forceFireReachEvent)) {
      element.dispatchEvent(createEvent("ps-" + y + "-reach-" + i.reach[y]));
    }
  }
  function toInt(x) {
    return parseInt(x, 10) || 0;
  }
  function isEditable(el) {
    return matches(el, "input,[contenteditable]") || matches(el, "select,[contenteditable]") || matches(el, "textarea,[contenteditable]") || matches(el, "button,[contenteditable]");
  }
  function outerWidth(element) {
    var styles2 = get(element);
    return toInt(styles2.width) + toInt(styles2.paddingLeft) + toInt(styles2.paddingRight) + toInt(styles2.borderLeftWidth) + toInt(styles2.borderRightWidth);
  }
  var env = {
    isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
    supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
    supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
    isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
  };
  function updateGeometry(i) {
    var element = i.element;
    var roundedScrollTop = Math.floor(element.scrollTop);
    var rect = element.getBoundingClientRect();
    i.containerWidth = Math.round(rect.width);
    i.containerHeight = Math.round(rect.height);
    i.contentWidth = element.scrollWidth;
    i.contentHeight = element.scrollHeight;
    if (!element.contains(i.scrollbarXRail)) {
      queryChildren(element, cls.element.rail("x")).forEach(function(el) {
        return remove(el);
      });
      element.appendChild(i.scrollbarXRail);
    }
    if (!element.contains(i.scrollbarYRail)) {
      queryChildren(element, cls.element.rail("y")).forEach(function(el) {
        return remove(el);
      });
      element.appendChild(i.scrollbarYRail);
    }
    if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
      i.scrollbarXActive = true;
      i.railXWidth = i.containerWidth - i.railXMarginWidth;
      i.railXRatio = i.containerWidth / i.railXWidth;
      i.scrollbarXWidth = getThumbSize(i, toInt(i.railXWidth * i.containerWidth / i.contentWidth));
      i.scrollbarXLeft = toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
    } else {
      i.scrollbarXActive = false;
    }
    if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
      i.scrollbarYActive = true;
      i.railYHeight = i.containerHeight - i.railYMarginHeight;
      i.railYRatio = i.containerHeight / i.railYHeight;
      i.scrollbarYHeight = getThumbSize(i, toInt(i.railYHeight * i.containerHeight / i.contentHeight));
      i.scrollbarYTop = toInt(roundedScrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
    } else {
      i.scrollbarYActive = false;
    }
    if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
      i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
    }
    if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
      i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
    }
    updateCss(element, i);
    if (i.scrollbarXActive) {
      element.classList.add(cls.state.active("x"));
    } else {
      element.classList.remove(cls.state.active("x"));
      i.scrollbarXWidth = 0;
      i.scrollbarXLeft = 0;
      element.scrollLeft = i.isRtl === true ? i.contentWidth : 0;
    }
    if (i.scrollbarYActive) {
      element.classList.add(cls.state.active("y"));
    } else {
      element.classList.remove(cls.state.active("y"));
      i.scrollbarYHeight = 0;
      i.scrollbarYTop = 0;
      element.scrollTop = 0;
    }
  }
  function getThumbSize(i, thumbSize) {
    if (i.settings.minScrollbarLength) {
      thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
    }
    if (i.settings.maxScrollbarLength) {
      thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
    }
    return thumbSize;
  }
  function updateCss(element, i) {
    var xRailOffset = { width: i.railXWidth };
    var roundedScrollTop = Math.floor(element.scrollTop);
    if (i.isRtl) {
      xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
    } else {
      xRailOffset.left = element.scrollLeft;
    }
    if (i.isScrollbarXUsingBottom) {
      xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
    } else {
      xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
    }
    set(i.scrollbarXRail, xRailOffset);
    var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };
    if (i.isScrollbarYUsingRight) {
      if (i.isRtl) {
        yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth - 9;
      } else {
        yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
      }
    } else {
      if (i.isRtl) {
        yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
      } else {
        yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
      }
    }
    set(i.scrollbarYRail, yRailOffset);
    set(i.scrollbarX, {
      left: i.scrollbarXLeft,
      width: i.scrollbarXWidth - i.railBorderXWidth
    });
    set(i.scrollbarY, {
      top: i.scrollbarYTop,
      height: i.scrollbarYHeight - i.railBorderYWidth
    });
  }
  function clickRail(i) {
    var element = i.element;
    i.event.bind(i.scrollbarY, "mousedown", function(e2) {
      return e2.stopPropagation();
    });
    i.event.bind(i.scrollbarYRail, "mousedown", function(e2) {
      var positionTop = e2.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top;
      var direction = positionTop > i.scrollbarYTop ? 1 : -1;
      i.element.scrollTop += direction * i.containerHeight;
      updateGeometry(i);
      e2.stopPropagation();
    });
    i.event.bind(i.scrollbarX, "mousedown", function(e2) {
      return e2.stopPropagation();
    });
    i.event.bind(i.scrollbarXRail, "mousedown", function(e2) {
      var positionLeft = e2.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left;
      var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;
      i.element.scrollLeft += direction * i.containerWidth;
      updateGeometry(i);
      e2.stopPropagation();
    });
  }
  function dragThumb(i) {
    bindMouseScrollHandler(i, [
      "containerWidth",
      "contentWidth",
      "pageX",
      "railXWidth",
      "scrollbarX",
      "scrollbarXWidth",
      "scrollLeft",
      "x",
      "scrollbarXRail"
    ]);
    bindMouseScrollHandler(i, [
      "containerHeight",
      "contentHeight",
      "pageY",
      "railYHeight",
      "scrollbarY",
      "scrollbarYHeight",
      "scrollTop",
      "y",
      "scrollbarYRail"
    ]);
  }
  function bindMouseScrollHandler(i, ref) {
    var containerHeight = ref[0];
    var contentHeight = ref[1];
    var pageY = ref[2];
    var railYHeight = ref[3];
    var scrollbarY = ref[4];
    var scrollbarYHeight = ref[5];
    var scrollTop = ref[6];
    var y = ref[7];
    var scrollbarYRail = ref[8];
    var element = i.element;
    var startingScrollTop = null;
    var startingMousePageY = null;
    var scrollBy = null;
    function mouseMoveHandler(e2) {
      if (e2.touches && e2.touches[0]) {
        e2[pageY] = e2.touches[0].pageY;
      }
      element[scrollTop] = startingScrollTop + scrollBy * (e2[pageY] - startingMousePageY);
      addScrollingClass(i, y);
      updateGeometry(i);
      e2.stopPropagation();
      if (e2.type.startsWith("touch") && e2.changedTouches.length > 1) {
        e2.preventDefault();
      }
    }
    function mouseUpHandler() {
      removeScrollingClass(i, y);
      i[scrollbarYRail].classList.remove(cls.state.clicking);
      i.event.unbind(i.ownerDocument, "mousemove", mouseMoveHandler);
    }
    function bindMoves(e2, touchMode) {
      startingScrollTop = element[scrollTop];
      if (touchMode && e2.touches) {
        e2[pageY] = e2.touches[0].pageY;
      }
      startingMousePageY = e2[pageY];
      scrollBy = (i[contentHeight] - i[containerHeight]) / (i[railYHeight] - i[scrollbarYHeight]);
      if (!touchMode) {
        i.event.bind(i.ownerDocument, "mousemove", mouseMoveHandler);
        i.event.once(i.ownerDocument, "mouseup", mouseUpHandler);
        e2.preventDefault();
      } else {
        i.event.bind(i.ownerDocument, "touchmove", mouseMoveHandler);
      }
      i[scrollbarYRail].classList.add(cls.state.clicking);
      e2.stopPropagation();
    }
    i.event.bind(i[scrollbarY], "mousedown", function(e2) {
      bindMoves(e2);
    });
    i.event.bind(i[scrollbarY], "touchstart", function(e2) {
      bindMoves(e2, true);
    });
  }
  function keyboard(i) {
    var element = i.element;
    var elementHovered = function() {
      return matches(element, ":hover");
    };
    var scrollbarFocused = function() {
      return matches(i.scrollbarX, ":focus") || matches(i.scrollbarY, ":focus");
    };
    function shouldPreventDefault(deltaX, deltaY) {
      var scrollTop = Math.floor(element.scrollTop);
      if (deltaX === 0) {
        if (!i.scrollbarYActive) {
          return false;
        }
        if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
          return !i.settings.wheelPropagation;
        }
      }
      var scrollLeft = element.scrollLeft;
      if (deltaY === 0) {
        if (!i.scrollbarXActive) {
          return false;
        }
        if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
          return !i.settings.wheelPropagation;
        }
      }
      return true;
    }
    i.event.bind(i.ownerDocument, "keydown", function(e2) {
      if (e2.isDefaultPrevented && e2.isDefaultPrevented() || e2.defaultPrevented) {
        return;
      }
      if (!elementHovered() && !scrollbarFocused()) {
        return;
      }
      var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
      if (activeElement) {
        if (activeElement.tagName === "IFRAME") {
          activeElement = activeElement.contentDocument.activeElement;
        } else {
          while (activeElement.shadowRoot) {
            activeElement = activeElement.shadowRoot.activeElement;
          }
        }
        if (isEditable(activeElement)) {
          return;
        }
      }
      var deltaX = 0;
      var deltaY = 0;
      switch (e2.which) {
        case 37:
          if (e2.metaKey) {
            deltaX = -i.contentWidth;
          } else if (e2.altKey) {
            deltaX = -i.containerWidth;
          } else {
            deltaX = -30;
          }
          break;
        case 38:
          if (e2.metaKey) {
            deltaY = i.contentHeight;
          } else if (e2.altKey) {
            deltaY = i.containerHeight;
          } else {
            deltaY = 30;
          }
          break;
        case 39:
          if (e2.metaKey) {
            deltaX = i.contentWidth;
          } else if (e2.altKey) {
            deltaX = i.containerWidth;
          } else {
            deltaX = 30;
          }
          break;
        case 40:
          if (e2.metaKey) {
            deltaY = -i.contentHeight;
          } else if (e2.altKey) {
            deltaY = -i.containerHeight;
          } else {
            deltaY = -30;
          }
          break;
        case 32:
          if (e2.shiftKey) {
            deltaY = i.containerHeight;
          } else {
            deltaY = -i.containerHeight;
          }
          break;
        case 33:
          deltaY = i.containerHeight;
          break;
        case 34:
          deltaY = -i.containerHeight;
          break;
        case 36:
          deltaY = i.contentHeight;
          break;
        case 35:
          deltaY = -i.contentHeight;
          break;
        default:
          return;
      }
      if (i.settings.suppressScrollX && deltaX !== 0) {
        return;
      }
      if (i.settings.suppressScrollY && deltaY !== 0) {
        return;
      }
      element.scrollTop -= deltaY;
      element.scrollLeft += deltaX;
      updateGeometry(i);
      if (shouldPreventDefault(deltaX, deltaY)) {
        e2.preventDefault();
      }
    });
  }
  function wheel(i) {
    var element = i.element;
    function shouldPreventDefault(deltaX, deltaY) {
      var roundedScrollTop = Math.floor(element.scrollTop);
      var isTop = element.scrollTop === 0;
      var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
      var isLeft = element.scrollLeft === 0;
      var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
      var hitsBound;
      if (Math.abs(deltaY) > Math.abs(deltaX)) {
        hitsBound = isTop || isBottom;
      } else {
        hitsBound = isLeft || isRight;
      }
      return hitsBound ? !i.settings.wheelPropagation : true;
    }
    function getDeltaFromEvent(e2) {
      var deltaX = e2.deltaX;
      var deltaY = -1 * e2.deltaY;
      if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
        deltaX = -1 * e2.wheelDeltaX / 6;
        deltaY = e2.wheelDeltaY / 6;
      }
      if (e2.deltaMode && e2.deltaMode === 1) {
        deltaX *= 10;
        deltaY *= 10;
      }
      if (deltaX !== deltaX && deltaY !== deltaY) {
        deltaX = 0;
        deltaY = e2.wheelDelta;
      }
      if (e2.shiftKey) {
        return [-deltaY, -deltaX];
      }
      return [deltaX, deltaY];
    }
    function shouldBeConsumedByChild(target, deltaX, deltaY) {
      if (!env.isWebKit && element.querySelector("select:focus")) {
        return true;
      }
      if (!element.contains(target)) {
        return false;
      }
      var cursor = target;
      while (cursor && cursor !== element) {
        if (cursor.classList.contains(cls.element.consuming)) {
          return true;
        }
        var style = get(cursor);
        if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
          var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
          if (maxScrollTop > 0) {
            if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
              return true;
            }
          }
        }
        if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
          var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
          if (maxScrollLeft > 0) {
            if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
              return true;
            }
          }
        }
        cursor = cursor.parentNode;
      }
      return false;
    }
    function mousewheelHandler(e2) {
      var ref = getDeltaFromEvent(e2);
      var deltaX = ref[0];
      var deltaY = ref[1];
      if (shouldBeConsumedByChild(e2.target, deltaX, deltaY)) {
        return;
      }
      var shouldPrevent = false;
      if (!i.settings.useBothWheelAxes) {
        element.scrollTop -= deltaY * i.settings.wheelSpeed;
        element.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else if (i.scrollbarYActive && !i.scrollbarXActive) {
        if (deltaY) {
          element.scrollTop -= deltaY * i.settings.wheelSpeed;
        } else {
          element.scrollTop += deltaX * i.settings.wheelSpeed;
        }
        shouldPrevent = true;
      } else if (i.scrollbarXActive && !i.scrollbarYActive) {
        if (deltaX) {
          element.scrollLeft += deltaX * i.settings.wheelSpeed;
        } else {
          element.scrollLeft -= deltaY * i.settings.wheelSpeed;
        }
        shouldPrevent = true;
      }
      updateGeometry(i);
      shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
      if (shouldPrevent && !e2.ctrlKey) {
        e2.stopPropagation();
        e2.preventDefault();
      }
    }
    if (typeof window.onwheel !== "undefined") {
      i.event.bind(element, "wheel", mousewheelHandler);
    } else if (typeof window.onmousewheel !== "undefined") {
      i.event.bind(element, "mousewheel", mousewheelHandler);
    }
  }
  function touch(i) {
    if (!env.supportsTouch && !env.supportsIePointer) {
      return;
    }
    var element = i.element;
    function shouldPrevent(deltaX, deltaY) {
      var scrollTop = Math.floor(element.scrollTop);
      var scrollLeft = element.scrollLeft;
      var magnitudeX = Math.abs(deltaX);
      var magnitudeY = Math.abs(deltaY);
      if (magnitudeY > magnitudeX) {
        if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
          return window.scrollY === 0 && deltaY > 0 && env.isChrome;
        }
      } else if (magnitudeX > magnitudeY) {
        if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
          return true;
        }
      }
      return true;
    }
    function applyTouchMove(differenceX, differenceY) {
      element.scrollTop -= differenceY;
      element.scrollLeft -= differenceX;
      updateGeometry(i);
    }
    var startOffset = {};
    var startTime = 0;
    var speed = {};
    var easingLoop = null;
    function getTouch(e2) {
      if (e2.targetTouches) {
        return e2.targetTouches[0];
      } else {
        return e2;
      }
    }
    function shouldHandle(e2) {
      if (e2.pointerType && e2.pointerType === "pen" && e2.buttons === 0) {
        return false;
      }
      if (e2.targetTouches && e2.targetTouches.length === 1) {
        return true;
      }
      if (e2.pointerType && e2.pointerType !== "mouse" && e2.pointerType !== e2.MSPOINTER_TYPE_MOUSE) {
        return true;
      }
      return false;
    }
    function touchStart(e2) {
      if (!shouldHandle(e2)) {
        return;
      }
      var touch2 = getTouch(e2);
      startOffset.pageX = touch2.pageX;
      startOffset.pageY = touch2.pageY;
      startTime = new Date().getTime();
      if (easingLoop !== null) {
        clearInterval(easingLoop);
      }
    }
    function shouldBeConsumedByChild(target, deltaX, deltaY) {
      if (!element.contains(target)) {
        return false;
      }
      var cursor = target;
      while (cursor && cursor !== element) {
        if (cursor.classList.contains(cls.element.consuming)) {
          return true;
        }
        var style = get(cursor);
        if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
          var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
          if (maxScrollTop > 0) {
            if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
              return true;
            }
          }
        }
        if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
          var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
          if (maxScrollLeft > 0) {
            if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
              return true;
            }
          }
        }
        cursor = cursor.parentNode;
      }
      return false;
    }
    function touchMove(e2) {
      if (shouldHandle(e2)) {
        var touch2 = getTouch(e2);
        var currentOffset = { pageX: touch2.pageX, pageY: touch2.pageY };
        var differenceX = currentOffset.pageX - startOffset.pageX;
        var differenceY = currentOffset.pageY - startOffset.pageY;
        if (shouldBeConsumedByChild(e2.target, differenceX, differenceY)) {
          return;
        }
        applyTouchMove(differenceX, differenceY);
        startOffset = currentOffset;
        var currentTime = new Date().getTime();
        var timeGap = currentTime - startTime;
        if (timeGap > 0) {
          speed.x = differenceX / timeGap;
          speed.y = differenceY / timeGap;
          startTime = currentTime;
        }
        if (shouldPrevent(differenceX, differenceY)) {
          e2.preventDefault();
        }
      }
    }
    function touchEnd() {
      if (i.settings.swipeEasing) {
        clearInterval(easingLoop);
        easingLoop = setInterval(function() {
          if (i.isInitialized) {
            clearInterval(easingLoop);
            return;
          }
          if (!speed.x && !speed.y) {
            clearInterval(easingLoop);
            return;
          }
          if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
            clearInterval(easingLoop);
            return;
          }
          if (!i.element) {
            clearInterval(easingLoop);
            return;
          }
          applyTouchMove(speed.x * 30, speed.y * 30);
          speed.x *= 0.8;
          speed.y *= 0.8;
        }, 10);
      }
    }
    if (env.supportsTouch) {
      i.event.bind(element, "touchstart", touchStart);
      i.event.bind(element, "touchmove", touchMove);
      i.event.bind(element, "touchend", touchEnd);
    } else if (env.supportsIePointer) {
      if (window.PointerEvent) {
        i.event.bind(element, "pointerdown", touchStart);
        i.event.bind(element, "pointermove", touchMove);
        i.event.bind(element, "pointerup", touchEnd);
      } else if (window.MSPointerEvent) {
        i.event.bind(element, "MSPointerDown", touchStart);
        i.event.bind(element, "MSPointerMove", touchMove);
        i.event.bind(element, "MSPointerUp", touchEnd);
      }
    }
  }
  var defaultSettings = function() {
    return {
      handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
      maxScrollbarLength: null,
      minScrollbarLength: null,
      scrollingThreshold: 1e3,
      scrollXMarginOffset: 0,
      scrollYMarginOffset: 0,
      suppressScrollX: false,
      suppressScrollY: false,
      swipeEasing: true,
      useBothWheelAxes: false,
      wheelPropagation: true,
      wheelSpeed: 1
    };
  };
  var handlers = {
    "click-rail": clickRail,
    "drag-thumb": dragThumb,
    keyboard,
    wheel,
    touch
  };
  var PerfectScrollbar = function PerfectScrollbar2(element, userSettings) {
    var this$1 = this;
    if (userSettings === void 0)
      userSettings = {};
    if (typeof element === "string") {
      element = document.querySelector(element);
    }
    if (!element || !element.nodeName) {
      throw new Error("no element is specified to initialize PerfectScrollbar");
    }
    this.element = element;
    element.classList.add(cls.main);
    this.settings = defaultSettings();
    for (var key in userSettings) {
      this.settings[key] = userSettings[key];
    }
    this.containerWidth = null;
    this.containerHeight = null;
    this.contentWidth = null;
    this.contentHeight = null;
    var focus2 = function() {
      return element.classList.add(cls.state.focus);
    };
    var blur2 = function() {
      return element.classList.remove(cls.state.focus);
    };
    this.isRtl = get(element).direction === "rtl";
    if (this.isRtl === true) {
      element.classList.add(cls.rtl);
    }
    this.isNegativeScroll = function() {
      var originalScrollLeft = element.scrollLeft;
      var result = null;
      element.scrollLeft = -1;
      result = element.scrollLeft < 0;
      element.scrollLeft = originalScrollLeft;
      return result;
    }();
    this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
    this.event = new EventManager();
    this.ownerDocument = element.ownerDocument || document;
    this.scrollbarXRail = div(cls.element.rail("x"));
    element.appendChild(this.scrollbarXRail);
    this.scrollbarX = div(cls.element.thumb("x"));
    this.scrollbarXRail.appendChild(this.scrollbarX);
    this.scrollbarX.setAttribute("tabindex", 0);
    this.event.bind(this.scrollbarX, "focus", focus2);
    this.event.bind(this.scrollbarX, "blur", blur2);
    this.scrollbarXActive = null;
    this.scrollbarXWidth = null;
    this.scrollbarXLeft = null;
    var railXStyle = get(this.scrollbarXRail);
    this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
    if (isNaN(this.scrollbarXBottom)) {
      this.isScrollbarXUsingBottom = false;
      this.scrollbarXTop = toInt(railXStyle.top);
    } else {
      this.isScrollbarXUsingBottom = true;
    }
    this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
    set(this.scrollbarXRail, { display: "block" });
    this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
    set(this.scrollbarXRail, { display: "" });
    this.railXWidth = null;
    this.railXRatio = null;
    this.scrollbarYRail = div(cls.element.rail("y"));
    element.appendChild(this.scrollbarYRail);
    this.scrollbarY = div(cls.element.thumb("y"));
    this.scrollbarYRail.appendChild(this.scrollbarY);
    this.scrollbarY.setAttribute("tabindex", 0);
    this.event.bind(this.scrollbarY, "focus", focus2);
    this.event.bind(this.scrollbarY, "blur", blur2);
    this.scrollbarYActive = null;
    this.scrollbarYHeight = null;
    this.scrollbarYTop = null;
    var railYStyle = get(this.scrollbarYRail);
    this.scrollbarYRight = parseInt(railYStyle.right, 10);
    if (isNaN(this.scrollbarYRight)) {
      this.isScrollbarYUsingRight = false;
      this.scrollbarYLeft = toInt(railYStyle.left);
    } else {
      this.isScrollbarYUsingRight = true;
    }
    this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
    this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
    set(this.scrollbarYRail, { display: "block" });
    this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
    set(this.scrollbarYRail, { display: "" });
    this.railYHeight = null;
    this.railYRatio = null;
    this.reach = {
      x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
      y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
    };
    this.isAlive = true;
    this.settings.handlers.forEach(function(handlerName) {
      return handlers[handlerName](this$1);
    });
    this.lastScrollTop = Math.floor(element.scrollTop);
    this.lastScrollLeft = element.scrollLeft;
    this.event.bind(this.element, "scroll", function(e2) {
      return this$1.onScroll(e2);
    });
    updateGeometry(this);
  };
  PerfectScrollbar.prototype.update = function update() {
    if (!this.isAlive) {
      return;
    }
    this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
    set(this.scrollbarXRail, { display: "block" });
    set(this.scrollbarYRail, { display: "block" });
    this.railXMarginWidth = toInt(get(this.scrollbarXRail).marginLeft) + toInt(get(this.scrollbarXRail).marginRight);
    this.railYMarginHeight = toInt(get(this.scrollbarYRail).marginTop) + toInt(get(this.scrollbarYRail).marginBottom);
    set(this.scrollbarXRail, { display: "none" });
    set(this.scrollbarYRail, { display: "none" });
    updateGeometry(this);
    processScrollDiff(this, "top", 0, false, true);
    processScrollDiff(this, "left", 0, false, true);
    set(this.scrollbarXRail, { display: "" });
    set(this.scrollbarYRail, { display: "" });
  };
  PerfectScrollbar.prototype.onScroll = function onScroll(e2) {
    if (!this.isAlive) {
      return;
    }
    updateGeometry(this);
    processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
    processScrollDiff(this, "left", this.element.scrollLeft - this.lastScrollLeft);
    this.lastScrollTop = Math.floor(this.element.scrollTop);
    this.lastScrollLeft = this.element.scrollLeft;
  };
  PerfectScrollbar.prototype.destroy = function destroy() {
    if (!this.isAlive) {
      return;
    }
    this.event.unbindAll();
    remove(this.scrollbarX);
    remove(this.scrollbarY);
    remove(this.scrollbarXRail);
    remove(this.scrollbarYRail);
    this.removePsClasses();
    this.element = null;
    this.scrollbarX = null;
    this.scrollbarY = null;
    this.scrollbarXRail = null;
    this.scrollbarYRail = null;
    this.isAlive = false;
  };
  PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
    this.element.className = this.element.className.split(" ").filter(function(name) {
      return !name.match(/^ps([-_].+|)$/);
    }).join(" ");
  };
  var perfect_scrollbar_esm_default = PerfectScrollbar;

  // node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  var hasPassiveEvents = false;
  if (typeof window !== "undefined") {
    passiveTestOptions = {
      get passive() {
        hasPassiveEvents = true;
        return void 0;
      }
    };
    window.addEventListener("testPassive", null, passiveTestOptions);
    window.removeEventListener("testPassive", null, passiveTestOptions);
  }
  var passiveTestOptions;
  var isIosDevice = typeof window !== "undefined" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
  var locks = [];
  var documentListenerAdded = false;
  var initialClientY = -1;
  var previousBodyOverflowSetting = void 0;
  var previousBodyPaddingRight = void 0;
  var allowTouchMove = function allowTouchMove2(el) {
    return locks.some(function(lock) {
      if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
        return true;
      }
      return false;
    });
  };
  var preventDefault = function preventDefault2(rawEvent) {
    var e2 = rawEvent || window.event;
    if (allowTouchMove(e2.target)) {
      return true;
    }
    if (e2.touches.length > 1)
      return true;
    if (e2.preventDefault)
      e2.preventDefault();
    return false;
  };
  var setOverflowHidden = function setOverflowHidden2(options) {
    if (previousBodyPaddingRight === void 0) {
      var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;
      var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
      if (_reserveScrollBarGap && scrollBarGap > 0) {
        previousBodyPaddingRight = document.body.style.paddingRight;
        document.body.style.paddingRight = scrollBarGap + "px";
      }
    }
    if (previousBodyOverflowSetting === void 0) {
      previousBodyOverflowSetting = document.body.style.overflow;
      document.body.style.overflow = "hidden";
    }
  };
  var restoreOverflowSetting = function restoreOverflowSetting2() {
    if (previousBodyPaddingRight !== void 0) {
      document.body.style.paddingRight = previousBodyPaddingRight;
      previousBodyPaddingRight = void 0;
    }
    if (previousBodyOverflowSetting !== void 0) {
      document.body.style.overflow = previousBodyOverflowSetting;
      previousBodyOverflowSetting = void 0;
    }
  };
  var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled2(targetElement) {
    return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
  };
  var handleScroll = function handleScroll2(event2, targetElement) {
    var clientY = event2.targetTouches[0].clientY - initialClientY;
    if (allowTouchMove(event2.target)) {
      return false;
    }
    if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
      return preventDefault(event2);
    }
    if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
      return preventDefault(event2);
    }
    event2.stopPropagation();
    return true;
  };
  var disableBodyScroll = function disableBodyScroll2(targetElement, options) {
    if (!targetElement) {
      console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
      return;
    }
    if (locks.some(function(lock2) {
      return lock2.targetElement === targetElement;
    })) {
      return;
    }
    var lock = {
      targetElement,
      options: options || {}
    };
    locks = [].concat(_toConsumableArray(locks), [lock]);
    if (isIosDevice) {
      targetElement.ontouchstart = function(event2) {
        if (event2.targetTouches.length === 1) {
          initialClientY = event2.targetTouches[0].clientY;
        }
      };
      targetElement.ontouchmove = function(event2) {
        if (event2.targetTouches.length === 1) {
          handleScroll(event2, targetElement);
        }
      };
      if (!documentListenerAdded) {
        document.addEventListener("touchmove", preventDefault, hasPassiveEvents ? { passive: false } : void 0);
        documentListenerAdded = true;
      }
    } else {
      setOverflowHidden(options);
    }
  };
  var enableBodyScroll = function enableBodyScroll2(targetElement) {
    if (!targetElement) {
      console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
      return;
    }
    locks = locks.filter(function(lock) {
      return lock.targetElement !== targetElement;
    });
    if (isIosDevice) {
      targetElement.ontouchstart = null;
      targetElement.ontouchmove = null;
      if (documentListenerAdded && locks.length === 0) {
        document.removeEventListener("touchmove", preventDefault, hasPassiveEvents ? { passive: false } : void 0);
        documentListenerAdded = false;
      }
    } else if (!locks.length) {
      restoreOverflowSetting();
    }
  };

  // src/js/utils/cookie.js
  function getCookie(name) {
    const matches2 = document.cookie.match(new RegExp("(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") + "=([^;]*)"));
    return matches2 ? decodeURIComponent(matches2[1]) : void 0;
  }
  function setCookie(name, value2, options) {
    options = options || {
      path: "/",
      "max-age": 60 * 60 * 24 * 30
    };
    if (options.expires instanceof Date) {
      options.expires = options.expires.toUTCString();
    }
    let updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value2);
    for (const optionKey in options) {
      updatedCookie += "; " + optionKey;
      const optionValue = options[optionKey];
      if (optionValue !== true) {
        updatedCookie += "=" + optionValue;
      }
    }
    document.cookie = updatedCookie;
  }

  // src/components/popup/popup.js
  document.addEventListener("click", function(event2) {
    const link = event2.target.closest(".js-popup-btn");
    if (link) {
      event2.preventDefault();
      const href = link.getAttribute("href");
      const currentPopup = document.querySelector(href);
      showPopup(currentPopup, link, event2);
    }
  });
  function showPopup(popup, link, event2, isReload, locationLink) {
    const body = document.querySelector("body");
    if (window.innerWidth <= 1024) {
      const btns = document.querySelectorAll(".js-popup-btn"), popups = document.querySelectorAll(".js-popup"), popucContainerLock = popup.querySelector(".popup__container");
      const linkMobile = !!link && document.querySelector(`.mobile-menu__item[href="${link.getAttribute("href")}"]`);
      btns.forEach((el) => el !== link && el.classList.remove("is-open"));
      popups.forEach((el) => {
        if (el !== popup) {
          const lockContainerMobile = el.querySelector(".popup__container");
          el.classList.remove("is-show");
          enableBodyScroll(lockContainerMobile);
        }
      });
      !!link && link.classList.toggle("is-open");
      !!linkMobile && !link.classList.contains("mobile-menu__item") && linkMobile.classList.add("is-open");
      popup.classList.toggle("is-show");
      popup.classList.contains("is-show") ? body.classList.add("overflow") : body.classList.remove("overflow");
      if (!!link && !!link.classList.contains("is-open")) {
        disableBodyScroll(popucContainerLock);
      } else {
        !!link && !!link.classList.contains("mobile-menu__item") && enableBodyScroll(popucContainerLock);
      }
    } else {
      const scrollBarWidth = window.innerWidth - document.body.clientWidth;
      popup.classList.add("is-show");
      if (!scrollBarWidth) {
        document.body.style = `padding-right:${scrollBarWidth}px;`;
      }
      body.classList.add("overflow");
    }
    const popupGeoCityList = document.querySelector(".geo-popup__city-list");
    const popupGeoHtml = !!popupGeoCityList && popupGeoCityList.innerHTML;
    document.addEventListener("click", (e2) => {
      const bg = e2.target.closest(".popup");
      const popupContainer = e2.target.closest(".js-popup .popup__container");
      const closeButton = e2.target.closest(".js-popup-close");
      const toggleButton = e2.target.closest(".js-popup-btn");
      const popucContainerLock = popup.querySelector(".popup__container");
      if (!popupContainer && bg || closeButton) {
        isReload && location.reload();
        !!locationLink && (location.href = locationLink);
        const popupMobileCatalog = popup.getAttribute("id") === "mobile-menu-detail";
        const popupGeo = popup.getAttribute("id") === "geo-popup";
        popup.classList.remove("is-show");
        !popupMobileCatalog && body.classList.remove("overflow");
        !!link && link.classList.remove("is-open");
        const linkMobile = !!link && document.querySelector(`.mobile-menu__item[href="${link.getAttribute("href")}"]`);
        const popupForm = popup.querySelector("form");
        !!popupForm && popupForm.reset();
        if (!!popupGeo) {
          const searchInput3 = popup.querySelector(".geo-popup__search-input");
          searchInput3.value = "";
          popupGeoCityList.innerHTML = popupGeoHtml;
          const selectCity = document.querySelector(`.geo-popup__city-item-input[value="${getCookie("city")}"]`);
          if (!!selectCity) {
            selectCity.checked = true;
          } else {
            if (getCookie("city")) {
              const cityInputNew = document.querySelector(`.geo-popup__city-item-input#city-00`);
              const cityInputNewParent = !!cityInputNew && cityInputNew.parentElement;
              !!cityInputNewParent && cityInputNewParent.remove();
              const popupGeoItemHtml = `<li class="geo-popup__city-item">
            <input class="geo-popup__city-item-input" type="radio" id="city-00" name="city" value="${getCookie("city")}" checked>
            <label class="geo-popup__city-item-label" for="city-00"><span>${getCookie("city")}</span></label>
          </li>`;
              popupGeoCityList.insertAdjacentHTML("afterbegin", popupGeoItemHtml);
            }
          }
        }
        !popupMobileCatalog && enableBodyScroll(popucContainerLock);
        if (!popupMobileCatalog) {
          document.body.style = "";
        }
        !!linkMobile && !!linkMobile.classList.contains("is-open") && linkMobile.classList.remove("is-open");
      }
    });
  }
  window.showPopups = function(newPopup) {
    const popupToShow = document.querySelector(`${newPopup}`);
    showPopup(popupToShow);
  };

  // src/components/header/header.js
  var menuItemLink = document.querySelectorAll(".js-menu-item-link");
  var cartPopup = document.querySelector(".cart-popup");
  var cartPopupInner = document.querySelector(".cart-popup__inner");
  var cartBtn = document.querySelector(".header__nav-item--cart");
  var cartPopupBody = document.querySelector(".cart-popup__body");
  var cartPopurTitle = document.querySelector(".cart-popup__count");
  var cartPopupSumm = document.querySelector(".cart-popup__summary");
  var cartPopupClearBtn = document.querySelector(".cart-popup__clear-cart");
  var headerCounter = document.querySelectorAll(".js-header-cart-count");
  var cartPopupFooter = document.querySelector(".cart-popup__footer");
  var popupProductLimit = document.querySelector("#product-limit");
  var popupBasketLimit = document.querySelector("#basket-limit");
  var cartPopupEl = document.querySelector(".cart-popup__wrap");
  var cartPopupLoader = `<div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`;
  window.innerWidth >= 1024 && menuItemLink.length && menuItemLink.forEach((link) => {
    if (location.pathname === link.getAttribute("href")) {
      link.classList.add("is-active");
    }
  });
  var cartPopupScroll = !!cartPopupEl && new perfect_scrollbar_esm_default(cartPopupEl, {
    wheelSpeed: 2,
    wheelPropagation: false,
    minScrollbarLength: 20
  });
  function getBasketRequest() {
    !document.querySelector(".lds-ring-mob-wrap") && cartPopup.insertAdjacentHTML("beforeend", cartPopupLoader);
    import_axios.default.get(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=getSmallBasket`).then(function(response) {
      const cartNoProduct = cartPopup.querySelector(".cart-popup__no-product");
      if (response.data.data) {
        let htmlArr = [];
        for (let key in response.data.data.ITEMS) {
          htmlArr.push(response.data.data.ITEMS[key]);
        }
        cartPopup.querySelectorAll("button").forEach((button) => {
          button.removeAttribute("disabled");
        });
        !!cartNoProduct && cartNoProduct.remove();
        cartPopupInner.classList.remove("is-hide");
        cartPopurTitle.textContent = response.data.data.COUNT;
        cartPopupSumm.innerHTML = `${valueToLocalString(response.data.data.SUMM)} <span class="cart-popup__summary-currency">\u20BD</span>`;
        cartPopupBody.innerHTML = htmlArr.map((el) => `<div class="cart-popup__item" data-id="${el.ID}">
                    <a href="${el.PRODUCT.DETAIL_PAGE_URL}" class="cart-popup__item-image"><img src="${el.PRODUCT.IMG}" alt="${el.PRODUCT.NAME}"></a>
                    <div class="cart-popup__item-body">
                        <div class="cart-popup__item-head">
                            <a href="${el.PRODUCT.DETAIL_PAGE_URL}" class="cart-popup__item-title">${el.PRODUCT.NAME}</a>
                            <button class="cart-popup__item-delete-btn" type="submit">
                                <svg class="icon " width="18" height="21">
                                    <use xlink:href="/local/templates/DoBuy/assets/images/sprite.svg#trash"></use>
                                </svg>
                            </button>
                        </div>
                        <div class="cart-popup__item-bottom">
                            <div class="cart-popup__item-bottom-counter">
                                <button class="cart-popup__item-bottom-counter-decr" ${el.QUANTITY <= 1 ? "disabled" : ""}>-</button><span
                                    class="cart-popup__item-bottom-counter-count">${el.QUANTITY}</span>
                                <button class="cart-popup__item-bottom-counter-incr"  ${el.QUANTITY >= 3 ? "disabled" : ""}>+</button>
                            </div>
                            <div class="cart-popup__item-bottom-summ">
                                <div class="cart-popup__item-price"><span>${valueToLocalString(el.PRICE)} <span
                                            class="cart-popup__item-currency"> \u20BD</span></span></div>
                                ${el.DISCOUNT === "Y" ? `<div class="cart-popup__item-old-price"><span                                class="card-product__price--old cart-popup__item-price--old">${valueToLocalString(el.BASE_PRICE)} \u20BD</span><span                                  class="cart-popup__item-discount card-stock__tag tag-yellow">-${el.PERCENT}%</span></div>` : ""}
                            </div>
                        </div>
                    </div>
                </div>`).join("");
        !!cartPopupInner && cartPopupInner.classList.remove("is-hide");
      } else {
        !!cartNoProduct && cartNoProduct.remove();
        if (!!cartPopupBody) {
          cartPopupBody.innerHTML = "";
        }
        const smallCartCount = document.querySelector(".cart-popup__item-bottom-counter-count");
        cartPopupInner.classList.add("is-hide");
        cartPopup.insertAdjacentHTML("beforeend", '<p class="cart-popup__no-product">\u0412\u0430\u0448\u0430 \u043A\u043E\u0440\u0437\u0438\u043D\u0430 \u043F\u0443\u0441\u0442\u0430</p>');
        if (!!smallCartCount) {
          smallCartCount.textContent = 0;
        }
      }
      let loader2 = cartPopup.querySelector(".lds-ring-mob-wrap");
      !!loader2 && loader2.remove();
      const basketSmallCounters = document.querySelectorAll(".cart-popup__item-bottom-counter-count");
      const basketSmallCountersSumm = basketSmallCounters.length > 0 && [...basketSmallCounters].map((el) => Number(el.textContent)).reduce(function(a, b) {
        return a + b;
      });
      if (headerCounter.length) {
        headerCounter.forEach((cout) => cout.textContent = basketSmallCountersSumm ? basketSmallCountersSumm : 0);
      }
      !!cartPopupScroll && cartPopupScroll.update();
    }).catch(function(error) {
      let loader2 = cartPopup.querySelector(".lds-ring-mob-wrap");
      !!loader2 && loader2.remove();
    });
  }
  function requestGetProductsBasket(id, urlParams) {
    let urlParam;
    switch (urlParams) {
      case "addItemToBasket":
        urlParam = "addItemToBasket";
        break;
      case "deleteItemFromBasket":
        urlParam = "deleteItemFromBasket";
        break;
      case "quantity":
        urlParam = "deleteItemFromBasket&quantity=all";
        break;
      default:
        urlParam = `clearBasket`;
    }
    const data = { productId: id };
    let form_data = new FormData();
    for (let key in data) {
      form_data.append(key, data[key]);
    }
    const cardsProductBtns = document.querySelectorAll(".js-product-cart-btn");
    import_axios.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=${urlParam}`, form_data).then(function(response) {
      const { data: data2 } = response;
      if (data2.data === "products_limit") {
        showPopup(popupProductLimit);
      } else if (data2.data === "basket_limit") {
        showPopup(popupBasketLimit);
      } else {
        getBasketRequest();
        let loader2 = cartPopup.querySelector(".lds-ring-mob-wrap");
        !!loader2 && loader2.remove();
        if (urlParam === `clearBasket`) {
          cardsProductBtns.length > 0 && cardsProductBtns.forEach((btn) => btn.classList.remove("is-active"));
          if (headerCounter.length) {
            headerCounter.forEach((count) => count.textContent = "0");
          }
        }
        if (urlParam === "deleteItemFromBasket&quantity=all") {
          const cardProductBtn = document.querySelectorAll(`.js-product-cart-btn[data-id="${id}"]`);
          !!cardProductBtn.length && cardProductBtn.forEach((btn) => btn.classList.remove("is-active"));
        }
      }
    }).catch(function(error) {
      let loader2 = cartPopup.querySelector(".lds-ring-mob-wrap");
      !!loader2 && loader2.remove();
    });
  }
  !!cartBtn && cartBtn.addEventListener("click", (event2, args) => {
    event2.preventDefault();
    !!cartPopupInner && cartPopupInner.classList.add("is-hide");
    getBasketRequest();
    const isJs = cartBtn.getAttribute("data-is-js");
    if (cartPopup.classList.contains("hidden")) {
      cartPopup.classList.remove("hidden");
      document.addEventListener("click", closeCartPopup);
    } else {
      if (!isJs) {
        cartPopup.classList.add("hidden");
        document.removeEventListener("click", closeCartPopup);
      }
    }
    cartBtn.removeAttribute("data-is-js");
  });
  document.addEventListener("click", (e2) => {
    const cartPopupItem = e2.target.closest(".cart-popup__item");
    const cartPopupBtnDecr = e2.target.closest(".cart-popup__item-bottom-counter-decr");
    const cartPopupBtnIncr = e2.target.closest(".cart-popup__item-bottom-counter-incr");
    const cartPopupBtnDel = e2.target.closest(".cart-popup__item-delete-btn");
    const cartPopupOrderBtn = e2.target.closest(".cart-popup__footer-submit-btn");
    function requestOnClickToSmallCart(cartButton, urlParam) {
      if (cartPopupItem && cartButton) {
        const id = cartPopupItem.getAttribute("data-id");
        requestGetProductsBasket(id, urlParam);
        cartPopup.insertAdjacentHTML("beforeend", cartPopupLoader);
        cartPopup.querySelectorAll("button").forEach((button) => {
          button.setAttribute("disabled", "");
        });
      }
    }
    ;
    requestOnClickToSmallCart(cartPopupBtnIncr, "addItemToBasket");
    requestOnClickToSmallCart(cartPopupBtnDecr, "deleteItemFromBasket");
    requestOnClickToSmallCart(cartPopupBtnDel, "quantity");
    if (cartPopupOrderBtn) {
      e2.preventDefault();
      const cartProduct = document.querySelectorAll(".cart-popup .cart-popup__item");
      const cartProductId = cartProduct.length && [...cartProduct].map((item) => item.getAttribute("data-id"));
      const form_data = new FormData();
      cartProductId.forEach((item) => {
        form_data.append("product_id_list[]", item);
      });
      cartPopup.insertAdjacentHTML("beforeend", cartPopupLoader);
      cartPopup.querySelectorAll("button").forEach((button) => {
        button.setAttribute("disabled", "");
      });
      import_axios.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=setBasketOrder`, form_data).then(function(response) {
        const loader2 = cartPopup.querySelector(".lds-ring-mob-wrap");
        !!loader2 && loader2.remove();
        window.location.href = "/order";
      }).catch(function(error) {
        const loader2 = cartPopup.querySelector(".lds-ring-mob-wrap");
        !!loader2 && loader2.remove();
      });
    }
  });
  !!cartPopupClearBtn && cartPopupClearBtn.addEventListener("click", (e2) => {
    requestGetProductsBasket();
  });
  var closeCartPopup = (event2) => {
    if (!event2.target.closest(".cart-popup") && !event2.target.closest(".header__nav-item--cart")) {
      cartPopup.classList.add("hidden");
    }
  };

  // src/components/header/catalog-popup/catalog-popup.js
  var import_debounce = __toModule(require_debounce());

  // node_modules/ssr-window/ssr-window.esm.js
  function isObject(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
  }
  function extend(target = {}, src = {}) {
    Object.keys(src).forEach((key) => {
      if (typeof target[key] === "undefined")
        target[key] = src[key];
      else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
        extend(target[key], src[key]);
      }
    });
  }
  var ssrDocument = {
    body: {},
    addEventListener() {
    },
    removeEventListener() {
    },
    activeElement: {
      blur() {
      },
      nodeName: ""
    },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return {
        initEvent() {
        }
      };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {
        },
        getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function getDocument() {
    const doc = typeof document !== "undefined" ? document : {};
    extend(doc, ssrDocument);
    return doc;
  }
  var ssrWindow = {
    document: ssrDocument,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {
      },
      pushState() {
      },
      go() {
      },
      back() {
      }
    },
    CustomEvent: function CustomEvent2() {
      return this;
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        }
      };
    },
    Image() {
    },
    Date() {
    },
    screen: {},
    setTimeout() {
    },
    clearTimeout() {
    },
    matchMedia() {
      return {};
    },
    requestAnimationFrame(callback) {
      if (typeof setTimeout === "undefined") {
        callback();
        return null;
      }
      return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
      if (typeof setTimeout === "undefined") {
        return;
      }
      clearTimeout(id);
    }
  };
  function getWindow() {
    const win = typeof window !== "undefined" ? window : {};
    extend(win, ssrWindow);
    return win;
  }

  // node_modules/dom7/dom7.esm.js
  function makeReactive(obj) {
    const proto = obj.__proto__;
    Object.defineProperty(obj, "__proto__", {
      get() {
        return proto;
      },
      set(value2) {
        proto.__proto__ = value2;
      }
    });
  }
  var Dom7 = class extends Array {
    constructor(items) {
      if (typeof items === "number") {
        super(items);
      } else {
        super(...items || []);
        makeReactive(this);
      }
    }
  };
  function arrayFlat(arr = []) {
    const res = [];
    arr.forEach((el) => {
      if (Array.isArray(el)) {
        res.push(...arrayFlat(el));
      } else {
        res.push(el);
      }
    });
    return res;
  }
  function arrayFilter(arr, callback) {
    return Array.prototype.filter.call(arr, callback);
  }
  function arrayUnique(arr) {
    const uniqueArray = [];
    for (let i = 0; i < arr.length; i += 1) {
      if (uniqueArray.indexOf(arr[i]) === -1)
        uniqueArray.push(arr[i]);
    }
    return uniqueArray;
  }
  function qsa(selector, context) {
    if (typeof selector !== "string") {
      return [selector];
    }
    const a = [];
    const res = context.querySelectorAll(selector);
    for (let i = 0; i < res.length; i += 1) {
      a.push(res[i]);
    }
    return a;
  }
  function $(selector, context) {
    const window2 = getWindow();
    const document2 = getDocument();
    let arr = [];
    if (!context && selector instanceof Dom7) {
      return selector;
    }
    if (!selector) {
      return new Dom7(arr);
    }
    if (typeof selector === "string") {
      const html2 = selector.trim();
      if (html2.indexOf("<") >= 0 && html2.indexOf(">") >= 0) {
        let toCreate = "div";
        if (html2.indexOf("<li") === 0)
          toCreate = "ul";
        if (html2.indexOf("<tr") === 0)
          toCreate = "tbody";
        if (html2.indexOf("<td") === 0 || html2.indexOf("<th") === 0)
          toCreate = "tr";
        if (html2.indexOf("<tbody") === 0)
          toCreate = "table";
        if (html2.indexOf("<option") === 0)
          toCreate = "select";
        const tempParent = document2.createElement(toCreate);
        tempParent.innerHTML = html2;
        for (let i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        arr = qsa(selector.trim(), context || document2);
      }
    } else if (selector.nodeType || selector === window2 || selector === document2) {
      arr.push(selector);
    } else if (Array.isArray(selector)) {
      if (selector instanceof Dom7)
        return selector;
      arr = selector;
    }
    return new Dom7(arrayUnique(arr));
  }
  $.fn = Dom7.prototype;
  function addClass(...classes) {
    const classNames = arrayFlat(classes.map((c) => c.split(" ")));
    this.forEach((el) => {
      el.classList.add(...classNames);
    });
    return this;
  }
  function removeClass(...classes) {
    const classNames = arrayFlat(classes.map((c) => c.split(" ")));
    this.forEach((el) => {
      el.classList.remove(...classNames);
    });
    return this;
  }
  function toggleClass(...classes) {
    const classNames = arrayFlat(classes.map((c) => c.split(" ")));
    this.forEach((el) => {
      classNames.forEach((className) => {
        el.classList.toggle(className);
      });
    });
  }
  function hasClass(...classes) {
    const classNames = arrayFlat(classes.map((c) => c.split(" ")));
    return arrayFilter(this, (el) => {
      return classNames.filter((className) => el.classList.contains(className)).length > 0;
    }).length > 0;
  }
  function attr(attrs, value2) {
    if (arguments.length === 1 && typeof attrs === "string") {
      if (this[0])
        return this[0].getAttribute(attrs);
      return void 0;
    }
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        this[i].setAttribute(attrs, value2);
      } else {
        for (const attrName in attrs) {
          this[i][attrName] = attrs[attrName];
          this[i].setAttribute(attrName, attrs[attrName]);
        }
      }
    }
    return this;
  }
  function removeAttr(attr2) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].removeAttribute(attr2);
    }
    return this;
  }
  function transform(transform2) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].style.transform = transform2;
    }
    return this;
  }
  function transition(duration) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].style.transitionDuration = typeof duration !== "string" ? `${duration}ms` : duration;
    }
    return this;
  }
  function on(...args) {
    let [eventType, targetSelector, listener, capture] = args;
    if (typeof args[1] === "function") {
      [eventType, listener, capture] = args;
      targetSelector = void 0;
    }
    if (!capture)
      capture = false;
    function handleLiveEvent(e2) {
      const target = e2.target;
      if (!target)
        return;
      const eventData = e2.target.dom7EventData || [];
      if (eventData.indexOf(e2) < 0) {
        eventData.unshift(e2);
      }
      if ($(target).is(targetSelector))
        listener.apply(target, eventData);
      else {
        const parents2 = $(target).parents();
        for (let k = 0; k < parents2.length; k += 1) {
          if ($(parents2[k]).is(targetSelector))
            listener.apply(parents2[k], eventData);
        }
      }
    }
    function handleEvent(e2) {
      const eventData = e2 && e2.target ? e2.target.dom7EventData || [] : [];
      if (eventData.indexOf(e2) < 0) {
        eventData.unshift(e2);
      }
      listener.apply(this, eventData);
    }
    const events2 = eventType.split(" ");
    let j;
    for (let i = 0; i < this.length; i += 1) {
      const el = this[i];
      if (!targetSelector) {
        for (j = 0; j < events2.length; j += 1) {
          const event2 = events2[j];
          if (!el.dom7Listeners)
            el.dom7Listeners = {};
          if (!el.dom7Listeners[event2])
            el.dom7Listeners[event2] = [];
          el.dom7Listeners[event2].push({
            listener,
            proxyListener: handleEvent
          });
          el.addEventListener(event2, handleEvent, capture);
        }
      } else {
        for (j = 0; j < events2.length; j += 1) {
          const event2 = events2[j];
          if (!el.dom7LiveListeners)
            el.dom7LiveListeners = {};
          if (!el.dom7LiveListeners[event2])
            el.dom7LiveListeners[event2] = [];
          el.dom7LiveListeners[event2].push({
            listener,
            proxyListener: handleLiveEvent
          });
          el.addEventListener(event2, handleLiveEvent, capture);
        }
      }
    }
    return this;
  }
  function off(...args) {
    let [eventType, targetSelector, listener, capture] = args;
    if (typeof args[1] === "function") {
      [eventType, listener, capture] = args;
      targetSelector = void 0;
    }
    if (!capture)
      capture = false;
    const events2 = eventType.split(" ");
    for (let i = 0; i < events2.length; i += 1) {
      const event2 = events2[i];
      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];
        let handlers2;
        if (!targetSelector && el.dom7Listeners) {
          handlers2 = el.dom7Listeners[event2];
        } else if (targetSelector && el.dom7LiveListeners) {
          handlers2 = el.dom7LiveListeners[event2];
        }
        if (handlers2 && handlers2.length) {
          for (let k = handlers2.length - 1; k >= 0; k -= 1) {
            const handler = handlers2[k];
            if (listener && handler.listener === listener) {
              el.removeEventListener(event2, handler.proxyListener, capture);
              handlers2.splice(k, 1);
            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
              el.removeEventListener(event2, handler.proxyListener, capture);
              handlers2.splice(k, 1);
            } else if (!listener) {
              el.removeEventListener(event2, handler.proxyListener, capture);
              handlers2.splice(k, 1);
            }
          }
        }
      }
    }
    return this;
  }
  function trigger(...args) {
    const window2 = getWindow();
    const events2 = args[0].split(" ");
    const eventData = args[1];
    for (let i = 0; i < events2.length; i += 1) {
      const event2 = events2[i];
      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];
        if (window2.CustomEvent) {
          const evt = new window2.CustomEvent(event2, {
            detail: eventData,
            bubbles: true,
            cancelable: true
          });
          el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
          el.dispatchEvent(evt);
          el.dom7EventData = [];
          delete el.dom7EventData;
        }
      }
    }
    return this;
  }
  function transitionEnd(callback) {
    const dom = this;
    function fireCallBack(e2) {
      if (e2.target !== this)
        return;
      callback.call(this, e2);
      dom.off("transitionend", fireCallBack);
    }
    if (callback) {
      dom.on("transitionend", fireCallBack);
    }
    return this;
  }
  function outerWidth2(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles2 = this.styles();
        return this[0].offsetWidth + parseFloat(styles2.getPropertyValue("margin-right")) + parseFloat(styles2.getPropertyValue("margin-left"));
      }
      return this[0].offsetWidth;
    }
    return null;
  }
  function outerHeight(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles2 = this.styles();
        return this[0].offsetHeight + parseFloat(styles2.getPropertyValue("margin-top")) + parseFloat(styles2.getPropertyValue("margin-bottom"));
      }
      return this[0].offsetHeight;
    }
    return null;
  }
  function offset() {
    if (this.length > 0) {
      const window2 = getWindow();
      const document2 = getDocument();
      const el = this[0];
      const box = el.getBoundingClientRect();
      const body = document2.body;
      const clientTop = el.clientTop || body.clientTop || 0;
      const clientLeft = el.clientLeft || body.clientLeft || 0;
      const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
      const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
      return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
      };
    }
    return null;
  }
  function styles() {
    const window2 = getWindow();
    if (this[0])
      return window2.getComputedStyle(this[0], null);
    return {};
  }
  function css(props, value2) {
    const window2 = getWindow();
    let i;
    if (arguments.length === 1) {
      if (typeof props === "string") {
        if (this[0])
          return window2.getComputedStyle(this[0], null).getPropertyValue(props);
      } else {
        for (i = 0; i < this.length; i += 1) {
          for (const prop in props) {
            this[i].style[prop] = props[prop];
          }
        }
        return this;
      }
    }
    if (arguments.length === 2 && typeof props === "string") {
      for (i = 0; i < this.length; i += 1) {
        this[i].style[props] = value2;
      }
      return this;
    }
    return this;
  }
  function each(callback) {
    if (!callback)
      return this;
    this.forEach((el, index2) => {
      callback.apply(el, [el, index2]);
    });
    return this;
  }
  function filter(callback) {
    const result = arrayFilter(this, callback);
    return $(result);
  }
  function html(html2) {
    if (typeof html2 === "undefined") {
      return this[0] ? this[0].innerHTML : null;
    }
    for (let i = 0; i < this.length; i += 1) {
      this[i].innerHTML = html2;
    }
    return this;
  }
  function text(text2) {
    if (typeof text2 === "undefined") {
      return this[0] ? this[0].textContent.trim() : null;
    }
    for (let i = 0; i < this.length; i += 1) {
      this[i].textContent = text2;
    }
    return this;
  }
  function is(selector) {
    const window2 = getWindow();
    const document2 = getDocument();
    const el = this[0];
    let compareWith;
    let i;
    if (!el || typeof selector === "undefined")
      return false;
    if (typeof selector === "string") {
      if (el.matches)
        return el.matches(selector);
      if (el.webkitMatchesSelector)
        return el.webkitMatchesSelector(selector);
      if (el.msMatchesSelector)
        return el.msMatchesSelector(selector);
      compareWith = $(selector);
      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el)
          return true;
      }
      return false;
    }
    if (selector === document2) {
      return el === document2;
    }
    if (selector === window2) {
      return el === window2;
    }
    if (selector.nodeType || selector instanceof Dom7) {
      compareWith = selector.nodeType ? [selector] : selector;
      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el)
          return true;
      }
      return false;
    }
    return false;
  }
  function index() {
    let child = this[0];
    let i;
    if (child) {
      i = 0;
      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1)
          i += 1;
      }
      return i;
    }
    return void 0;
  }
  function eq(index2) {
    if (typeof index2 === "undefined")
      return this;
    const length = this.length;
    if (index2 > length - 1) {
      return $([]);
    }
    if (index2 < 0) {
      const returnIndex = length + index2;
      if (returnIndex < 0)
        return $([]);
      return $([this[returnIndex]]);
    }
    return $([this[index2]]);
  }
  function append(...els) {
    let newChild;
    const document2 = getDocument();
    for (let k = 0; k < els.length; k += 1) {
      newChild = els[k];
      for (let i = 0; i < this.length; i += 1) {
        if (typeof newChild === "string") {
          const tempDiv = document2.createElement("div");
          tempDiv.innerHTML = newChild;
          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom7) {
          for (let j = 0; j < newChild.length; j += 1) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }
    }
    return this;
  }
  function prepend(newChild) {
    const document2 = getDocument();
    let i;
    let j;
    for (i = 0; i < this.length; i += 1) {
      if (typeof newChild === "string") {
        const tempDiv = document2.createElement("div");
        tempDiv.innerHTML = newChild;
        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
        }
      } else if (newChild instanceof Dom7) {
        for (j = 0; j < newChild.length; j += 1) {
          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
        }
      } else {
        this[i].insertBefore(newChild, this[i].childNodes[0]);
      }
    }
    return this;
  }
  function next(selector) {
    if (this.length > 0) {
      if (selector) {
        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
          return $([this[0].nextElementSibling]);
        }
        return $([]);
      }
      if (this[0].nextElementSibling)
        return $([this[0].nextElementSibling]);
      return $([]);
    }
    return $([]);
  }
  function nextAll(selector) {
    const nextEls = [];
    let el = this[0];
    if (!el)
      return $([]);
    while (el.nextElementSibling) {
      const next2 = el.nextElementSibling;
      if (selector) {
        if ($(next2).is(selector))
          nextEls.push(next2);
      } else
        nextEls.push(next2);
      el = next2;
    }
    return $(nextEls);
  }
  function prev(selector) {
    if (this.length > 0) {
      const el = this[0];
      if (selector) {
        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
          return $([el.previousElementSibling]);
        }
        return $([]);
      }
      if (el.previousElementSibling)
        return $([el.previousElementSibling]);
      return $([]);
    }
    return $([]);
  }
  function prevAll(selector) {
    const prevEls = [];
    let el = this[0];
    if (!el)
      return $([]);
    while (el.previousElementSibling) {
      const prev2 = el.previousElementSibling;
      if (selector) {
        if ($(prev2).is(selector))
          prevEls.push(prev2);
      } else
        prevEls.push(prev2);
      el = prev2;
    }
    return $(prevEls);
  }
  function parent(selector) {
    const parents2 = [];
    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode !== null) {
        if (selector) {
          if ($(this[i].parentNode).is(selector))
            parents2.push(this[i].parentNode);
        } else {
          parents2.push(this[i].parentNode);
        }
      }
    }
    return $(parents2);
  }
  function parents(selector) {
    const parents2 = [];
    for (let i = 0; i < this.length; i += 1) {
      let parent2 = this[i].parentNode;
      while (parent2) {
        if (selector) {
          if ($(parent2).is(selector))
            parents2.push(parent2);
        } else {
          parents2.push(parent2);
        }
        parent2 = parent2.parentNode;
      }
    }
    return $(parents2);
  }
  function closest(selector) {
    let closest2 = this;
    if (typeof selector === "undefined") {
      return $([]);
    }
    if (!closest2.is(selector)) {
      closest2 = closest2.parents(selector).eq(0);
    }
    return closest2;
  }
  function find(selector) {
    const foundElements = [];
    for (let i = 0; i < this.length; i += 1) {
      const found = this[i].querySelectorAll(selector);
      for (let j = 0; j < found.length; j += 1) {
        foundElements.push(found[j]);
      }
    }
    return $(foundElements);
  }
  function children(selector) {
    const children2 = [];
    for (let i = 0; i < this.length; i += 1) {
      const childNodes = this[i].children;
      for (let j = 0; j < childNodes.length; j += 1) {
        if (!selector || $(childNodes[j]).is(selector)) {
          children2.push(childNodes[j]);
        }
      }
    }
    return $(children2);
  }
  function remove2() {
    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode)
        this[i].parentNode.removeChild(this[i]);
    }
    return this;
  }
  var noTrigger = "resize scroll".split(" ");
  function shortcut(name) {
    function eventHandler(...args) {
      if (typeof args[0] === "undefined") {
        for (let i = 0; i < this.length; i += 1) {
          if (noTrigger.indexOf(name) < 0) {
            if (name in this[i])
              this[i][name]();
            else {
              $(this[i]).trigger(name);
            }
          }
        }
        return this;
      }
      return this.on(name, ...args);
    }
    return eventHandler;
  }
  var click = shortcut("click");
  var blur = shortcut("blur");
  var focus = shortcut("focus");
  var focusin = shortcut("focusin");
  var focusout = shortcut("focusout");
  var keyup = shortcut("keyup");
  var keydown = shortcut("keydown");
  var keypress = shortcut("keypress");
  var submit = shortcut("submit");
  var change = shortcut("change");
  var mousedown = shortcut("mousedown");
  var mousemove = shortcut("mousemove");
  var mouseup = shortcut("mouseup");
  var mouseenter = shortcut("mouseenter");
  var mouseleave = shortcut("mouseleave");
  var mouseout = shortcut("mouseout");
  var mouseover = shortcut("mouseover");
  var touchstart = shortcut("touchstart");
  var touchend = shortcut("touchend");
  var touchmove = shortcut("touchmove");
  var resize = shortcut("resize");
  var scroll = shortcut("scroll");

  // node_modules/swiper/shared/dom.js
  var Methods = {
    addClass,
    removeClass,
    hasClass,
    toggleClass,
    attr,
    removeAttr,
    transform,
    transition,
    on,
    off,
    trigger,
    transitionEnd,
    outerWidth: outerWidth2,
    outerHeight,
    styles,
    offset,
    css,
    each,
    html,
    text,
    is,
    index,
    eq,
    append,
    prepend,
    next,
    nextAll,
    prev,
    prevAll,
    parent,
    parents,
    closest,
    find,
    children,
    filter,
    remove: remove2
  };
  Object.keys(Methods).forEach((methodName) => {
    Object.defineProperty($.fn, methodName, {
      value: Methods[methodName],
      writable: true
    });
  });
  var dom_default = $;

  // node_modules/swiper/shared/utils.js
  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e2) {
      }
      try {
        delete object[key];
      } catch (e2) {
      }
    });
  }
  function nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  }
  function now() {
    return Date.now();
  }
  function getComputedStyle2(el) {
    const window2 = getWindow();
    let style;
    if (window2.getComputedStyle) {
      style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }
    if (!style) {
      style = el.style;
    }
    return style;
  }
  function getTranslate(el, axis = "x") {
    const window2 = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle2(el, null);
    if (window2.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(",").length > 6) {
        curTransform = curTransform.split(", ").map((a) => a.replace(",", ".")).join(", ");
      }
      transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
      matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
      if (window2.WebKitCSSMatrix)
        curTransform = transformMatrix.m41;
      else if (matrix.length === 16)
        curTransform = parseFloat(matrix[12]);
      else
        curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
      if (window2.WebKitCSSMatrix)
        curTransform = transformMatrix.m42;
      else if (matrix.length === 16)
        curTransform = parseFloat(matrix[13]);
      else
        curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  }
  function isObject2(o) {
    return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
  }
  function isNode(node) {
    if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
      return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
  }
  function extend2(...args) {
    const to = Object(args[0]);
    const noExtend = ["__proto__", "constructor", "prototype"];
    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            if (isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              to[nextKey] = {};
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  }
  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }
  function animateCSSModeScroll({
    swiper: swiper2,
    targetPosition,
    side
  }) {
    const window2 = getWindow();
    const startPosition = -swiper2.translate;
    let startTime = null;
    let time;
    const duration = swiper2.params.speed;
    swiper2.wrapperEl.style.scrollSnapType = "none";
    window2.cancelAnimationFrame(swiper2.cssModeFrameID);
    const dir = targetPosition > startPosition ? "next" : "prev";
    const isOutOfBound = (current, target) => {
      return dir === "next" && current >= target || dir === "prev" && current <= target;
    };
    const animate = () => {
      time = new Date().getTime();
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }
      swiper2.wrapperEl.scrollTo({
        [side]: currentPosition
      });
      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper2.wrapperEl.style.overflow = "hidden";
        swiper2.wrapperEl.style.scrollSnapType = "";
        setTimeout(() => {
          swiper2.wrapperEl.style.overflow = "";
          swiper2.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window2.cancelAnimationFrame(swiper2.cssModeFrameID);
        return;
      }
      swiper2.cssModeFrameID = window2.requestAnimationFrame(animate);
    };
    animate();
  }

  // node_modules/swiper/shared/get-support.js
  var support;
  function calcSupport() {
    const window2 = getWindow();
    const document2 = getDocument();
    return {
      smoothScroll: document2.documentElement && "scrollBehavior" in document2.documentElement.style,
      touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
      passiveListener: function checkPassiveListener() {
        let supportsPassive = false;
        try {
          const opts = Object.defineProperty({}, "passive", {
            get() {
              supportsPassive = true;
            }
          });
          window2.addEventListener("testPassiveListener", null, opts);
        } catch (e2) {
        }
        return supportsPassive;
      }(),
      gestures: function checkGestures() {
        return "ongesturestart" in window2;
      }()
    };
  }
  function getSupport() {
    if (!support) {
      support = calcSupport();
    }
    return support;
  }

  // node_modules/swiper/shared/get-device.js
  var deviceCached;
  function calcDevice({
    userAgent
  } = {}) {
    const support2 = getSupport();
    const window2 = getWindow();
    const platform = window2.navigator.platform;
    const ua = userAgent || window2.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window2.screen.width;
    const screenHeight = window2.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === "Win32";
    let macos = platform === "MacIntel";
    const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad)
        ipad = [0, 1, "13_0_0"];
      macos = false;
    }
    if (android && !windows) {
      device.os = "android";
      device.android = true;
    }
    if (ipad || iphone || ipod) {
      device.os = "ios";
      device.ios = true;
    }
    return device;
  }
  function getDevice(overrides = {}) {
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }
    return deviceCached;
  }

  // node_modules/swiper/shared/get-browser.js
  var browser;
  function calcBrowser() {
    const window2 = getWindow();
    function isSafari() {
      const ua = window2.navigator.userAgent.toLowerCase();
      return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    return {
      isSafari: isSafari(),
      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
    };
  }
  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }
    return browser;
  }

  // node_modules/swiper/core/modules/resize/resize.js
  function Resize({
    swiper: swiper2,
    on: on2,
    emit
  }) {
    const window2 = getWindow();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = () => {
      if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
        return;
      emit("beforeResize");
      emit("resize");
    };
    const createObserver = () => {
      if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
        return;
      observer = new ResizeObserver((entries) => {
        animationFrame = window2.requestAnimationFrame(() => {
          const {
            width,
            height
          } = swiper2;
          let newWidth = width;
          let newHeight = height;
          entries.forEach(({
            contentBoxSize,
            contentRect,
            target
          }) => {
            if (target && target !== swiper2.el)
              return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });
          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
      });
      observer.observe(swiper2.el);
    };
    const removeObserver = () => {
      if (animationFrame) {
        window2.cancelAnimationFrame(animationFrame);
      }
      if (observer && observer.unobserve && swiper2.el) {
        observer.unobserve(swiper2.el);
        observer = null;
      }
    };
    const orientationChangeHandler = () => {
      if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
        return;
      emit("orientationchange");
    };
    on2("init", () => {
      if (swiper2.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
        createObserver();
        return;
      }
      window2.addEventListener("resize", resizeHandler);
      window2.addEventListener("orientationchange", orientationChangeHandler);
    });
    on2("destroy", () => {
      removeObserver();
      window2.removeEventListener("resize", resizeHandler);
      window2.removeEventListener("orientationchange", orientationChangeHandler);
    });
  }

  // node_modules/swiper/core/modules/observer/observer.js
  function Observer({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    const observers = [];
    const window2 = getWindow();
    const attach = (target, options = {}) => {
      const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
      const observer = new ObserverFunc((mutations) => {
        if (mutations.length === 1) {
          emit("observerUpdate", mutations[0]);
          return;
        }
        const observerUpdate = function observerUpdate2() {
          emit("observerUpdate", mutations[0]);
        };
        if (window2.requestAnimationFrame) {
          window2.requestAnimationFrame(observerUpdate);
        } else {
          window2.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === "undefined" ? true : options.attributes,
        childList: typeof options.childList === "undefined" ? true : options.childList,
        characterData: typeof options.characterData === "undefined" ? true : options.characterData
      });
      observers.push(observer);
    };
    const init = () => {
      if (!swiper2.params.observer)
        return;
      if (swiper2.params.observeParents) {
        const containerParents = swiper2.$el.parents();
        for (let i = 0; i < containerParents.length; i += 1) {
          attach(containerParents[i]);
        }
      }
      attach(swiper2.$el[0], {
        childList: swiper2.params.observeSlideChildren
      });
      attach(swiper2.$wrapperEl[0], {
        attributes: false
      });
    };
    const destroy2 = () => {
      observers.forEach((observer) => {
        observer.disconnect();
      });
      observers.splice(0, observers.length);
    };
    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on2("init", init);
    on2("destroy", destroy2);
  }

  // node_modules/swiper/core/events-emitter.js
  var events_emitter_default = {
    on(events2, handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (typeof handler !== "function")
        return self2;
      const method = priority ? "unshift" : "push";
      events2.split(" ").forEach((event2) => {
        if (!self2.eventsListeners[event2])
          self2.eventsListeners[event2] = [];
        self2.eventsListeners[event2][method](handler);
      });
      return self2;
    },
    once(events2, handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (typeof handler !== "function")
        return self2;
      function onceHandler(...args) {
        self2.off(events2, onceHandler);
        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }
        handler.apply(self2, args);
      }
      onceHandler.__emitterProxy = handler;
      return self2.on(events2, onceHandler, priority);
    },
    onAny(handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (typeof handler !== "function")
        return self2;
      const method = priority ? "unshift" : "push";
      if (self2.eventsAnyListeners.indexOf(handler) < 0) {
        self2.eventsAnyListeners[method](handler);
      }
      return self2;
    },
    offAny(handler) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (!self2.eventsAnyListeners)
        return self2;
      const index2 = self2.eventsAnyListeners.indexOf(handler);
      if (index2 >= 0) {
        self2.eventsAnyListeners.splice(index2, 1);
      }
      return self2;
    },
    off(events2, handler) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (!self2.eventsListeners)
        return self2;
      events2.split(" ").forEach((event2) => {
        if (typeof handler === "undefined") {
          self2.eventsListeners[event2] = [];
        } else if (self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler, index2) => {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self2.eventsListeners[event2].splice(index2, 1);
            }
          });
        }
      });
      return self2;
    },
    emit(...args) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (!self2.eventsListeners)
        return self2;
      let events2;
      let data;
      let context;
      if (typeof args[0] === "string" || Array.isArray(args[0])) {
        events2 = args[0];
        data = args.slice(1, args.length);
        context = self2;
      } else {
        events2 = args[0].events;
        data = args[0].data;
        context = args[0].context || self2;
      }
      data.unshift(context);
      const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
      eventsArray.forEach((event2) => {
        if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
          self2.eventsAnyListeners.forEach((eventHandler) => {
            eventHandler.apply(context, [event2, ...data]);
          });
        }
        if (self2.eventsListeners && self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler) => {
            eventHandler.apply(context, data);
          });
        }
      });
      return self2;
    }
  };

  // node_modules/swiper/core/update/updateSize.js
  function updateSize() {
    const swiper2 = this;
    let width;
    let height;
    const $el = swiper2.$el;
    if (typeof swiper2.params.width !== "undefined" && swiper2.params.width !== null) {
      width = swiper2.params.width;
    } else {
      width = $el[0].clientWidth;
    }
    if (typeof swiper2.params.height !== "undefined" && swiper2.params.height !== null) {
      height = swiper2.params.height;
    } else {
      height = $el[0].clientHeight;
    }
    if (width === 0 && swiper2.isHorizontal() || height === 0 && swiper2.isVertical()) {
      return;
    }
    width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
    height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
    if (Number.isNaN(width))
      width = 0;
    if (Number.isNaN(height))
      height = 0;
    Object.assign(swiper2, {
      width,
      height,
      size: swiper2.isHorizontal() ? width : height
    });
  }

  // node_modules/swiper/core/update/updateSlides.js
  function updateSlides() {
    const swiper2 = this;
    function getDirectionLabel(property) {
      if (swiper2.isHorizontal()) {
        return property;
      }
      return {
        "width": "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        "marginRight": "marginBottom"
      }[property];
    }
    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
    }
    const params = swiper2.params;
    const {
      $wrapperEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper2;
    const isVirtual = swiper2.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper2.virtual.slides.length : swiper2.slides.length;
    const slides = $wrapperEl.children(`.${swiper2.params.slideClass}`);
    const slidesLength = isVirtual ? swiper2.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
      offsetBefore = params.slidesOffsetBefore.call(swiper2);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
      offsetAfter = params.slidesOffsetAfter.call(swiper2);
    }
    const previousSnapGridLength = swiper2.snapGrid.length;
    const previousSlidesGridLength = swiper2.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index2 = 0;
    if (typeof swiperSize === "undefined") {
      return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    }
    swiper2.virtualSize = -spaceBetween;
    if (rtl)
      slides.css({
        marginLeft: "",
        marginBottom: "",
        marginTop: ""
      });
    else
      slides.css({
        marginRight: "",
        marginBottom: "",
        marginTop: ""
      });
    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(swiper2.wrapperEl, "--swiper-centered-offset-before", "");
      setCSSProperty(swiper2.wrapperEl, "--swiper-centered-offset-after", "");
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper2.grid;
    if (gridEnabled) {
      swiper2.grid.initSlides(slidesLength);
    }
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
      return typeof params.breakpoints[key].slidesPerView !== "undefined";
    }).length > 0;
    for (let i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      const slide = slides.eq(i);
      if (gridEnabled) {
        swiper2.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
      }
      if (slide.css("display") === "none")
        continue;
      if (params.slidesPerView === "auto") {
        if (shouldResetSlideSize) {
          slides[i].style[getDirectionLabel("width")] = ``;
        }
        const slideStyles = getComputedStyle(slide[0]);
        const currentTransform = slide[0].style.transform;
        const currentWebKitTransform = slide[0].style.webkitTransform;
        if (currentTransform) {
          slide[0].style.transform = "none";
        }
        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = "none";
        }
        if (params.roundLengths) {
          slideSize = swiper2.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
        } else {
          const width = getDirectionPropertyValue(slideStyles, "width");
          const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
          const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
          const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
          const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
          const boxSizing = slideStyles.getPropertyValue("box-sizing");
          if (boxSizing && boxSizing === "border-box") {
            slideSize = width + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide[0];
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }
        if (currentTransform) {
          slide[0].style.transform = currentTransform;
        }
        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = currentWebKitTransform;
        }
        if (params.roundLengths)
          slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths)
          slideSize = Math.floor(slideSize);
        if (slides[i]) {
          slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
        }
      }
      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }
      slidesSizesGrid.push(slideSize);
      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i !== 0)
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i === 0)
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1e3)
          slidePosition = 0;
        if (params.roundLengths)
          slidePosition = Math.floor(slidePosition);
        if (index2 % params.slidesPerGroup === 0)
          snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths)
          slidePosition = Math.floor(slidePosition);
        if ((index2 - Math.min(swiper2.params.slidesPerGroupSkip, index2)) % swiper2.params.slidesPerGroup === 0)
          snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }
      swiper2.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index2 += 1;
    }
    swiper2.virtualSize = Math.max(swiper2.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
      $wrapperEl.css({
        width: `${swiper2.virtualSize + params.spaceBetween}px`
      });
    }
    if (params.setWrapperSize) {
      $wrapperEl.css({
        [getDirectionLabel("width")]: `${swiper2.virtualSize + params.spaceBetween}px`
      });
    }
    if (gridEnabled) {
      swiper2.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
    }
    if (!params.centeredSlides) {
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths)
          slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] <= swiper2.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }
      snapGrid = newSlidesGrid;
      if (Math.floor(swiper2.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper2.virtualSize - swiperSize);
      }
    }
    if (snapGrid.length === 0)
      snapGrid = [0];
    if (params.spaceBetween !== 0) {
      const key = swiper2.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
      slides.filter((_, slideIndex) => {
        if (!params.cssMode)
          return true;
        if (slideIndex === slides.length - 1) {
          return false;
        }
        return true;
      }).css({
        [key]: `${spaceBetween}px`
      });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      const maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map((snap) => {
        if (snap < 0)
          return -offsetBefore;
        if (snap > maxSnap)
          return maxSnap + offsetAfter;
        return snap;
      });
    }
    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      if (allSlidesSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
        snapGrid.forEach((snap, snapIndex) => {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach((snap, snapIndex) => {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }
    Object.assign(swiper2, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(swiper2.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
      setCSSProperty(swiper2.wrapperEl, "--swiper-centered-offset-after", `${swiper2.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper2.snapGrid[0];
      const addToSlidesGrid = -swiper2.slidesGrid[0];
      swiper2.snapGrid = swiper2.snapGrid.map((v) => v + addToSnapGrid);
      swiper2.slidesGrid = swiper2.slidesGrid.map((v) => v + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
      swiper2.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper2.params.watchOverflow)
        swiper2.checkOverflow();
      swiper2.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper2.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress) {
      swiper2.updateSlidesOffset();
    }
    if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
      const hasClassBackfaceClassAdded = swiper2.$el.hasClass(backFaceHiddenClass);
      if (slidesLength <= params.maxBackfaceHiddenSlides) {
        if (!hasClassBackfaceClassAdded)
          swiper2.$el.addClass(backFaceHiddenClass);
      } else if (hasClassBackfaceClassAdded) {
        swiper2.$el.removeClass(backFaceHiddenClass);
      }
    }
  }

  // node_modules/swiper/core/update/updateAutoHeight.js
  function updateAutoHeight(speed) {
    const swiper2 = this;
    const activeSlides = [];
    const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
    let newHeight = 0;
    let i;
    if (typeof speed === "number") {
      swiper2.setTransition(speed);
    } else if (speed === true) {
      swiper2.setTransition(swiper2.params.speed);
    }
    const getSlideByIndex = (index2) => {
      if (isVirtual) {
        return swiper2.slides.filter((el) => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index2)[0];
      }
      return swiper2.slides.eq(index2)[0];
    };
    if (swiper2.params.slidesPerView !== "auto" && swiper2.params.slidesPerView > 1) {
      if (swiper2.params.centeredSlides) {
        (swiper2.visibleSlides || dom_default([])).each((slide) => {
          activeSlides.push(slide);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper2.params.slidesPerView); i += 1) {
          const index2 = swiper2.activeIndex + i;
          if (index2 > swiper2.slides.length && !isVirtual)
            break;
          activeSlides.push(getSlideByIndex(index2));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper2.activeIndex));
    }
    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== "undefined") {
        const height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    }
    if (newHeight || newHeight === 0)
      swiper2.$wrapperEl.css("height", `${newHeight}px`);
  }

  // node_modules/swiper/core/update/updateSlidesOffset.js
  function updateSlidesOffset() {
    const swiper2 = this;
    const slides = swiper2.slides;
    for (let i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = swiper2.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
    }
  }

  // node_modules/swiper/core/update/updateSlidesProgress.js
  function updateSlidesProgress(translate = this && this.translate || 0) {
    const swiper2 = this;
    const params = swiper2.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper2;
    if (slides.length === 0)
      return;
    if (typeof slides[0].swiperSlideOffset === "undefined")
      swiper2.updateSlidesOffset();
    let offsetCenter = -translate;
    if (rtl)
      offsetCenter = translate;
    slides.removeClass(params.slideVisibleClass);
    swiper2.visibleSlidesIndexes = [];
    swiper2.visibleSlides = [];
    for (let i = 0; i < slides.length; i += 1) {
      const slide = slides[i];
      let slideOffset = slide.swiperSlideOffset;
      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }
      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper2.slidesSizesGrid[i];
      const isVisible = slideBefore >= 0 && slideBefore < swiper2.size - 1 || slideAfter > 1 && slideAfter <= swiper2.size || slideBefore <= 0 && slideAfter >= swiper2.size;
      if (isVisible) {
        swiper2.visibleSlides.push(slide);
        swiper2.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
      slide.progress = rtl ? -slideProgress : slideProgress;
      slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
    swiper2.visibleSlides = dom_default(swiper2.visibleSlides);
  }

  // node_modules/swiper/core/update/updateProgress.js
  function updateProgress(translate) {
    const swiper2 = this;
    if (typeof translate === "undefined") {
      const multiplier = swiper2.rtlTranslate ? -1 : 1;
      translate = swiper2 && swiper2.translate && swiper2.translate * multiplier || 0;
    }
    const params = swiper2.params;
    const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd
    } = swiper2;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper2.minTranslate()) / translatesDiff;
      isBeginning = progress <= 0;
      isEnd = progress >= 1;
    }
    Object.assign(swiper2, {
      progress,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
      swiper2.updateSlidesProgress(translate);
    if (isBeginning && !wasBeginning) {
      swiper2.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
      swiper2.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper2.emit("fromEdge");
    }
    swiper2.emit("progress", progress);
  }

  // node_modules/swiper/core/update/updateSlidesClasses.js
  function updateSlidesClasses() {
    const swiper2 = this;
    const {
      slides,
      params,
      $wrapperEl,
      activeIndex,
      realIndex
    } = swiper2;
    const isVirtual = swiper2.virtual && params.virtual.enabled;
    slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
    let activeSlide;
    if (isVirtual) {
      activeSlide = swiper2.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
    } else {
      activeSlide = slides.eq(activeIndex);
    }
    activeSlide.addClass(params.slideActiveClass);
    if (params.loop) {
      if (activeSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      }
    }
    let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
    if (params.loop && nextSlide.length === 0) {
      nextSlide = slides.eq(0);
      nextSlide.addClass(params.slideNextClass);
    }
    let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
    if (params.loop && prevSlide.length === 0) {
      prevSlide = slides.eq(-1);
      prevSlide.addClass(params.slidePrevClass);
    }
    if (params.loop) {
      if (nextSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
      }
      if (prevSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
      }
    }
    swiper2.emitSlidesClasses();
  }

  // node_modules/swiper/core/update/updateActiveIndex.js
  function updateActiveIndex(newActiveIndex) {
    const swiper2 = this;
    const translate = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
    const {
      slidesGrid,
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper2;
    let activeIndex = newActiveIndex;
    let snapIndex;
    if (typeof activeIndex === "undefined") {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        if (typeof slidesGrid[i + 1] !== "undefined") {
          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
            activeIndex = i;
          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
            activeIndex = i + 1;
          }
        } else if (translate >= slidesGrid[i]) {
          activeIndex = i;
        }
      }
      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === "undefined")
          activeIndex = 0;
      }
    }
    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length)
      snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper2.snapIndex = snapIndex;
        swiper2.emit("snapIndexChange");
      }
      return;
    }
    const realIndex = parseInt(swiper2.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
    Object.assign(swiper2, {
      snapIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    swiper2.emit("activeIndexChange");
    swiper2.emit("snapIndexChange");
    if (previousRealIndex !== realIndex) {
      swiper2.emit("realIndexChange");
    }
    if (swiper2.initialized || swiper2.params.runCallbacksOnInit) {
      swiper2.emit("slideChange");
    }
  }

  // node_modules/swiper/core/update/updateClickedSlide.js
  function updateClickedSlide(e2) {
    const swiper2 = this;
    const params = swiper2.params;
    const slide = dom_default(e2).closest(`.${params.slideClass}`)[0];
    let slideFound = false;
    let slideIndex;
    if (slide) {
      for (let i = 0; i < swiper2.slides.length; i += 1) {
        if (swiper2.slides[i] === slide) {
          slideFound = true;
          slideIndex = i;
          break;
        }
      }
    }
    if (slide && slideFound) {
      swiper2.clickedSlide = slide;
      if (swiper2.virtual && swiper2.params.virtual.enabled) {
        swiper2.clickedIndex = parseInt(dom_default(slide).attr("data-swiper-slide-index"), 10);
      } else {
        swiper2.clickedIndex = slideIndex;
      }
    } else {
      swiper2.clickedSlide = void 0;
      swiper2.clickedIndex = void 0;
      return;
    }
    if (params.slideToClickedSlide && swiper2.clickedIndex !== void 0 && swiper2.clickedIndex !== swiper2.activeIndex) {
      swiper2.slideToClickedSlide();
    }
  }

  // node_modules/swiper/core/update/index.js
  var update_default = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };

  // node_modules/swiper/core/translate/getTranslate.js
  function getSwiperTranslate(axis = this.isHorizontal() ? "x" : "y") {
    const swiper2 = this;
    const {
      params,
      rtlTranslate: rtl,
      translate,
      $wrapperEl
    } = swiper2;
    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }
    if (params.cssMode) {
      return translate;
    }
    let currentTranslate = getTranslate($wrapperEl[0], axis);
    if (rtl)
      currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }

  // node_modules/swiper/core/translate/setTranslate.js
  function setTranslate(translate, byController) {
    const swiper2 = this;
    const {
      rtlTranslate: rtl,
      params,
      $wrapperEl,
      wrapperEl,
      progress
    } = swiper2;
    let x = 0;
    let y = 0;
    const z = 0;
    if (swiper2.isHorizontal()) {
      x = rtl ? -translate : translate;
    } else {
      y = translate;
    }
    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }
    if (params.cssMode) {
      wrapperEl[swiper2.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper2.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
    }
    swiper2.previousTranslate = swiper2.translate;
    swiper2.translate = swiper2.isHorizontal() ? x : y;
    let newProgress;
    const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper2.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
      swiper2.updateProgress(translate);
    }
    swiper2.emit("setTranslate", swiper2.translate, byController);
  }

  // node_modules/swiper/core/translate/minTranslate.js
  function minTranslate() {
    return -this.snapGrid[0];
  }

  // node_modules/swiper/core/translate/maxTranslate.js
  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }

  // node_modules/swiper/core/translate/translateTo.js
  function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
    const swiper2 = this;
    const {
      params,
      wrapperEl
    } = swiper2;
    if (swiper2.animating && params.preventInteractionOnTransition) {
      return false;
    }
    const minTranslate2 = swiper2.minTranslate();
    const maxTranslate2 = swiper2.maxTranslate();
    let newTranslate;
    if (translateBounds && translate > minTranslate2)
      newTranslate = minTranslate2;
    else if (translateBounds && translate < maxTranslate2)
      newTranslate = maxTranslate2;
    else
      newTranslate = translate;
    swiper2.updateProgress(newTranslate);
    if (params.cssMode) {
      const isH = swiper2.isHorizontal();
      if (speed === 0) {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
      } else {
        if (!swiper2.support.smoothScroll) {
          animateCSSModeScroll({
            swiper: swiper2,
            targetPosition: -newTranslate,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: -newTranslate,
          behavior: "smooth"
        });
      }
      return true;
    }
    if (speed === 0) {
      swiper2.setTransition(0);
      swiper2.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper2.emit("beforeTransitionStart", speed, internal);
        swiper2.emit("transitionEnd");
      }
    } else {
      swiper2.setTransition(speed);
      swiper2.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper2.emit("beforeTransitionStart", speed, internal);
        swiper2.emit("transitionStart");
      }
      if (!swiper2.animating) {
        swiper2.animating = true;
        if (!swiper2.onTranslateToWrapperTransitionEnd) {
          swiper2.onTranslateToWrapperTransitionEnd = function transitionEnd3(e2) {
            if (!swiper2 || swiper2.destroyed)
              return;
            if (e2.target !== this)
              return;
            swiper2.$wrapperEl[0].removeEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
            swiper2.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper2.onTranslateToWrapperTransitionEnd);
            swiper2.onTranslateToWrapperTransitionEnd = null;
            delete swiper2.onTranslateToWrapperTransitionEnd;
            if (runCallbacks) {
              swiper2.emit("transitionEnd");
            }
          };
        }
        swiper2.$wrapperEl[0].addEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
        swiper2.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper2.onTranslateToWrapperTransitionEnd);
      }
    }
    return true;
  }

  // node_modules/swiper/core/translate/index.js
  var translate_default = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };

  // node_modules/swiper/core/transition/setTransition.js
  function setTransition(duration, byController) {
    const swiper2 = this;
    if (!swiper2.params.cssMode) {
      swiper2.$wrapperEl.transition(duration);
    }
    swiper2.emit("setTransition", duration, byController);
  }

  // node_modules/swiper/core/transition/transitionEmit.js
  function transitionEmit({
    swiper: swiper2,
    runCallbacks,
    direction,
    step
  }) {
    const {
      activeIndex,
      previousIndex
    } = swiper2;
    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex)
        dir = "next";
      else if (activeIndex < previousIndex)
        dir = "prev";
      else
        dir = "reset";
    }
    swiper2.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === "reset") {
        swiper2.emit(`slideResetTransition${step}`);
        return;
      }
      swiper2.emit(`slideChangeTransition${step}`);
      if (dir === "next") {
        swiper2.emit(`slideNextTransition${step}`);
      } else {
        swiper2.emit(`slidePrevTransition${step}`);
      }
    }
  }

  // node_modules/swiper/core/transition/transitionStart.js
  function transitionStart(runCallbacks = true, direction) {
    const swiper2 = this;
    const {
      params
    } = swiper2;
    if (params.cssMode)
      return;
    if (params.autoHeight) {
      swiper2.updateAutoHeight();
    }
    transitionEmit({
      swiper: swiper2,
      runCallbacks,
      direction,
      step: "Start"
    });
  }

  // node_modules/swiper/core/transition/transitionEnd.js
  function transitionEnd2(runCallbacks = true, direction) {
    const swiper2 = this;
    const {
      params
    } = swiper2;
    swiper2.animating = false;
    if (params.cssMode)
      return;
    swiper2.setTransition(0);
    transitionEmit({
      swiper: swiper2,
      runCallbacks,
      direction,
      step: "End"
    });
  }

  // node_modules/swiper/core/transition/index.js
  var transition_default = {
    setTransition,
    transitionStart,
    transitionEnd: transitionEnd2
  };

  // node_modules/swiper/core/slide/slideTo.js
  function slideTo(index2 = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
    if (typeof index2 !== "number" && typeof index2 !== "string") {
      throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index2}] given.`);
    }
    if (typeof index2 === "string") {
      const indexAsNumber = parseInt(index2, 10);
      const isValidNumber = isFinite(indexAsNumber);
      if (!isValidNumber) {
        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
      }
      index2 = indexAsNumber;
    }
    const swiper2 = this;
    let slideIndex = index2;
    if (slideIndex < 0)
      slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper2;
    if (swiper2.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
      return false;
    }
    const skip = Math.min(swiper2.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper2.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length)
      snapIndex = snapGrid.length - 1;
    const translate = -snapGrid[snapIndex];
    if (params.normalizeSlideIndex) {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        const normalizedTranslate = -Math.floor(translate * 100);
        const normalizedGrid = Math.floor(slidesGrid[i] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
        if (typeof slidesGrid[i + 1] !== "undefined") {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i;
        }
      }
    }
    if (swiper2.initialized && slideIndex !== activeIndex) {
      if (!swiper2.allowSlideNext && translate < swiper2.translate && translate < swiper2.minTranslate()) {
        return false;
      }
      if (!swiper2.allowSlidePrev && translate > swiper2.translate && translate > swiper2.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex)
          return false;
      }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
      swiper2.emit("beforeSlideChangeStart");
    }
    swiper2.updateProgress(translate);
    let direction;
    if (slideIndex > activeIndex)
      direction = "next";
    else if (slideIndex < activeIndex)
      direction = "prev";
    else
      direction = "reset";
    if (rtl && -translate === swiper2.translate || !rtl && translate === swiper2.translate) {
      swiper2.updateActiveIndex(slideIndex);
      if (params.autoHeight) {
        swiper2.updateAutoHeight();
      }
      swiper2.updateSlidesClasses();
      if (params.effect !== "slide") {
        swiper2.setTranslate(translate);
      }
      if (direction !== "reset") {
        swiper2.transitionStart(runCallbacks, direction);
        swiper2.transitionEnd(runCallbacks, direction);
      }
      return false;
    }
    if (params.cssMode) {
      const isH = swiper2.isHorizontal();
      const t = rtl ? translate : -translate;
      if (speed === 0) {
        const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
        if (isVirtual) {
          swiper2.wrapperEl.style.scrollSnapType = "none";
          swiper2._immediateVirtual = true;
        }
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper2.wrapperEl.style.scrollSnapType = "";
            swiper2._swiperImmediateVirtual = false;
          });
        }
      } else {
        if (!swiper2.support.smoothScroll) {
          animateCSSModeScroll({
            swiper: swiper2,
            targetPosition: t,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: t,
          behavior: "smooth"
        });
      }
      return true;
    }
    swiper2.setTransition(speed);
    swiper2.setTranslate(translate);
    swiper2.updateActiveIndex(slideIndex);
    swiper2.updateSlidesClasses();
    swiper2.emit("beforeTransitionStart", speed, internal);
    swiper2.transitionStart(runCallbacks, direction);
    if (speed === 0) {
      swiper2.transitionEnd(runCallbacks, direction);
    } else if (!swiper2.animating) {
      swiper2.animating = true;
      if (!swiper2.onSlideToWrapperTransitionEnd) {
        swiper2.onSlideToWrapperTransitionEnd = function transitionEnd3(e2) {
          if (!swiper2 || swiper2.destroyed)
            return;
          if (e2.target !== this)
            return;
          swiper2.$wrapperEl[0].removeEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
          swiper2.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper2.onSlideToWrapperTransitionEnd);
          swiper2.onSlideToWrapperTransitionEnd = null;
          delete swiper2.onSlideToWrapperTransitionEnd;
          swiper2.transitionEnd(runCallbacks, direction);
        };
      }
      swiper2.$wrapperEl[0].addEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
      swiper2.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper2.onSlideToWrapperTransitionEnd);
    }
    return true;
  }

  // node_modules/swiper/core/slide/slideToLoop.js
  function slideToLoop(index2 = 0, speed = this.params.speed, runCallbacks = true, internal) {
    if (typeof index2 === "string") {
      const indexAsNumber = parseInt(index2, 10);
      const isValidNumber = isFinite(indexAsNumber);
      if (!isValidNumber) {
        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
      }
      index2 = indexAsNumber;
    }
    const swiper2 = this;
    let newIndex = index2;
    if (swiper2.params.loop) {
      newIndex += swiper2.loopedSlides;
    }
    return swiper2.slideTo(newIndex, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideNext.js
  function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper2 = this;
    const {
      animating,
      enabled,
      params
    } = swiper2;
    if (!enabled)
      return swiper2;
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper2.slidesPerViewDynamic("current", true), 1);
    }
    const increment = swiper2.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    if (params.loop) {
      if (animating && params.loopPreventsSlide)
        return false;
      swiper2.loopFix();
      swiper2._clientLeft = swiper2.$wrapperEl[0].clientLeft;
    }
    if (params.rewind && swiper2.isEnd) {
      return swiper2.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper2.slideTo(swiper2.activeIndex + increment, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slidePrev.js
  function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper2 = this;
    const {
      params,
      animating,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled
    } = swiper2;
    if (!enabled)
      return swiper2;
    if (params.loop) {
      if (animating && params.loopPreventsSlide)
        return false;
      swiper2.loopFix();
      swiper2._clientLeft = swiper2.$wrapperEl[0].clientLeft;
    }
    const translate = rtlTranslate ? swiper2.translate : -swiper2.translate;
    function normalize(val) {
      if (val < 0)
        return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }
    const normalizedTranslate = normalize(translate);
    const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap, snapIndex) => {
        if (normalizedTranslate >= snap) {
          prevSnapIndex = snapIndex;
        }
      });
      if (typeof prevSnapIndex !== "undefined") {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== "undefined") {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0)
        prevIndex = swiper2.activeIndex - 1;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper2.slidesPerViewDynamic("previous", true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }
    if (params.rewind && swiper2.isBeginning) {
      const lastIndex = swiper2.params.virtual && swiper2.params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
      return swiper2.slideTo(lastIndex, speed, runCallbacks, internal);
    }
    return swiper2.slideTo(prevIndex, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideReset.js
  function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper2 = this;
    return swiper2.slideTo(swiper2.activeIndex, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideToClosest.js
  function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
    const swiper2 = this;
    let index2 = swiper2.activeIndex;
    const skip = Math.min(swiper2.params.slidesPerGroupSkip, index2);
    const snapIndex = skip + Math.floor((index2 - skip) / swiper2.params.slidesPerGroup);
    const translate = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
    if (translate >= swiper2.snapGrid[snapIndex]) {
      const currentSnap = swiper2.snapGrid[snapIndex];
      const nextSnap = swiper2.snapGrid[snapIndex + 1];
      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
        index2 += swiper2.params.slidesPerGroup;
      }
    } else {
      const prevSnap = swiper2.snapGrid[snapIndex - 1];
      const currentSnap = swiper2.snapGrid[snapIndex];
      if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index2 -= swiper2.params.slidesPerGroup;
      }
    }
    index2 = Math.max(index2, 0);
    index2 = Math.min(index2, swiper2.slidesGrid.length - 1);
    return swiper2.slideTo(index2, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideToClickedSlide.js
  function slideToClickedSlide() {
    const swiper2 = this;
    const {
      params,
      $wrapperEl
    } = swiper2;
    const slidesPerView = params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper2.clickedIndex;
    let realIndex;
    if (params.loop) {
      if (swiper2.animating)
        return;
      realIndex = parseInt(dom_default(swiper2.clickedSlide).attr("data-swiper-slide-index"), 10);
      if (params.centeredSlides) {
        if (slideToIndex < swiper2.loopedSlides - slidesPerView / 2 || slideToIndex > swiper2.slides.length - swiper2.loopedSlides + slidesPerView / 2) {
          swiper2.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper2.slideTo(slideToIndex);
          });
        } else {
          swiper2.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper2.slides.length - slidesPerView) {
        swiper2.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        nextTick(() => {
          swiper2.slideTo(slideToIndex);
        });
      } else {
        swiper2.slideTo(slideToIndex);
      }
    } else {
      swiper2.slideTo(slideToIndex);
    }
  }

  // node_modules/swiper/core/slide/index.js
  var slide_default = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };

  // node_modules/swiper/core/loop/loopCreate.js
  function loopCreate() {
    const swiper2 = this;
    const document2 = getDocument();
    const {
      params,
      $wrapperEl
    } = swiper2;
    const $selector = $wrapperEl.children().length > 0 ? dom_default($wrapperEl.children()[0].parentNode) : $wrapperEl;
    $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
    let slides = $selector.children(`.${params.slideClass}`);
    if (params.loopFillGroupWithBlank) {
      const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
      if (blankSlidesNum !== params.slidesPerGroup) {
        for (let i = 0; i < blankSlidesNum; i += 1) {
          const blankNode = dom_default(document2.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
          $selector.append(blankNode);
        }
        slides = $selector.children(`.${params.slideClass}`);
      }
    }
    if (params.slidesPerView === "auto" && !params.loopedSlides)
      params.loopedSlides = slides.length;
    swiper2.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper2.loopedSlides += params.loopAdditionalSlides;
    if (swiper2.loopedSlides > slides.length && swiper2.params.loopedSlidesLimit) {
      swiper2.loopedSlides = slides.length;
    }
    const prependSlides = [];
    const appendSlides = [];
    slides.each((el, index2) => {
      const slide = dom_default(el);
      slide.attr("data-swiper-slide-index", index2);
    });
    for (let i = 0; i < swiper2.loopedSlides; i += 1) {
      const index2 = i - Math.floor(i / slides.length) * slides.length;
      appendSlides.push(slides.eq(index2)[0]);
      prependSlides.unshift(slides.eq(slides.length - index2 - 1)[0]);
    }
    for (let i = 0; i < appendSlides.length; i += 1) {
      $selector.append(dom_default(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
    for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
      $selector.prepend(dom_default(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
  }

  // node_modules/swiper/core/loop/loopFix.js
  function loopFix() {
    const swiper2 = this;
    swiper2.emit("beforeLoopFix");
    const {
      activeIndex,
      slides,
      loopedSlides,
      allowSlidePrev,
      allowSlideNext,
      snapGrid,
      rtlTranslate: rtl
    } = swiper2;
    let newIndex;
    swiper2.allowSlidePrev = true;
    swiper2.allowSlideNext = true;
    const snapTranslate = -snapGrid[activeIndex];
    const diff = snapTranslate - swiper2.getTranslate();
    if (activeIndex < loopedSlides) {
      newIndex = slides.length - loopedSlides * 3 + activeIndex;
      newIndex += loopedSlides;
      const slideChanged = swiper2.slideTo(newIndex, 0, false, true);
      if (slideChanged && diff !== 0) {
        swiper2.setTranslate((rtl ? -swiper2.translate : swiper2.translate) - diff);
      }
    } else if (activeIndex >= slides.length - loopedSlides) {
      newIndex = -slides.length + activeIndex + loopedSlides;
      newIndex += loopedSlides;
      const slideChanged = swiper2.slideTo(newIndex, 0, false, true);
      if (slideChanged && diff !== 0) {
        swiper2.setTranslate((rtl ? -swiper2.translate : swiper2.translate) - diff);
      }
    }
    swiper2.allowSlidePrev = allowSlidePrev;
    swiper2.allowSlideNext = allowSlideNext;
    swiper2.emit("loopFix");
  }

  // node_modules/swiper/core/loop/loopDestroy.js
  function loopDestroy() {
    const swiper2 = this;
    const {
      $wrapperEl,
      params,
      slides
    } = swiper2;
    $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
    slides.removeAttr("data-swiper-slide-index");
  }

  // node_modules/swiper/core/loop/index.js
  var loop_default = {
    loopCreate,
    loopFix,
    loopDestroy
  };

  // node_modules/swiper/core/grab-cursor/setGrabCursor.js
  function setGrabCursor(moving) {
    const swiper2 = this;
    if (swiper2.support.touch || !swiper2.params.simulateTouch || swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode)
      return;
    const el = swiper2.params.touchEventsTarget === "container" ? swiper2.el : swiper2.wrapperEl;
    el.style.cursor = "move";
    el.style.cursor = moving ? "grabbing" : "grab";
  }

  // node_modules/swiper/core/grab-cursor/unsetGrabCursor.js
  function unsetGrabCursor() {
    const swiper2 = this;
    if (swiper2.support.touch || swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode) {
      return;
    }
    swiper2[swiper2.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
  }

  // node_modules/swiper/core/grab-cursor/index.js
  var grab_cursor_default = {
    setGrabCursor,
    unsetGrabCursor
  };

  // node_modules/swiper/core/events/onTouchStart.js
  function closestElement(selector, base = this) {
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow())
        return null;
      if (el.assignedSlot)
        el = el.assignedSlot;
      const found = el.closest(selector);
      if (!found && !el.getRootNode) {
        return null;
      }
      return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
  }
  function onTouchStart(event2) {
    const swiper2 = this;
    const document2 = getDocument();
    const window2 = getWindow();
    const data = swiper2.touchEventsData;
    const {
      params,
      touches,
      enabled
    } = swiper2;
    if (!enabled)
      return;
    if (swiper2.animating && params.preventInteractionOnTransition) {
      return;
    }
    if (!swiper2.animating && params.cssMode && params.loop) {
      swiper2.loopFix();
    }
    let e2 = event2;
    if (e2.originalEvent)
      e2 = e2.originalEvent;
    let $targetEl = dom_default(e2.target);
    if (params.touchEventsTarget === "wrapper") {
      if (!$targetEl.closest(swiper2.wrapperEl).length)
        return;
    }
    data.isTouchEvent = e2.type === "touchstart";
    if (!data.isTouchEvent && "which" in e2 && e2.which === 3)
      return;
    if (!data.isTouchEvent && "button" in e2 && e2.button > 0)
      return;
    if (data.isTouched && data.isMoved)
      return;
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    const eventPath = event2.composedPath ? event2.composedPath() : event2.path;
    if (swipingClassHasValue && e2.target && e2.target.shadowRoot && eventPath) {
      $targetEl = dom_default(eventPath[0]);
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e2.target && e2.target.shadowRoot);
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
      swiper2.allowClick = true;
      return;
    }
    if (params.swipeHandler) {
      if (!$targetEl.closest(params.swipeHandler)[0])
        return;
    }
    touches.currentX = e2.type === "touchstart" ? e2.targetTouches[0].pageX : e2.pageX;
    touches.currentY = e2.type === "touchstart" ? e2.targetTouches[0].pageY : e2.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === "prevent") {
        event2.preventDefault();
      } else {
        return;
      }
    }
    Object.assign(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: void 0,
      startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper2.allowClick = true;
    swiper2.updateSize();
    swiper2.swipeDirection = void 0;
    if (params.threshold > 0)
      data.allowThresholdMove = false;
    if (e2.type !== "touchstart") {
      let preventDefault3 = true;
      if ($targetEl.is(data.focusableElements)) {
        preventDefault3 = false;
        if ($targetEl[0].nodeName === "SELECT") {
          data.isTouched = false;
        }
      }
      if (document2.activeElement && dom_default(document2.activeElement).is(data.focusableElements) && document2.activeElement !== $targetEl[0]) {
        document2.activeElement.blur();
      }
      const shouldPreventDefault = preventDefault3 && swiper2.allowTouchMove && params.touchStartPreventDefault;
      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
        e2.preventDefault();
      }
    }
    if (swiper2.params.freeMode && swiper2.params.freeMode.enabled && swiper2.freeMode && swiper2.animating && !params.cssMode) {
      swiper2.freeMode.onTouchStart();
    }
    swiper2.emit("touchStart", e2);
  }

  // node_modules/swiper/core/events/onTouchMove.js
  function onTouchMove(event2) {
    const document2 = getDocument();
    const swiper2 = this;
    const data = swiper2.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper2;
    if (!enabled)
      return;
    let e2 = event2;
    if (e2.originalEvent)
      e2 = e2.originalEvent;
    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper2.emit("touchMoveOpposite", e2);
      }
      return;
    }
    if (data.isTouchEvent && e2.type !== "touchmove")
      return;
    const targetTouch = e2.type === "touchmove" && e2.targetTouches && (e2.targetTouches[0] || e2.changedTouches[0]);
    const pageX = e2.type === "touchmove" ? targetTouch.pageX : e2.pageX;
    const pageY = e2.type === "touchmove" ? targetTouch.pageY : e2.pageY;
    if (e2.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }
    if (!swiper2.allowTouchMove) {
      if (!dom_default(e2.target).is(data.focusableElements)) {
        swiper2.allowClick = false;
      }
      if (data.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = now();
      }
      return;
    }
    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
      if (swiper2.isVertical()) {
        if (pageY < touches.startY && swiper2.translate <= swiper2.maxTranslate() || pageY > touches.startY && swiper2.translate >= swiper2.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper2.translate <= swiper2.maxTranslate() || pageX > touches.startX && swiper2.translate >= swiper2.minTranslate()) {
        return;
      }
    }
    if (data.isTouchEvent && document2.activeElement) {
      if (e2.target === document2.activeElement && dom_default(e2.target).is(data.focusableElements)) {
        data.isMoved = true;
        swiper2.allowClick = false;
        return;
      }
    }
    if (data.allowTouchCallbacks) {
      swiper2.emit("touchMove", e2);
    }
    if (e2.targetTouches && e2.targetTouches.length > 1)
      return;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper2.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper2.params.threshold)
      return;
    if (typeof data.isScrolling === "undefined") {
      let touchAngle;
      if (swiper2.isHorizontal() && touches.currentY === touches.startY || swiper2.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper2.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }
    if (data.isScrolling) {
      swiper2.emit("touchMoveOpposite", e2);
    }
    if (typeof data.startMoving === "undefined") {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }
    if (data.isScrolling) {
      data.isTouched = false;
      return;
    }
    if (!data.startMoving) {
      return;
    }
    swiper2.allowClick = false;
    if (!params.cssMode && e2.cancelable) {
      e2.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
      e2.stopPropagation();
    }
    if (!data.isMoved) {
      if (params.loop && !params.cssMode) {
        swiper2.loopFix();
      }
      data.startTranslate = swiper2.getTranslate();
      swiper2.setTransition(0);
      if (swiper2.animating) {
        swiper2.$wrapperEl.trigger("webkitTransitionEnd transitionend");
      }
      data.allowMomentumBounce = false;
      if (params.grabCursor && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
        swiper2.setGrabCursor(true);
      }
      swiper2.emit("sliderFirstMove", e2);
    }
    swiper2.emit("sliderMove", e2);
    data.isMoved = true;
    let diff = swiper2.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl)
      diff = -diff;
    swiper2.swipeDirection = diff > 0 ? "prev" : "next";
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }
    if (diff > 0 && data.currentTranslate > swiper2.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance)
        data.currentTranslate = swiper2.minTranslate() - 1 + (-swiper2.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
    } else if (diff < 0 && data.currentTranslate < swiper2.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance)
        data.currentTranslate = swiper2.maxTranslate() + 1 - (swiper2.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
    }
    if (disableParentSwiper) {
      e2.preventedByNestedSwiper = true;
    }
    if (!swiper2.allowSlideNext && swiper2.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper2.allowSlidePrev && swiper2.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper2.allowSlidePrev && !swiper2.allowSlideNext) {
      data.currentTranslate = data.startTranslate;
    }
    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper2.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }
    if (!params.followFinger || params.cssMode)
      return;
    if (params.freeMode && params.freeMode.enabled && swiper2.freeMode || params.watchSlidesProgress) {
      swiper2.updateActiveIndex();
      swiper2.updateSlidesClasses();
    }
    if (swiper2.params.freeMode && params.freeMode.enabled && swiper2.freeMode) {
      swiper2.freeMode.onTouchMove();
    }
    swiper2.updateProgress(data.currentTranslate);
    swiper2.setTranslate(data.currentTranslate);
  }

  // node_modules/swiper/core/events/onTouchEnd.js
  function onTouchEnd(event2) {
    const swiper2 = this;
    const data = swiper2.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper2;
    if (!enabled)
      return;
    let e2 = event2;
    if (e2.originalEvent)
      e2 = e2.originalEvent;
    if (data.allowTouchCallbacks) {
      swiper2.emit("touchEnd", e2);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper2.setGrabCursor(false);
      }
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
      swiper2.setGrabCursor(false);
    }
    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (swiper2.allowClick) {
      const pathTree = e2.path || e2.composedPath && e2.composedPath();
      swiper2.updateClickedSlide(pathTree && pathTree[0] || e2.target);
      swiper2.emit("tap click", e2);
      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        swiper2.emit("doubleTap doubleClick", e2);
      }
    }
    data.lastClickTime = now();
    nextTick(() => {
      if (!swiper2.destroyed)
        swiper2.allowClick = true;
    });
    if (!data.isTouched || !data.isMoved || !swiper2.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;
    if (params.followFinger) {
      currentPos = rtl ? swiper2.translate : -swiper2.translate;
    } else {
      currentPos = -data.currentTranslate;
    }
    if (params.cssMode) {
      return;
    }
    if (swiper2.params.freeMode && params.freeMode.enabled) {
      swiper2.freeMode.onTouchEnd({
        currentPos
      });
      return;
    }
    let stopIndex = 0;
    let groupSize = swiper2.slidesSizesGrid[0];
    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (typeof slidesGrid[i + increment2] !== "undefined") {
        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
          stopIndex = i;
          groupSize = slidesGrid[i + increment2] - slidesGrid[i];
        }
      } else if (currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
      if (swiper2.isBeginning) {
        rewindLastIndex = swiper2.params.virtual && swiper2.params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
      } else if (swiper2.isEnd) {
        rewindFirstIndex = 0;
      }
    }
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
      if (!params.longSwipes) {
        swiper2.slideTo(swiper2.activeIndex);
        return;
      }
      if (swiper2.swipeDirection === "next") {
        if (ratio >= params.longSwipesRatio)
          swiper2.slideTo(params.rewind && swiper2.isEnd ? rewindFirstIndex : stopIndex + increment);
        else
          swiper2.slideTo(stopIndex);
      }
      if (swiper2.swipeDirection === "prev") {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper2.slideTo(stopIndex + increment);
        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
          swiper2.slideTo(rewindLastIndex);
        } else {
          swiper2.slideTo(stopIndex);
        }
      }
    } else {
      if (!params.shortSwipes) {
        swiper2.slideTo(swiper2.activeIndex);
        return;
      }
      const isNavButtonTarget = swiper2.navigation && (e2.target === swiper2.navigation.nextEl || e2.target === swiper2.navigation.prevEl);
      if (!isNavButtonTarget) {
        if (swiper2.swipeDirection === "next") {
          swiper2.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
        }
        if (swiper2.swipeDirection === "prev") {
          swiper2.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        }
      } else if (e2.target === swiper2.navigation.nextEl) {
        swiper2.slideTo(stopIndex + increment);
      } else {
        swiper2.slideTo(stopIndex);
      }
    }
  }

  // node_modules/swiper/core/events/onResize.js
  function onResize() {
    const swiper2 = this;
    const {
      params,
      el
    } = swiper2;
    if (el && el.offsetWidth === 0)
      return;
    if (params.breakpoints) {
      swiper2.setBreakpoint();
    }
    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper2;
    swiper2.allowSlideNext = true;
    swiper2.allowSlidePrev = true;
    swiper2.updateSize();
    swiper2.updateSlides();
    swiper2.updateSlidesClasses();
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper2.isEnd && !swiper2.isBeginning && !swiper2.params.centeredSlides) {
      swiper2.slideTo(swiper2.slides.length - 1, 0, false, true);
    } else {
      swiper2.slideTo(swiper2.activeIndex, 0, false, true);
    }
    if (swiper2.autoplay && swiper2.autoplay.running && swiper2.autoplay.paused) {
      swiper2.autoplay.run();
    }
    swiper2.allowSlidePrev = allowSlidePrev;
    swiper2.allowSlideNext = allowSlideNext;
    if (swiper2.params.watchOverflow && snapGrid !== swiper2.snapGrid) {
      swiper2.checkOverflow();
    }
  }

  // node_modules/swiper/core/events/onClick.js
  function onClick(e2) {
    const swiper2 = this;
    if (!swiper2.enabled)
      return;
    if (!swiper2.allowClick) {
      if (swiper2.params.preventClicks)
        e2.preventDefault();
      if (swiper2.params.preventClicksPropagation && swiper2.animating) {
        e2.stopPropagation();
        e2.stopImmediatePropagation();
      }
    }
  }

  // node_modules/swiper/core/events/onScroll.js
  function onScroll2() {
    const swiper2 = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper2;
    if (!enabled)
      return;
    swiper2.previousTranslate = swiper2.translate;
    if (swiper2.isHorizontal()) {
      swiper2.translate = -wrapperEl.scrollLeft;
    } else {
      swiper2.translate = -wrapperEl.scrollTop;
    }
    if (swiper2.translate === 0)
      swiper2.translate = 0;
    swiper2.updateActiveIndex();
    swiper2.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper2.translate - swiper2.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper2.progress) {
      swiper2.updateProgress(rtlTranslate ? -swiper2.translate : swiper2.translate);
    }
    swiper2.emit("setTranslate", swiper2.translate, false);
  }

  // node_modules/swiper/core/events/index.js
  var dummyEventAttached = false;
  function dummyEventListener() {
  }
  var events = (swiper2, method) => {
    const document2 = getDocument();
    const {
      params,
      touchEvents,
      el,
      wrapperEl,
      device,
      support: support2
    } = swiper2;
    const capture = !!params.nested;
    const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
    const swiperMethod = method;
    if (!support2.touch) {
      el[domMethod](touchEvents.start, swiper2.onTouchStart, false);
      document2[domMethod](touchEvents.move, swiper2.onTouchMove, capture);
      document2[domMethod](touchEvents.end, swiper2.onTouchEnd, false);
    } else {
      const passiveListener = touchEvents.start === "touchstart" && support2.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el[domMethod](touchEvents.start, swiper2.onTouchStart, passiveListener);
      el[domMethod](touchEvents.move, swiper2.onTouchMove, support2.passiveListener ? {
        passive: false,
        capture
      } : capture);
      el[domMethod](touchEvents.end, swiper2.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el[domMethod](touchEvents.cancel, swiper2.onTouchEnd, passiveListener);
      }
    }
    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]("click", swiper2.onClick, true);
    }
    if (params.cssMode) {
      wrapperEl[domMethod]("scroll", swiper2.onScroll);
    }
    if (params.updateOnWindowResize) {
      swiper2[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
      swiper2[swiperMethod]("observerUpdate", onResize, true);
    }
  };
  function attachEvents() {
    const swiper2 = this;
    const document2 = getDocument();
    const {
      params,
      support: support2
    } = swiper2;
    swiper2.onTouchStart = onTouchStart.bind(swiper2);
    swiper2.onTouchMove = onTouchMove.bind(swiper2);
    swiper2.onTouchEnd = onTouchEnd.bind(swiper2);
    if (params.cssMode) {
      swiper2.onScroll = onScroll2.bind(swiper2);
    }
    swiper2.onClick = onClick.bind(swiper2);
    if (support2.touch && !dummyEventAttached) {
      document2.addEventListener("touchstart", dummyEventListener);
      dummyEventAttached = true;
    }
    events(swiper2, "on");
  }
  function detachEvents() {
    const swiper2 = this;
    events(swiper2, "off");
  }
  var events_default = {
    attachEvents,
    detachEvents
  };

  // node_modules/swiper/core/breakpoints/setBreakpoint.js
  var isGridEnabled = (swiper2, params) => {
    return swiper2.grid && params.grid && params.grid.rows > 1;
  };
  function setBreakpoint() {
    const swiper2 = this;
    const {
      activeIndex,
      initialized,
      loopedSlides = 0,
      params,
      $el
    } = swiper2;
    const breakpoints = params.breakpoints;
    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0)
      return;
    const breakpoint = swiper2.getBreakpoint(breakpoints, swiper2.params.breakpointsBase, swiper2.el);
    if (!breakpoint || swiper2.currentBreakpoint === breakpoint)
      return;
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
    const breakpointParams = breakpointOnlyParams || swiper2.originalParams;
    const wasMultiRow = isGridEnabled(swiper2, params);
    const isMultiRow = isGridEnabled(swiper2, breakpointParams);
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
      $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
      swiper2.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass(`${params.containerModifierClass}grid`);
      if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
        $el.addClass(`${params.containerModifierClass}grid-column`);
      }
      swiper2.emitContainerClasses();
    }
    ["navigation", "pagination", "scrollbar"].forEach((prop) => {
      const wasModuleEnabled = params[prop] && params[prop].enabled;
      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
      if (wasModuleEnabled && !isModuleEnabled) {
        swiper2[prop].disable();
      }
      if (!wasModuleEnabled && isModuleEnabled) {
        swiper2[prop].enable();
      }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    if (directionChanged && initialized) {
      swiper2.changeDirection();
    }
    extend2(swiper2.params, breakpointParams);
    const isEnabled = swiper2.params.enabled;
    Object.assign(swiper2, {
      allowTouchMove: swiper2.params.allowTouchMove,
      allowSlideNext: swiper2.params.allowSlideNext,
      allowSlidePrev: swiper2.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
      swiper2.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper2.enable();
    }
    swiper2.currentBreakpoint = breakpoint;
    swiper2.emit("_beforeBreakpoint", breakpointParams);
    if (needsReLoop && initialized) {
      swiper2.loopDestroy();
      swiper2.loopCreate();
      swiper2.updateSlides();
      swiper2.slideTo(activeIndex - loopedSlides + swiper2.loopedSlides, 0, false);
    }
    swiper2.emit("breakpoint", breakpointParams);
  }

  // node_modules/swiper/core/breakpoints/getBreakpoint.js
  function getBreakpoint(breakpoints, base = "window", containerEl) {
    if (!breakpoints || base === "container" && !containerEl)
      return void 0;
    let breakpoint = false;
    const window2 = getWindow();
    const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints).map((point) => {
      if (typeof point === "string" && point.indexOf("@") === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value2 = currentHeight * minRatio;
        return {
          value: value2,
          point
        };
      }
      return {
        value: point,
        point
      };
    });
    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
    for (let i = 0; i < points.length; i += 1) {
      const {
        point,
        value: value2
      } = points[i];
      if (base === "window") {
        if (window2.matchMedia(`(min-width: ${value2}px)`).matches) {
          breakpoint = point;
        }
      } else if (value2 <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }
    return breakpoint || "max";
  }

  // node_modules/swiper/core/breakpoints/index.js
  var breakpoints_default = {
    setBreakpoint,
    getBreakpoint
  };

  // node_modules/swiper/core/classes/addClasses.js
  function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach((item) => {
      if (typeof item === "object") {
        Object.keys(item).forEach((classNames) => {
          if (item[classNames]) {
            resultClasses.push(prefix + classNames);
          }
        });
      } else if (typeof item === "string") {
        resultClasses.push(prefix + item);
      }
    });
    return resultClasses;
  }
  function addClasses() {
    const swiper2 = this;
    const {
      classNames,
      params,
      rtl,
      $el,
      device,
      support: support2
    } = swiper2;
    const suffixes = prepareClasses(["initialized", params.direction, {
      "pointer-events": !support2.touch
    }, {
      "free-mode": swiper2.params.freeMode && params.freeMode.enabled
    }, {
      "autoheight": params.autoHeight
    }, {
      "rtl": rtl
    }, {
      "grid": params.grid && params.grid.rows > 1
    }, {
      "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
    }, {
      "android": device.android
    }, {
      "ios": device.ios
    }, {
      "css-mode": params.cssMode
    }, {
      "centered": params.cssMode && params.centeredSlides
    }, {
      "watch-progress": params.watchSlidesProgress
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    $el.addClass([...classNames].join(" "));
    swiper2.emitContainerClasses();
  }

  // node_modules/swiper/core/classes/removeClasses.js
  function removeClasses() {
    const swiper2 = this;
    const {
      $el,
      classNames
    } = swiper2;
    $el.removeClass(classNames.join(" "));
    swiper2.emitContainerClasses();
  }

  // node_modules/swiper/core/classes/index.js
  var classes_default = {
    addClasses,
    removeClasses
  };

  // node_modules/swiper/core/images/loadImage.js
  function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
    const window2 = getWindow();
    let image;
    function onReady() {
      if (callback)
        callback();
    }
    const isPicture = dom_default(imageEl).parent("picture")[0];
    if (!isPicture && (!imageEl.complete || !checkForComplete)) {
      if (src) {
        image = new window2.Image();
        image.onload = onReady;
        image.onerror = onReady;
        if (sizes) {
          image.sizes = sizes;
        }
        if (srcset) {
          image.srcset = srcset;
        }
        if (src) {
          image.src = src;
        }
      } else {
        onReady();
      }
    } else {
      onReady();
    }
  }

  // node_modules/swiper/core/images/preloadImages.js
  function preloadImages() {
    const swiper2 = this;
    swiper2.imagesToLoad = swiper2.$el.find("img");
    function onReady() {
      if (typeof swiper2 === "undefined" || swiper2 === null || !swiper2 || swiper2.destroyed)
        return;
      if (swiper2.imagesLoaded !== void 0)
        swiper2.imagesLoaded += 1;
      if (swiper2.imagesLoaded === swiper2.imagesToLoad.length) {
        if (swiper2.params.updateOnImagesReady)
          swiper2.update();
        swiper2.emit("imagesReady");
      }
    }
    for (let i = 0; i < swiper2.imagesToLoad.length; i += 1) {
      const imageEl = swiper2.imagesToLoad[i];
      swiper2.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
    }
  }

  // node_modules/swiper/core/images/index.js
  var images_default = {
    loadImage,
    preloadImages
  };

  // node_modules/swiper/core/check-overflow/index.js
  function checkOverflow() {
    const swiper2 = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper2;
    const {
      slidesOffsetBefore
    } = params;
    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper2.slides.length - 1;
      const lastSlideRightEdge = swiper2.slidesGrid[lastSlideIndex] + swiper2.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper2.isLocked = swiper2.size > lastSlideRightEdge;
    } else {
      swiper2.isLocked = swiper2.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
      swiper2.allowSlideNext = !swiper2.isLocked;
    }
    if (params.allowSlidePrev === true) {
      swiper2.allowSlidePrev = !swiper2.isLocked;
    }
    if (wasLocked && wasLocked !== swiper2.isLocked) {
      swiper2.isEnd = false;
    }
    if (wasLocked !== swiper2.isLocked) {
      swiper2.emit(swiper2.isLocked ? "lock" : "unlock");
    }
  }
  var check_overflow_default = {
    checkOverflow
  };

  // node_modules/swiper/core/defaults.js
  var defaults_default = {
    init: true,
    direction: "horizontal",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: false,
    userAgent: null,
    url: null,
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    autoHeight: false,
    setWrapperSize: false,
    virtualTranslate: false,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    watchOverflow: true,
    roundLengths: false,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    uniqueNavElements: true,
    resistance: true,
    resistanceRatio: 0.85,
    watchSlidesProgress: false,
    grabCursor: false,
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    preloadImages: true,
    updateOnImagesReady: true,
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopedSlidesLimit: true,
    loopFillGroupWithBlank: false,
    loopPreventsSlide: true,
    rewind: false,
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-invisible-blank",
    slideActiveClass: "swiper-slide-active",
    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
    slideVisibleClass: "swiper-slide-visible",
    slideDuplicateClass: "swiper-slide-duplicate",
    slideNextClass: "swiper-slide-next",
    slideDuplicateNextClass: "swiper-slide-duplicate-next",
    slidePrevClass: "swiper-slide-prev",
    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
    wrapperClass: "swiper-wrapper",
    runCallbacksOnInit: true,
    _emitClasses: false
  };

  // node_modules/swiper/core/moduleExtendParams.js
  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj = {}) {
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];
      if (typeof moduleParams !== "object" || moduleParams === null) {
        extend2(allModulesParams, obj);
        return;
      }
      if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
        params[moduleParamName] = {
          auto: true
        };
      }
      if (!(moduleParamName in params && "enabled" in moduleParams)) {
        extend2(allModulesParams, obj);
        return;
      }
      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }
      if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }
      if (!params[moduleParamName])
        params[moduleParamName] = {
          enabled: false
        };
      extend2(allModulesParams, obj);
    };
  }

  // node_modules/swiper/core/core.js
  var prototypes = {
    eventsEmitter: events_emitter_default,
    update: update_default,
    translate: translate_default,
    transition: transition_default,
    slide: slide_default,
    loop: loop_default,
    grabCursor: grab_cursor_default,
    events: events_default,
    breakpoints: breakpoints_default,
    checkOverflow: check_overflow_default,
    classes: classes_default,
    images: images_default
  };
  var extendedDefaults = {};
  var Swiper = class {
    constructor(...args) {
      let el;
      let params;
      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
        params = args[0];
      } else {
        [el, params] = args;
      }
      if (!params)
        params = {};
      params = extend2({}, params);
      if (el && !params.el)
        params.el = el;
      if (params.el && dom_default(params.el).length > 1) {
        const swipers = [];
        dom_default(params.el).each((containerEl) => {
          const newParams = extend2({}, params, {
            el: containerEl
          });
          swipers.push(new Swiper(newParams));
        });
        return swipers;
      }
      const swiper2 = this;
      swiper2.__swiper__ = true;
      swiper2.support = getSupport();
      swiper2.device = getDevice({
        userAgent: params.userAgent
      });
      swiper2.browser = getBrowser();
      swiper2.eventsListeners = {};
      swiper2.eventsAnyListeners = [];
      swiper2.modules = [...swiper2.__modules__];
      if (params.modules && Array.isArray(params.modules)) {
        swiper2.modules.push(...params.modules);
      }
      const allModulesParams = {};
      swiper2.modules.forEach((mod) => {
        mod({
          swiper: swiper2,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper2.on.bind(swiper2),
          once: swiper2.once.bind(swiper2),
          off: swiper2.off.bind(swiper2),
          emit: swiper2.emit.bind(swiper2)
        });
      });
      const swiperParams = extend2({}, defaults_default, allModulesParams);
      swiper2.params = extend2({}, swiperParams, extendedDefaults, params);
      swiper2.originalParams = extend2({}, swiper2.params);
      swiper2.passedParams = extend2({}, params);
      if (swiper2.params && swiper2.params.on) {
        Object.keys(swiper2.params.on).forEach((eventName) => {
          swiper2.on(eventName, swiper2.params.on[eventName]);
        });
      }
      if (swiper2.params && swiper2.params.onAny) {
        swiper2.onAny(swiper2.params.onAny);
      }
      swiper2.$ = dom_default;
      Object.assign(swiper2, {
        enabled: swiper2.params.enabled,
        el,
        classNames: [],
        slides: dom_default(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        isHorizontal() {
          return swiper2.params.direction === "horizontal";
        },
        isVertical() {
          return swiper2.params.direction === "vertical";
        },
        activeIndex: 0,
        realIndex: 0,
        isBeginning: true,
        isEnd: false,
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        allowSlideNext: swiper2.params.allowSlideNext,
        allowSlidePrev: swiper2.params.allowSlidePrev,
        touchEvents: function touchEvents() {
          const touch2 = ["touchstart", "touchmove", "touchend", "touchcancel"];
          const desktop = ["pointerdown", "pointermove", "pointerup"];
          swiper2.touchEventsTouch = {
            start: touch2[0],
            move: touch2[1],
            end: touch2[2],
            cancel: touch2[3]
          };
          swiper2.touchEventsDesktop = {
            start: desktop[0],
            move: desktop[1],
            end: desktop[2]
          };
          return swiper2.support.touch || !swiper2.params.simulateTouch ? swiper2.touchEventsTouch : swiper2.touchEventsDesktop;
        }(),
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          focusableElements: swiper2.params.focusableElements,
          lastClickTime: now(),
          clickTimeout: void 0,
          velocities: [],
          allowMomentumBounce: void 0,
          isTouchEvent: void 0,
          startMoving: void 0
        },
        allowClick: true,
        allowTouchMove: swiper2.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper2.emit("_swiper");
      if (swiper2.params.init) {
        swiper2.init();
      }
      return swiper2;
    }
    enable() {
      const swiper2 = this;
      if (swiper2.enabled)
        return;
      swiper2.enabled = true;
      if (swiper2.params.grabCursor) {
        swiper2.setGrabCursor();
      }
      swiper2.emit("enable");
    }
    disable() {
      const swiper2 = this;
      if (!swiper2.enabled)
        return;
      swiper2.enabled = false;
      if (swiper2.params.grabCursor) {
        swiper2.unsetGrabCursor();
      }
      swiper2.emit("disable");
    }
    setProgress(progress, speed) {
      const swiper2 = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = swiper2.minTranslate();
      const max = swiper2.maxTranslate();
      const current = (max - min) * progress + min;
      swiper2.translateTo(current, typeof speed === "undefined" ? 0 : speed);
      swiper2.updateActiveIndex();
      swiper2.updateSlidesClasses();
    }
    emitContainerClasses() {
      const swiper2 = this;
      if (!swiper2.params._emitClasses || !swiper2.el)
        return;
      const cls2 = swiper2.el.className.split(" ").filter((className) => {
        return className.indexOf("swiper") === 0 || className.indexOf(swiper2.params.containerModifierClass) === 0;
      });
      swiper2.emit("_containerClasses", cls2.join(" "));
    }
    getSlideClasses(slideEl) {
      const swiper2 = this;
      if (swiper2.destroyed)
        return "";
      return slideEl.className.split(" ").filter((className) => {
        return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper2.params.slideClass) === 0;
      }).join(" ");
    }
    emitSlidesClasses() {
      const swiper2 = this;
      if (!swiper2.params._emitClasses || !swiper2.el)
        return;
      const updates = [];
      swiper2.slides.each((slideEl) => {
        const classNames = swiper2.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper2.emit("_slideClass", slideEl, classNames);
      });
      swiper2.emit("_slideClasses", updates);
    }
    slidesPerViewDynamic(view = "current", exact = false) {
      const swiper2 = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper2;
      let spv = 1;
      if (params.centeredSlides) {
        let slideSize = slides[activeIndex].swiperSlideSize;
        let breakLoop;
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize)
              breakLoop = true;
          }
        }
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize)
              breakLoop = true;
          }
        }
      } else {
        if (view === "current") {
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        }
      }
      return spv;
    }
    update() {
      const swiper2 = this;
      if (!swiper2 || swiper2.destroyed)
        return;
      const {
        snapGrid,
        params
      } = swiper2;
      if (params.breakpoints) {
        swiper2.setBreakpoint();
      }
      swiper2.updateSize();
      swiper2.updateSlides();
      swiper2.updateProgress();
      swiper2.updateSlidesClasses();
      function setTranslate2() {
        const translateValue = swiper2.rtlTranslate ? swiper2.translate * -1 : swiper2.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper2.maxTranslate()), swiper2.minTranslate());
        swiper2.setTranslate(newTranslate);
        swiper2.updateActiveIndex();
        swiper2.updateSlidesClasses();
      }
      let translated;
      if (swiper2.params.freeMode && swiper2.params.freeMode.enabled) {
        setTranslate2();
        if (swiper2.params.autoHeight) {
          swiper2.updateAutoHeight();
        }
      } else {
        if ((swiper2.params.slidesPerView === "auto" || swiper2.params.slidesPerView > 1) && swiper2.isEnd && !swiper2.params.centeredSlides) {
          translated = swiper2.slideTo(swiper2.slides.length - 1, 0, false, true);
        } else {
          translated = swiper2.slideTo(swiper2.activeIndex, 0, false, true);
        }
        if (!translated) {
          setTranslate2();
        }
      }
      if (params.watchOverflow && snapGrid !== swiper2.snapGrid) {
        swiper2.checkOverflow();
      }
      swiper2.emit("update");
    }
    changeDirection(newDirection, needUpdate = true) {
      const swiper2 = this;
      const currentDirection = swiper2.params.direction;
      if (!newDirection) {
        newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
      }
      if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
        return swiper2;
      }
      swiper2.$el.removeClass(`${swiper2.params.containerModifierClass}${currentDirection}`).addClass(`${swiper2.params.containerModifierClass}${newDirection}`);
      swiper2.emitContainerClasses();
      swiper2.params.direction = newDirection;
      swiper2.slides.each((slideEl) => {
        if (newDirection === "vertical") {
          slideEl.style.width = "";
        } else {
          slideEl.style.height = "";
        }
      });
      swiper2.emit("changeDirection");
      if (needUpdate)
        swiper2.update();
      return swiper2;
    }
    changeLanguageDirection(direction) {
      const swiper2 = this;
      if (swiper2.rtl && direction === "rtl" || !swiper2.rtl && direction === "ltr")
        return;
      swiper2.rtl = direction === "rtl";
      swiper2.rtlTranslate = swiper2.params.direction === "horizontal" && swiper2.rtl;
      if (swiper2.rtl) {
        swiper2.$el.addClass(`${swiper2.params.containerModifierClass}rtl`);
        swiper2.el.dir = "rtl";
      } else {
        swiper2.$el.removeClass(`${swiper2.params.containerModifierClass}rtl`);
        swiper2.el.dir = "ltr";
      }
      swiper2.update();
    }
    mount(el) {
      const swiper2 = this;
      if (swiper2.mounted)
        return true;
      const $el = dom_default(el || swiper2.params.el);
      el = $el[0];
      if (!el) {
        return false;
      }
      el.swiper = swiper2;
      const getWrapperSelector = () => {
        return `.${(swiper2.params.wrapperClass || "").trim().split(" ").join(".")}`;
      };
      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = dom_default(el.shadowRoot.querySelector(getWrapperSelector()));
          res.children = (options) => $el.children(options);
          return res;
        }
        if (!$el.children) {
          return dom_default($el).children(getWrapperSelector());
        }
        return $el.children(getWrapperSelector());
      };
      let $wrapperEl = getWrapper();
      if ($wrapperEl.length === 0 && swiper2.params.createElements) {
        const document2 = getDocument();
        const wrapper = document2.createElement("div");
        $wrapperEl = dom_default(wrapper);
        wrapper.className = swiper2.params.wrapperClass;
        $el.append(wrapper);
        $el.children(`.${swiper2.params.slideClass}`).each((slideEl) => {
          $wrapperEl.append(slideEl);
        });
      }
      Object.assign(swiper2, {
        $el,
        el,
        $wrapperEl,
        wrapperEl: $wrapperEl[0],
        mounted: true,
        rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
        rtlTranslate: swiper2.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
        wrongRTL: $wrapperEl.css("display") === "-webkit-box"
      });
      return true;
    }
    init(el) {
      const swiper2 = this;
      if (swiper2.initialized)
        return swiper2;
      const mounted = swiper2.mount(el);
      if (mounted === false)
        return swiper2;
      swiper2.emit("beforeInit");
      if (swiper2.params.breakpoints) {
        swiper2.setBreakpoint();
      }
      swiper2.addClasses();
      if (swiper2.params.loop) {
        swiper2.loopCreate();
      }
      swiper2.updateSize();
      swiper2.updateSlides();
      if (swiper2.params.watchOverflow) {
        swiper2.checkOverflow();
      }
      if (swiper2.params.grabCursor && swiper2.enabled) {
        swiper2.setGrabCursor();
      }
      if (swiper2.params.preloadImages) {
        swiper2.preloadImages();
      }
      if (swiper2.params.loop) {
        swiper2.slideTo(swiper2.params.initialSlide + swiper2.loopedSlides, 0, swiper2.params.runCallbacksOnInit, false, true);
      } else {
        swiper2.slideTo(swiper2.params.initialSlide, 0, swiper2.params.runCallbacksOnInit, false, true);
      }
      swiper2.attachEvents();
      swiper2.initialized = true;
      swiper2.emit("init");
      swiper2.emit("afterInit");
      return swiper2;
    }
    destroy(deleteInstance = true, cleanStyles = true) {
      const swiper2 = this;
      const {
        params,
        $el,
        $wrapperEl,
        slides
      } = swiper2;
      if (typeof swiper2.params === "undefined" || swiper2.destroyed) {
        return null;
      }
      swiper2.emit("beforeDestroy");
      swiper2.initialized = false;
      swiper2.detachEvents();
      if (params.loop) {
        swiper2.loopDestroy();
      }
      if (cleanStyles) {
        swiper2.removeClasses();
        $el.removeAttr("style");
        $wrapperEl.removeAttr("style");
        if (slides && slides.length) {
          slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
        }
      }
      swiper2.emit("destroy");
      Object.keys(swiper2.eventsListeners).forEach((eventName) => {
        swiper2.off(eventName);
      });
      if (deleteInstance !== false) {
        swiper2.$el[0].swiper = null;
        deleteProps(swiper2);
      }
      swiper2.destroyed = true;
      return null;
    }
    static extendDefaults(newDefaults) {
      extend2(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
      return extendedDefaults;
    }
    static get defaults() {
      return defaults_default;
    }
    static installModule(mod) {
      if (!Swiper.prototype.__modules__)
        Swiper.prototype.__modules__ = [];
      const modules2 = Swiper.prototype.__modules__;
      if (typeof mod === "function" && modules2.indexOf(mod) < 0) {
        modules2.push(mod);
      }
    }
    static use(module) {
      if (Array.isArray(module)) {
        module.forEach((m) => Swiper.installModule(m));
        return Swiper;
      }
      Swiper.installModule(module);
      return Swiper;
    }
  };
  Object.keys(prototypes).forEach((prototypeGroup) => {
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer]);
  var core_default = Swiper;

  // node_modules/swiper/modules/virtual/virtual.js
  function Virtual({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    extendParams({
      virtual: {
        enabled: false,
        slides: [],
        cache: true,
        renderSlide: null,
        renderExternal: null,
        renderExternalUpdate: true,
        addSlidesBefore: 0,
        addSlidesAfter: 0
      }
    });
    let cssModeTimeout;
    swiper2.virtual = {
      cache: {},
      from: void 0,
      to: void 0,
      slides: [],
      offset: 0,
      slidesGrid: []
    };
    function renderSlide(slide, index2) {
      const params = swiper2.params.virtual;
      if (params.cache && swiper2.virtual.cache[index2]) {
        return swiper2.virtual.cache[index2];
      }
      const $slideEl = params.renderSlide ? dom_default(params.renderSlide.call(swiper2, slide, index2)) : dom_default(`<div class="${swiper2.params.slideClass}" data-swiper-slide-index="${index2}">${slide}</div>`);
      if (!$slideEl.attr("data-swiper-slide-index"))
        $slideEl.attr("data-swiper-slide-index", index2);
      if (params.cache)
        swiper2.virtual.cache[index2] = $slideEl;
      return $slideEl;
    }
    function update2(force) {
      const {
        slidesPerView,
        slidesPerGroup,
        centeredSlides
      } = swiper2.params;
      const {
        addSlidesBefore,
        addSlidesAfter
      } = swiper2.params.virtual;
      const {
        from: previousFrom,
        to: previousTo,
        slides,
        slidesGrid: previousSlidesGrid,
        offset: previousOffset
      } = swiper2.virtual;
      if (!swiper2.params.cssMode) {
        swiper2.updateActiveIndex();
      }
      const activeIndex = swiper2.activeIndex || 0;
      let offsetProp;
      if (swiper2.rtlTranslate)
        offsetProp = "right";
      else
        offsetProp = swiper2.isHorizontal() ? "left" : "top";
      let slidesAfter;
      let slidesBefore;
      if (centeredSlides) {
        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
      } else {
        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
        slidesBefore = slidesPerGroup + addSlidesBefore;
      }
      const from = Math.max((activeIndex || 0) - slidesBefore, 0);
      const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
      const offset2 = (swiper2.slidesGrid[from] || 0) - (swiper2.slidesGrid[0] || 0);
      Object.assign(swiper2.virtual, {
        from,
        to,
        offset: offset2,
        slidesGrid: swiper2.slidesGrid
      });
      function onRendered() {
        swiper2.updateSlides();
        swiper2.updateProgress();
        swiper2.updateSlidesClasses();
        if (swiper2.lazy && swiper2.params.lazy.enabled) {
          swiper2.lazy.load();
        }
        emit("virtualUpdate");
      }
      if (previousFrom === from && previousTo === to && !force) {
        if (swiper2.slidesGrid !== previousSlidesGrid && offset2 !== previousOffset) {
          swiper2.slides.css(offsetProp, `${offset2}px`);
        }
        swiper2.updateProgress();
        emit("virtualUpdate");
        return;
      }
      if (swiper2.params.virtual.renderExternal) {
        swiper2.params.virtual.renderExternal.call(swiper2, {
          offset: offset2,
          from,
          to,
          slides: function getSlides() {
            const slidesToRender = [];
            for (let i = from; i <= to; i += 1) {
              slidesToRender.push(slides[i]);
            }
            return slidesToRender;
          }()
        });
        if (swiper2.params.virtual.renderExternalUpdate) {
          onRendered();
        } else {
          emit("virtualUpdate");
        }
        return;
      }
      const prependIndexes = [];
      const appendIndexes = [];
      if (force) {
        swiper2.$wrapperEl.find(`.${swiper2.params.slideClass}`).remove();
      } else {
        for (let i = previousFrom; i <= previousTo; i += 1) {
          if (i < from || i > to) {
            swiper2.$wrapperEl.find(`.${swiper2.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
          }
        }
      }
      for (let i = 0; i < slides.length; i += 1) {
        if (i >= from && i <= to) {
          if (typeof previousTo === "undefined" || force) {
            appendIndexes.push(i);
          } else {
            if (i > previousTo)
              appendIndexes.push(i);
            if (i < previousFrom)
              prependIndexes.push(i);
          }
        }
      }
      appendIndexes.forEach((index2) => {
        swiper2.$wrapperEl.append(renderSlide(slides[index2], index2));
      });
      prependIndexes.sort((a, b) => b - a).forEach((index2) => {
        swiper2.$wrapperEl.prepend(renderSlide(slides[index2], index2));
      });
      swiper2.$wrapperEl.children(".swiper-slide").css(offsetProp, `${offset2}px`);
      onRendered();
    }
    function appendSlide2(slides) {
      if (typeof slides === "object" && "length" in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i])
            swiper2.virtual.slides.push(slides[i]);
        }
      } else {
        swiper2.virtual.slides.push(slides);
      }
      update2(true);
    }
    function prependSlide2(slides) {
      const activeIndex = swiper2.activeIndex;
      let newActiveIndex = activeIndex + 1;
      let numberOfNewSlides = 1;
      if (Array.isArray(slides)) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i])
            swiper2.virtual.slides.unshift(slides[i]);
        }
        newActiveIndex = activeIndex + slides.length;
        numberOfNewSlides = slides.length;
      } else {
        swiper2.virtual.slides.unshift(slides);
      }
      if (swiper2.params.virtual.cache) {
        const cache = swiper2.virtual.cache;
        const newCache = {};
        Object.keys(cache).forEach((cachedIndex) => {
          const $cachedEl = cache[cachedIndex];
          const cachedElIndex = $cachedEl.attr("data-swiper-slide-index");
          if (cachedElIndex) {
            $cachedEl.attr("data-swiper-slide-index", parseInt(cachedElIndex, 10) + numberOfNewSlides);
          }
          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
        });
        swiper2.virtual.cache = newCache;
      }
      update2(true);
      swiper2.slideTo(newActiveIndex, 0);
    }
    function removeSlide2(slidesIndexes) {
      if (typeof slidesIndexes === "undefined" || slidesIndexes === null)
        return;
      let activeIndex = swiper2.activeIndex;
      if (Array.isArray(slidesIndexes)) {
        for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
          swiper2.virtual.slides.splice(slidesIndexes[i], 1);
          if (swiper2.params.virtual.cache) {
            delete swiper2.virtual.cache[slidesIndexes[i]];
          }
          if (slidesIndexes[i] < activeIndex)
            activeIndex -= 1;
          activeIndex = Math.max(activeIndex, 0);
        }
      } else {
        swiper2.virtual.slides.splice(slidesIndexes, 1);
        if (swiper2.params.virtual.cache) {
          delete swiper2.virtual.cache[slidesIndexes];
        }
        if (slidesIndexes < activeIndex)
          activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
      update2(true);
      swiper2.slideTo(activeIndex, 0);
    }
    function removeAllSlides2() {
      swiper2.virtual.slides = [];
      if (swiper2.params.virtual.cache) {
        swiper2.virtual.cache = {};
      }
      update2(true);
      swiper2.slideTo(0, 0);
    }
    on2("beforeInit", () => {
      if (!swiper2.params.virtual.enabled)
        return;
      swiper2.virtual.slides = swiper2.params.virtual.slides;
      swiper2.classNames.push(`${swiper2.params.containerModifierClass}virtual`);
      swiper2.params.watchSlidesProgress = true;
      swiper2.originalParams.watchSlidesProgress = true;
      if (!swiper2.params.initialSlide) {
        update2();
      }
    });
    on2("setTranslate", () => {
      if (!swiper2.params.virtual.enabled)
        return;
      if (swiper2.params.cssMode && !swiper2._immediateVirtual) {
        clearTimeout(cssModeTimeout);
        cssModeTimeout = setTimeout(() => {
          update2();
        }, 100);
      } else {
        update2();
      }
    });
    on2("init update resize", () => {
      if (!swiper2.params.virtual.enabled)
        return;
      if (swiper2.params.cssMode) {
        setCSSProperty(swiper2.wrapperEl, "--swiper-virtual-size", `${swiper2.virtualSize}px`);
      }
    });
    Object.assign(swiper2.virtual, {
      appendSlide: appendSlide2,
      prependSlide: prependSlide2,
      removeSlide: removeSlide2,
      removeAllSlides: removeAllSlides2,
      update: update2
    });
  }

  // node_modules/swiper/modules/keyboard/keyboard.js
  function Keyboard({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    const document2 = getDocument();
    const window2 = getWindow();
    swiper2.keyboard = {
      enabled: false
    };
    extendParams({
      keyboard: {
        enabled: false,
        onlyInViewport: true,
        pageUpDown: true
      }
    });
    function handle(event2) {
      if (!swiper2.enabled)
        return;
      const {
        rtlTranslate: rtl
      } = swiper2;
      let e2 = event2;
      if (e2.originalEvent)
        e2 = e2.originalEvent;
      const kc = e2.keyCode || e2.charCode;
      const pageUpDown = swiper2.params.keyboard.pageUpDown;
      const isPageUp = pageUpDown && kc === 33;
      const isPageDown = pageUpDown && kc === 34;
      const isArrowLeft = kc === 37;
      const isArrowRight = kc === 39;
      const isArrowUp = kc === 38;
      const isArrowDown = kc === 40;
      if (!swiper2.allowSlideNext && (swiper2.isHorizontal() && isArrowRight || swiper2.isVertical() && isArrowDown || isPageDown)) {
        return false;
      }
      if (!swiper2.allowSlidePrev && (swiper2.isHorizontal() && isArrowLeft || swiper2.isVertical() && isArrowUp || isPageUp)) {
        return false;
      }
      if (e2.shiftKey || e2.altKey || e2.ctrlKey || e2.metaKey) {
        return void 0;
      }
      if (document2.activeElement && document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === "input" || document2.activeElement.nodeName.toLowerCase() === "textarea")) {
        return void 0;
      }
      if (swiper2.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
        let inView = false;
        if (swiper2.$el.parents(`.${swiper2.params.slideClass}`).length > 0 && swiper2.$el.parents(`.${swiper2.params.slideActiveClass}`).length === 0) {
          return void 0;
        }
        const $el = swiper2.$el;
        const swiperWidth = $el[0].clientWidth;
        const swiperHeight = $el[0].clientHeight;
        const windowWidth = window2.innerWidth;
        const windowHeight = window2.innerHeight;
        const swiperOffset = swiper2.$el.offset();
        if (rtl)
          swiperOffset.left -= swiper2.$el[0].scrollLeft;
        const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
        for (let i = 0; i < swiperCoord.length; i += 1) {
          const point = swiperCoord[i];
          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
            if (point[0] === 0 && point[1] === 0)
              continue;
            inView = true;
          }
        }
        if (!inView)
          return void 0;
      }
      if (swiper2.isHorizontal()) {
        if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
          if (e2.preventDefault)
            e2.preventDefault();
          else
            e2.returnValue = false;
        }
        if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl)
          swiper2.slideNext();
        if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl)
          swiper2.slidePrev();
      } else {
        if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
          if (e2.preventDefault)
            e2.preventDefault();
          else
            e2.returnValue = false;
        }
        if (isPageDown || isArrowDown)
          swiper2.slideNext();
        if (isPageUp || isArrowUp)
          swiper2.slidePrev();
      }
      emit("keyPress", kc);
      return void 0;
    }
    function enable() {
      if (swiper2.keyboard.enabled)
        return;
      dom_default(document2).on("keydown", handle);
      swiper2.keyboard.enabled = true;
    }
    function disable() {
      if (!swiper2.keyboard.enabled)
        return;
      dom_default(document2).off("keydown", handle);
      swiper2.keyboard.enabled = false;
    }
    on2("init", () => {
      if (swiper2.params.keyboard.enabled) {
        enable();
      }
    });
    on2("destroy", () => {
      if (swiper2.keyboard.enabled) {
        disable();
      }
    });
    Object.assign(swiper2.keyboard, {
      enable,
      disable
    });
  }

  // node_modules/swiper/modules/mousewheel/mousewheel.js
  function Mousewheel({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    const window2 = getWindow();
    extendParams({
      mousewheel: {
        enabled: false,
        releaseOnEdges: false,
        invert: false,
        forceToAxis: false,
        sensitivity: 1,
        eventsTarget: "container",
        thresholdDelta: null,
        thresholdTime: null
      }
    });
    swiper2.mousewheel = {
      enabled: false
    };
    let timeout;
    let lastScrollTime = now();
    let lastEventBeforeSnap;
    const recentWheelEvents = [];
    function normalize(e2) {
      const PIXEL_STEP = 10;
      const LINE_HEIGHT = 40;
      const PAGE_HEIGHT = 800;
      let sX = 0;
      let sY = 0;
      let pX = 0;
      let pY = 0;
      if ("detail" in e2) {
        sY = e2.detail;
      }
      if ("wheelDelta" in e2) {
        sY = -e2.wheelDelta / 120;
      }
      if ("wheelDeltaY" in e2) {
        sY = -e2.wheelDeltaY / 120;
      }
      if ("wheelDeltaX" in e2) {
        sX = -e2.wheelDeltaX / 120;
      }
      if ("axis" in e2 && e2.axis === e2.HORIZONTAL_AXIS) {
        sX = sY;
        sY = 0;
      }
      pX = sX * PIXEL_STEP;
      pY = sY * PIXEL_STEP;
      if ("deltaY" in e2) {
        pY = e2.deltaY;
      }
      if ("deltaX" in e2) {
        pX = e2.deltaX;
      }
      if (e2.shiftKey && !pX) {
        pX = pY;
        pY = 0;
      }
      if ((pX || pY) && e2.deltaMode) {
        if (e2.deltaMode === 1) {
          pX *= LINE_HEIGHT;
          pY *= LINE_HEIGHT;
        } else {
          pX *= PAGE_HEIGHT;
          pY *= PAGE_HEIGHT;
        }
      }
      if (pX && !sX) {
        sX = pX < 1 ? -1 : 1;
      }
      if (pY && !sY) {
        sY = pY < 1 ? -1 : 1;
      }
      return {
        spinX: sX,
        spinY: sY,
        pixelX: pX,
        pixelY: pY
      };
    }
    function handleMouseEnter() {
      if (!swiper2.enabled)
        return;
      swiper2.mouseEntered = true;
    }
    function handleMouseLeave() {
      if (!swiper2.enabled)
        return;
      swiper2.mouseEntered = false;
    }
    function animateSlider(newEvent) {
      if (swiper2.params.mousewheel.thresholdDelta && newEvent.delta < swiper2.params.mousewheel.thresholdDelta) {
        return false;
      }
      if (swiper2.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper2.params.mousewheel.thresholdTime) {
        return false;
      }
      if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
        return true;
      }
      if (newEvent.direction < 0) {
        if ((!swiper2.isEnd || swiper2.params.loop) && !swiper2.animating) {
          swiper2.slideNext();
          emit("scroll", newEvent.raw);
        }
      } else if ((!swiper2.isBeginning || swiper2.params.loop) && !swiper2.animating) {
        swiper2.slidePrev();
        emit("scroll", newEvent.raw);
      }
      lastScrollTime = new window2.Date().getTime();
      return false;
    }
    function releaseScroll(newEvent) {
      const params = swiper2.params.mousewheel;
      if (newEvent.direction < 0) {
        if (swiper2.isEnd && !swiper2.params.loop && params.releaseOnEdges) {
          return true;
        }
      } else if (swiper2.isBeginning && !swiper2.params.loop && params.releaseOnEdges) {
        return true;
      }
      return false;
    }
    function handle(event2) {
      let e2 = event2;
      let disableParentSwiper = true;
      if (!swiper2.enabled)
        return;
      const params = swiper2.params.mousewheel;
      if (swiper2.params.cssMode) {
        e2.preventDefault();
      }
      let target = swiper2.$el;
      if (swiper2.params.mousewheel.eventsTarget !== "container") {
        target = dom_default(swiper2.params.mousewheel.eventsTarget);
      }
      if (!swiper2.mouseEntered && !target[0].contains(e2.target) && !params.releaseOnEdges)
        return true;
      if (e2.originalEvent)
        e2 = e2.originalEvent;
      let delta = 0;
      const rtlFactor = swiper2.rtlTranslate ? -1 : 1;
      const data = normalize(e2);
      if (params.forceToAxis) {
        if (swiper2.isHorizontal()) {
          if (Math.abs(data.pixelX) > Math.abs(data.pixelY))
            delta = -data.pixelX * rtlFactor;
          else
            return true;
        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))
          delta = -data.pixelY;
        else
          return true;
      } else {
        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
      }
      if (delta === 0)
        return true;
      if (params.invert)
        delta = -delta;
      let positions = swiper2.getTranslate() + delta * params.sensitivity;
      if (positions >= swiper2.minTranslate())
        positions = swiper2.minTranslate();
      if (positions <= swiper2.maxTranslate())
        positions = swiper2.maxTranslate();
      disableParentSwiper = swiper2.params.loop ? true : !(positions === swiper2.minTranslate() || positions === swiper2.maxTranslate());
      if (disableParentSwiper && swiper2.params.nested)
        e2.stopPropagation();
      if (!swiper2.params.freeMode || !swiper2.params.freeMode.enabled) {
        const newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta),
          raw: event2
        };
        if (recentWheelEvents.length >= 2) {
          recentWheelEvents.shift();
        }
        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
        recentWheelEvents.push(newEvent);
        if (prevEvent) {
          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
            animateSlider(newEvent);
          }
        } else {
          animateSlider(newEvent);
        }
        if (releaseScroll(newEvent)) {
          return true;
        }
      } else {
        const newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta)
        };
        const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
        if (!ignoreWheelEvents) {
          lastEventBeforeSnap = void 0;
          if (swiper2.params.loop) {
            swiper2.loopFix();
          }
          let position = swiper2.getTranslate() + delta * params.sensitivity;
          const wasBeginning = swiper2.isBeginning;
          const wasEnd = swiper2.isEnd;
          if (position >= swiper2.minTranslate())
            position = swiper2.minTranslate();
          if (position <= swiper2.maxTranslate())
            position = swiper2.maxTranslate();
          swiper2.setTransition(0);
          swiper2.setTranslate(position);
          swiper2.updateProgress();
          swiper2.updateActiveIndex();
          swiper2.updateSlidesClasses();
          if (!wasBeginning && swiper2.isBeginning || !wasEnd && swiper2.isEnd) {
            swiper2.updateSlidesClasses();
          }
          if (swiper2.params.freeMode.sticky) {
            clearTimeout(timeout);
            timeout = void 0;
            if (recentWheelEvents.length >= 15) {
              recentWheelEvents.shift();
            }
            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
            const firstEvent = recentWheelEvents[0];
            recentWheelEvents.push(newEvent);
            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
              recentWheelEvents.splice(0);
            } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
              const snapToThreshold = delta > 0 ? 0.8 : 0.2;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              timeout = nextTick(() => {
                swiper2.slideToClosest(swiper2.params.speed, true, void 0, snapToThreshold);
              }, 0);
            }
            if (!timeout) {
              timeout = nextTick(() => {
                const snapToThreshold = 0.5;
                lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                swiper2.slideToClosest(swiper2.params.speed, true, void 0, snapToThreshold);
              }, 500);
            }
          }
          if (!ignoreWheelEvents)
            emit("scroll", e2);
          if (swiper2.params.autoplay && swiper2.params.autoplayDisableOnInteraction)
            swiper2.autoplay.stop();
          if (position === swiper2.minTranslate() || position === swiper2.maxTranslate())
            return true;
        }
      }
      if (e2.preventDefault)
        e2.preventDefault();
      else
        e2.returnValue = false;
      return false;
    }
    function events2(method) {
      let target = swiper2.$el;
      if (swiper2.params.mousewheel.eventsTarget !== "container") {
        target = dom_default(swiper2.params.mousewheel.eventsTarget);
      }
      target[method]("mouseenter", handleMouseEnter);
      target[method]("mouseleave", handleMouseLeave);
      target[method]("wheel", handle);
    }
    function enable() {
      if (swiper2.params.cssMode) {
        swiper2.wrapperEl.removeEventListener("wheel", handle);
        return true;
      }
      if (swiper2.mousewheel.enabled)
        return false;
      events2("on");
      swiper2.mousewheel.enabled = true;
      return true;
    }
    function disable() {
      if (swiper2.params.cssMode) {
        swiper2.wrapperEl.addEventListener(event, handle);
        return true;
      }
      if (!swiper2.mousewheel.enabled)
        return false;
      events2("off");
      swiper2.mousewheel.enabled = false;
      return true;
    }
    on2("init", () => {
      if (!swiper2.params.mousewheel.enabled && swiper2.params.cssMode) {
        disable();
      }
      if (swiper2.params.mousewheel.enabled)
        enable();
    });
    on2("destroy", () => {
      if (swiper2.params.cssMode) {
        enable();
      }
      if (swiper2.mousewheel.enabled)
        disable();
    });
    Object.assign(swiper2.mousewheel, {
      enable,
      disable
    });
  }

  // node_modules/swiper/shared/create-element-if-not-defined.js
  function createElementIfNotDefined(swiper2, originalParams, params, checkProps) {
    const document2 = getDocument();
    if (swiper2.params.createElements) {
      Object.keys(checkProps).forEach((key) => {
        if (!params[key] && params.auto === true) {
          let element = swiper2.$el.children(`.${checkProps[key]}`)[0];
          if (!element) {
            element = document2.createElement("div");
            element.className = checkProps[key];
            swiper2.$el.append(element);
          }
          params[key] = element;
          originalParams[key] = element;
        }
      });
    }
    return params;
  }

  // node_modules/swiper/modules/navigation/navigation.js
  function Navigation({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    extendParams({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    });
    swiper2.navigation = {
      nextEl: null,
      $nextEl: null,
      prevEl: null,
      $prevEl: null
    };
    function getEl(el) {
      let $el;
      if (el) {
        $el = dom_default(el);
        if (swiper2.params.uniqueNavElements && typeof el === "string" && $el.length > 1 && swiper2.$el.find(el).length === 1) {
          $el = swiper2.$el.find(el);
        }
      }
      return $el;
    }
    function toggleEl($el, disabled) {
      const params = swiper2.params.navigation;
      if ($el && $el.length > 0) {
        $el[disabled ? "addClass" : "removeClass"](params.disabledClass);
        if ($el[0] && $el[0].tagName === "BUTTON")
          $el[0].disabled = disabled;
        if (swiper2.params.watchOverflow && swiper2.enabled) {
          $el[swiper2.isLocked ? "addClass" : "removeClass"](params.lockClass);
        }
      }
    }
    function update2() {
      if (swiper2.params.loop)
        return;
      const {
        $nextEl,
        $prevEl
      } = swiper2.navigation;
      toggleEl($prevEl, swiper2.isBeginning && !swiper2.params.rewind);
      toggleEl($nextEl, swiper2.isEnd && !swiper2.params.rewind);
    }
    function onPrevClick(e2) {
      e2.preventDefault();
      if (swiper2.isBeginning && !swiper2.params.loop && !swiper2.params.rewind)
        return;
      swiper2.slidePrev();
      emit("navigationPrev");
    }
    function onNextClick(e2) {
      e2.preventDefault();
      if (swiper2.isEnd && !swiper2.params.loop && !swiper2.params.rewind)
        return;
      swiper2.slideNext();
      emit("navigationNext");
    }
    function init() {
      const params = swiper2.params.navigation;
      swiper2.params.navigation = createElementIfNotDefined(swiper2, swiper2.originalParams.navigation, swiper2.params.navigation, {
        nextEl: "swiper-button-next",
        prevEl: "swiper-button-prev"
      });
      if (!(params.nextEl || params.prevEl))
        return;
      const $nextEl = getEl(params.nextEl);
      const $prevEl = getEl(params.prevEl);
      if ($nextEl && $nextEl.length > 0) {
        $nextEl.on("click", onNextClick);
      }
      if ($prevEl && $prevEl.length > 0) {
        $prevEl.on("click", onPrevClick);
      }
      Object.assign(swiper2.navigation, {
        $nextEl,
        nextEl: $nextEl && $nextEl[0],
        $prevEl,
        prevEl: $prevEl && $prevEl[0]
      });
      if (!swiper2.enabled) {
        if ($nextEl)
          $nextEl.addClass(params.lockClass);
        if ($prevEl)
          $prevEl.addClass(params.lockClass);
      }
    }
    function destroy2() {
      const {
        $nextEl,
        $prevEl
      } = swiper2.navigation;
      if ($nextEl && $nextEl.length) {
        $nextEl.off("click", onNextClick);
        $nextEl.removeClass(swiper2.params.navigation.disabledClass);
      }
      if ($prevEl && $prevEl.length) {
        $prevEl.off("click", onPrevClick);
        $prevEl.removeClass(swiper2.params.navigation.disabledClass);
      }
    }
    on2("init", () => {
      if (swiper2.params.navigation.enabled === false) {
        disable();
      } else {
        init();
        update2();
      }
    });
    on2("toEdge fromEdge lock unlock", () => {
      update2();
    });
    on2("destroy", () => {
      destroy2();
    });
    on2("enable disable", () => {
      const {
        $nextEl,
        $prevEl
      } = swiper2.navigation;
      if ($nextEl) {
        $nextEl[swiper2.enabled ? "removeClass" : "addClass"](swiper2.params.navigation.lockClass);
      }
      if ($prevEl) {
        $prevEl[swiper2.enabled ? "removeClass" : "addClass"](swiper2.params.navigation.lockClass);
      }
    });
    on2("click", (_s, e2) => {
      const {
        $nextEl,
        $prevEl
      } = swiper2.navigation;
      const targetEl = e2.target;
      if (swiper2.params.navigation.hideOnClick && !dom_default(targetEl).is($prevEl) && !dom_default(targetEl).is($nextEl)) {
        if (swiper2.pagination && swiper2.params.pagination && swiper2.params.pagination.clickable && (swiper2.pagination.el === targetEl || swiper2.pagination.el.contains(targetEl)))
          return;
        let isHidden;
        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper2.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper2.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          emit("navigationShow");
        } else {
          emit("navigationHide");
        }
        if ($nextEl) {
          $nextEl.toggleClass(swiper2.params.navigation.hiddenClass);
        }
        if ($prevEl) {
          $prevEl.toggleClass(swiper2.params.navigation.hiddenClass);
        }
      }
    });
    const enable = () => {
      swiper2.$el.removeClass(swiper2.params.navigation.navigationDisabledClass);
      init();
      update2();
    };
    const disable = () => {
      swiper2.$el.addClass(swiper2.params.navigation.navigationDisabledClass);
      destroy2();
    };
    Object.assign(swiper2.navigation, {
      enable,
      disable,
      update: update2,
      init,
      destroy: destroy2
    });
  }

  // node_modules/swiper/shared/classes-to-selector.js
  function classesToSelector(classes = "") {
    return `.${classes.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`;
  }

  // node_modules/swiper/modules/pagination/pagination.js
  function Pagination({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    const pfx = "swiper-pagination";
    extendParams({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: "bullets",
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: (number) => number,
        formatFractionTotal: (number) => number,
        bulletClass: `${pfx}-bullet`,
        bulletActiveClass: `${pfx}-bullet-active`,
        modifierClass: `${pfx}-`,
        currentClass: `${pfx}-current`,
        totalClass: `${pfx}-total`,
        hiddenClass: `${pfx}-hidden`,
        progressbarFillClass: `${pfx}-progressbar-fill`,
        progressbarOppositeClass: `${pfx}-progressbar-opposite`,
        clickableClass: `${pfx}-clickable`,
        lockClass: `${pfx}-lock`,
        horizontalClass: `${pfx}-horizontal`,
        verticalClass: `${pfx}-vertical`,
        paginationDisabledClass: `${pfx}-disabled`
      }
    });
    swiper2.pagination = {
      el: null,
      $el: null,
      bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;
    function isPaginationDisabled() {
      return !swiper2.params.pagination.el || !swiper2.pagination.el || !swiper2.pagination.$el || swiper2.pagination.$el.length === 0;
    }
    function setSideBullets($bulletEl, position) {
      const {
        bulletActiveClass
      } = swiper2.params.pagination;
      $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
    }
    function update2() {
      const rtl = swiper2.rtl;
      const params = swiper2.params.pagination;
      if (isPaginationDisabled())
        return;
      const slidesLength = swiper2.virtual && swiper2.params.virtual.enabled ? swiper2.virtual.slides.length : swiper2.slides.length;
      const $el = swiper2.pagination.$el;
      let current;
      const total = swiper2.params.loop ? Math.ceil((slidesLength - swiper2.loopedSlides * 2) / swiper2.params.slidesPerGroup) : swiper2.snapGrid.length;
      if (swiper2.params.loop) {
        current = Math.ceil((swiper2.activeIndex - swiper2.loopedSlides) / swiper2.params.slidesPerGroup);
        if (current > slidesLength - 1 - swiper2.loopedSlides * 2) {
          current -= slidesLength - swiper2.loopedSlides * 2;
        }
        if (current > total - 1)
          current -= total;
        if (current < 0 && swiper2.params.paginationType !== "bullets")
          current = total + current;
      } else if (typeof swiper2.snapIndex !== "undefined") {
        current = swiper2.snapIndex;
      } else {
        current = swiper2.activeIndex || 0;
      }
      if (params.type === "bullets" && swiper2.pagination.bullets && swiper2.pagination.bullets.length > 0) {
        const bullets = swiper2.pagination.bullets;
        let firstIndex;
        let lastIndex;
        let midIndex;
        if (params.dynamicBullets) {
          bulletSize = bullets.eq(0)[swiper2.isHorizontal() ? "outerWidth" : "outerHeight"](true);
          $el.css(swiper2.isHorizontal() ? "width" : "height", `${bulletSize * (params.dynamicMainBullets + 4)}px`);
          if (params.dynamicMainBullets > 1 && swiper2.previousIndex !== void 0) {
            dynamicBulletIndex += current - (swiper2.previousIndex - swiper2.loopedSlides || 0);
            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
              dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (dynamicBulletIndex < 0) {
              dynamicBulletIndex = 0;
            }
          }
          firstIndex = Math.max(current - dynamicBulletIndex, 0);
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }
        bullets.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`).join(" "));
        if ($el.length > 1) {
          bullets.each((bullet) => {
            const $bullet = dom_default(bullet);
            const bulletIndex = $bullet.index();
            if (bulletIndex === current) {
              $bullet.addClass(params.bulletActiveClass);
            }
            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                $bullet.addClass(`${params.bulletActiveClass}-main`);
              }
              if (bulletIndex === firstIndex) {
                setSideBullets($bullet, "prev");
              }
              if (bulletIndex === lastIndex) {
                setSideBullets($bullet, "next");
              }
            }
          });
        } else {
          const $bullet = bullets.eq(current);
          const bulletIndex = $bullet.index();
          $bullet.addClass(params.bulletActiveClass);
          if (params.dynamicBullets) {
            const $firstDisplayedBullet = bullets.eq(firstIndex);
            const $lastDisplayedBullet = bullets.eq(lastIndex);
            for (let i = firstIndex; i <= lastIndex; i += 1) {
              bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
            }
            if (swiper2.params.loop) {
              if (bulletIndex >= bullets.length) {
                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                  bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                }
                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
              } else {
                setSideBullets($firstDisplayedBullet, "prev");
                setSideBullets($lastDisplayedBullet, "next");
              }
            } else {
              setSideBullets($firstDisplayedBullet, "prev");
              setSideBullets($lastDisplayedBullet, "next");
            }
          }
        }
        if (params.dynamicBullets) {
          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
          const offsetProp = rtl ? "right" : "left";
          bullets.css(swiper2.isHorizontal() ? offsetProp : "top", `${bulletsOffset}px`);
        }
      }
      if (params.type === "fraction") {
        $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
        $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
      }
      if (params.type === "progressbar") {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper2.isHorizontal() ? "vertical" : "horizontal";
        } else {
          progressbarDirection = swiper2.isHorizontal() ? "horizontal" : "vertical";
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === "horizontal") {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper2.params.speed);
      }
      if (params.type === "custom" && params.renderCustom) {
        $el.html(params.renderCustom(swiper2, current + 1, total));
        emit("paginationRender", $el[0]);
      } else {
        emit("paginationUpdate", $el[0]);
      }
      if (swiper2.params.watchOverflow && swiper2.enabled) {
        $el[swiper2.isLocked ? "addClass" : "removeClass"](params.lockClass);
      }
    }
    function render() {
      const params = swiper2.params.pagination;
      if (isPaginationDisabled())
        return;
      const slidesLength = swiper2.virtual && swiper2.params.virtual.enabled ? swiper2.virtual.slides.length : swiper2.slides.length;
      const $el = swiper2.pagination.$el;
      let paginationHTML = "";
      if (params.type === "bullets") {
        let numberOfBullets = swiper2.params.loop ? Math.ceil((slidesLength - swiper2.loopedSlides * 2) / swiper2.params.slidesPerGroup) : swiper2.snapGrid.length;
        if (swiper2.params.freeMode && swiper2.params.freeMode.enabled && !swiper2.params.loop && numberOfBullets > slidesLength) {
          numberOfBullets = slidesLength;
        }
        for (let i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper2, i, params.bulletClass);
          } else {
            paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
          }
        }
        $el.html(paginationHTML);
        swiper2.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
      }
      if (params.type === "fraction") {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper2, params.currentClass, params.totalClass);
        } else {
          paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
        }
        $el.html(paginationHTML);
      }
      if (params.type === "progressbar") {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper2, params.progressbarFillClass);
        } else {
          paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        }
        $el.html(paginationHTML);
      }
      if (params.type !== "custom") {
        emit("paginationRender", swiper2.pagination.$el[0]);
      }
    }
    function init() {
      swiper2.params.pagination = createElementIfNotDefined(swiper2, swiper2.originalParams.pagination, swiper2.params.pagination, {
        el: "swiper-pagination"
      });
      const params = swiper2.params.pagination;
      if (!params.el)
        return;
      let $el = dom_default(params.el);
      if ($el.length === 0)
        return;
      if (swiper2.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1) {
        $el = swiper2.$el.find(params.el);
        if ($el.length > 1) {
          $el = $el.filter((el) => {
            if (dom_default(el).parents(".swiper")[0] !== swiper2.el)
              return false;
            return true;
          });
        }
      }
      if (params.type === "bullets" && params.clickable) {
        $el.addClass(params.clickableClass);
      }
      $el.addClass(params.modifierClass + params.type);
      $el.addClass(swiper2.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === "bullets" && params.dynamicBullets) {
        $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === "progressbar" && params.progressbarOpposite) {
        $el.addClass(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        $el.on("click", classesToSelector(params.bulletClass), function onClick2(e2) {
          e2.preventDefault();
          let index2 = dom_default(this).index() * swiper2.params.slidesPerGroup;
          if (swiper2.params.loop)
            index2 += swiper2.loopedSlides;
          swiper2.slideTo(index2);
        });
      }
      Object.assign(swiper2.pagination, {
        $el,
        el: $el[0]
      });
      if (!swiper2.enabled) {
        $el.addClass(params.lockClass);
      }
    }
    function destroy2() {
      const params = swiper2.params.pagination;
      if (isPaginationDisabled())
        return;
      const $el = swiper2.pagination.$el;
      $el.removeClass(params.hiddenClass);
      $el.removeClass(params.modifierClass + params.type);
      $el.removeClass(swiper2.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (swiper2.pagination.bullets && swiper2.pagination.bullets.removeClass)
        swiper2.pagination.bullets.removeClass(params.bulletActiveClass);
      if (params.clickable) {
        $el.off("click", classesToSelector(params.bulletClass));
      }
    }
    on2("init", () => {
      if (swiper2.params.pagination.enabled === false) {
        disable();
      } else {
        init();
        render();
        update2();
      }
    });
    on2("activeIndexChange", () => {
      if (swiper2.params.loop) {
        update2();
      } else if (typeof swiper2.snapIndex === "undefined") {
        update2();
      }
    });
    on2("snapIndexChange", () => {
      if (!swiper2.params.loop) {
        update2();
      }
    });
    on2("slidesLengthChange", () => {
      if (swiper2.params.loop) {
        render();
        update2();
      }
    });
    on2("snapGridLengthChange", () => {
      if (!swiper2.params.loop) {
        render();
        update2();
      }
    });
    on2("destroy", () => {
      destroy2();
    });
    on2("enable disable", () => {
      const {
        $el
      } = swiper2.pagination;
      if ($el) {
        $el[swiper2.enabled ? "removeClass" : "addClass"](swiper2.params.pagination.lockClass);
      }
    });
    on2("lock unlock", () => {
      update2();
    });
    on2("click", (_s, e2) => {
      const targetEl = e2.target;
      const {
        $el
      } = swiper2.pagination;
      if (swiper2.params.pagination.el && swiper2.params.pagination.hideOnClick && $el && $el.length > 0 && !dom_default(targetEl).hasClass(swiper2.params.pagination.bulletClass)) {
        if (swiper2.navigation && (swiper2.navigation.nextEl && targetEl === swiper2.navigation.nextEl || swiper2.navigation.prevEl && targetEl === swiper2.navigation.prevEl))
          return;
        const isHidden = $el.hasClass(swiper2.params.pagination.hiddenClass);
        if (isHidden === true) {
          emit("paginationShow");
        } else {
          emit("paginationHide");
        }
        $el.toggleClass(swiper2.params.pagination.hiddenClass);
      }
    });
    const enable = () => {
      swiper2.$el.removeClass(swiper2.params.pagination.paginationDisabledClass);
      if (swiper2.pagination.$el) {
        swiper2.pagination.$el.removeClass(swiper2.params.pagination.paginationDisabledClass);
      }
      init();
      render();
      update2();
    };
    const disable = () => {
      swiper2.$el.addClass(swiper2.params.pagination.paginationDisabledClass);
      if (swiper2.pagination.$el) {
        swiper2.pagination.$el.addClass(swiper2.params.pagination.paginationDisabledClass);
      }
      destroy2();
    };
    Object.assign(swiper2.pagination, {
      enable,
      disable,
      render,
      update: update2,
      init,
      destroy: destroy2
    });
  }

  // node_modules/swiper/modules/scrollbar/scrollbar.js
  function Scrollbar({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    const document2 = getDocument();
    let isTouched = false;
    let timeout = null;
    let dragTimeout = null;
    let dragStartPos;
    let dragSize;
    let trackSize;
    let divider;
    extendParams({
      scrollbar: {
        el: null,
        dragSize: "auto",
        hide: false,
        draggable: false,
        snapOnRelease: true,
        lockClass: "swiper-scrollbar-lock",
        dragClass: "swiper-scrollbar-drag",
        scrollbarDisabledClass: "swiper-scrollbar-disabled",
        horizontalClass: `swiper-scrollbar-horizontal`,
        verticalClass: `swiper-scrollbar-vertical`
      }
    });
    swiper2.scrollbar = {
      el: null,
      dragEl: null,
      $el: null,
      $dragEl: null
    };
    function setTranslate2() {
      if (!swiper2.params.scrollbar.el || !swiper2.scrollbar.el)
        return;
      const {
        scrollbar,
        rtlTranslate: rtl,
        progress
      } = swiper2;
      const {
        $dragEl,
        $el
      } = scrollbar;
      const params = swiper2.params.scrollbar;
      let newSize = dragSize;
      let newPos = (trackSize - dragSize) * progress;
      if (rtl) {
        newPos = -newPos;
        if (newPos > 0) {
          newSize = dragSize - newPos;
          newPos = 0;
        } else if (-newPos + dragSize > trackSize) {
          newSize = trackSize + newPos;
        }
      } else if (newPos < 0) {
        newSize = dragSize + newPos;
        newPos = 0;
      } else if (newPos + dragSize > trackSize) {
        newSize = trackSize - newPos;
      }
      if (swiper2.isHorizontal()) {
        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
        $dragEl[0].style.width = `${newSize}px`;
      } else {
        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
        $dragEl[0].style.height = `${newSize}px`;
      }
      if (params.hide) {
        clearTimeout(timeout);
        $el[0].style.opacity = 1;
        timeout = setTimeout(() => {
          $el[0].style.opacity = 0;
          $el.transition(400);
        }, 1e3);
      }
    }
    function setTransition2(duration) {
      if (!swiper2.params.scrollbar.el || !swiper2.scrollbar.el)
        return;
      swiper2.scrollbar.$dragEl.transition(duration);
    }
    function updateSize2() {
      if (!swiper2.params.scrollbar.el || !swiper2.scrollbar.el)
        return;
      const {
        scrollbar
      } = swiper2;
      const {
        $dragEl,
        $el
      } = scrollbar;
      $dragEl[0].style.width = "";
      $dragEl[0].style.height = "";
      trackSize = swiper2.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
      divider = swiper2.size / (swiper2.virtualSize + swiper2.params.slidesOffsetBefore - (swiper2.params.centeredSlides ? swiper2.snapGrid[0] : 0));
      if (swiper2.params.scrollbar.dragSize === "auto") {
        dragSize = trackSize * divider;
      } else {
        dragSize = parseInt(swiper2.params.scrollbar.dragSize, 10);
      }
      if (swiper2.isHorizontal()) {
        $dragEl[0].style.width = `${dragSize}px`;
      } else {
        $dragEl[0].style.height = `${dragSize}px`;
      }
      if (divider >= 1) {
        $el[0].style.display = "none";
      } else {
        $el[0].style.display = "";
      }
      if (swiper2.params.scrollbar.hide) {
        $el[0].style.opacity = 0;
      }
      if (swiper2.params.watchOverflow && swiper2.enabled) {
        scrollbar.$el[swiper2.isLocked ? "addClass" : "removeClass"](swiper2.params.scrollbar.lockClass);
      }
    }
    function getPointerPosition(e2) {
      if (swiper2.isHorizontal()) {
        return e2.type === "touchstart" || e2.type === "touchmove" ? e2.targetTouches[0].clientX : e2.clientX;
      }
      return e2.type === "touchstart" || e2.type === "touchmove" ? e2.targetTouches[0].clientY : e2.clientY;
    }
    function setDragPosition(e2) {
      const {
        scrollbar,
        rtlTranslate: rtl
      } = swiper2;
      const {
        $el
      } = scrollbar;
      let positionRatio;
      positionRatio = (getPointerPosition(e2) - $el.offset()[swiper2.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
      positionRatio = Math.max(Math.min(positionRatio, 1), 0);
      if (rtl) {
        positionRatio = 1 - positionRatio;
      }
      const position = swiper2.minTranslate() + (swiper2.maxTranslate() - swiper2.minTranslate()) * positionRatio;
      swiper2.updateProgress(position);
      swiper2.setTranslate(position);
      swiper2.updateActiveIndex();
      swiper2.updateSlidesClasses();
    }
    function onDragStart(e2) {
      const params = swiper2.params.scrollbar;
      const {
        scrollbar,
        $wrapperEl
      } = swiper2;
      const {
        $el,
        $dragEl
      } = scrollbar;
      isTouched = true;
      dragStartPos = e2.target === $dragEl[0] || e2.target === $dragEl ? getPointerPosition(e2) - e2.target.getBoundingClientRect()[swiper2.isHorizontal() ? "left" : "top"] : null;
      e2.preventDefault();
      e2.stopPropagation();
      $wrapperEl.transition(100);
      $dragEl.transition(100);
      setDragPosition(e2);
      clearTimeout(dragTimeout);
      $el.transition(0);
      if (params.hide) {
        $el.css("opacity", 1);
      }
      if (swiper2.params.cssMode) {
        swiper2.$wrapperEl.css("scroll-snap-type", "none");
      }
      emit("scrollbarDragStart", e2);
    }
    function onDragMove(e2) {
      const {
        scrollbar,
        $wrapperEl
      } = swiper2;
      const {
        $el,
        $dragEl
      } = scrollbar;
      if (!isTouched)
        return;
      if (e2.preventDefault)
        e2.preventDefault();
      else
        e2.returnValue = false;
      setDragPosition(e2);
      $wrapperEl.transition(0);
      $el.transition(0);
      $dragEl.transition(0);
      emit("scrollbarDragMove", e2);
    }
    function onDragEnd(e2) {
      const params = swiper2.params.scrollbar;
      const {
        scrollbar,
        $wrapperEl
      } = swiper2;
      const {
        $el
      } = scrollbar;
      if (!isTouched)
        return;
      isTouched = false;
      if (swiper2.params.cssMode) {
        swiper2.$wrapperEl.css("scroll-snap-type", "");
        $wrapperEl.transition("");
      }
      if (params.hide) {
        clearTimeout(dragTimeout);
        dragTimeout = nextTick(() => {
          $el.css("opacity", 0);
          $el.transition(400);
        }, 1e3);
      }
      emit("scrollbarDragEnd", e2);
      if (params.snapOnRelease) {
        swiper2.slideToClosest();
      }
    }
    function events2(method) {
      const {
        scrollbar,
        touchEventsTouch,
        touchEventsDesktop,
        params,
        support: support2
      } = swiper2;
      const $el = scrollbar.$el;
      if (!$el)
        return;
      const target = $el[0];
      const activeListener = support2.passiveListener && params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      const passiveListener = support2.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      if (!target)
        return;
      const eventMethod = method === "on" ? "addEventListener" : "removeEventListener";
      if (!support2.touch) {
        target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
        document2[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
        document2[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
      } else {
        target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
        target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
        target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
      }
    }
    function enableDraggable() {
      if (!swiper2.params.scrollbar.el || !swiper2.scrollbar.el)
        return;
      events2("on");
    }
    function disableDraggable() {
      if (!swiper2.params.scrollbar.el || !swiper2.scrollbar.el)
        return;
      events2("off");
    }
    function init() {
      const {
        scrollbar,
        $el: $swiperEl
      } = swiper2;
      swiper2.params.scrollbar = createElementIfNotDefined(swiper2, swiper2.originalParams.scrollbar, swiper2.params.scrollbar, {
        el: "swiper-scrollbar"
      });
      const params = swiper2.params.scrollbar;
      if (!params.el)
        return;
      let $el = dom_default(params.el);
      if (swiper2.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
        $el = $swiperEl.find(params.el);
      }
      $el.addClass(swiper2.isHorizontal() ? params.horizontalClass : params.verticalClass);
      let $dragEl = $el.find(`.${swiper2.params.scrollbar.dragClass}`);
      if ($dragEl.length === 0) {
        $dragEl = dom_default(`<div class="${swiper2.params.scrollbar.dragClass}"></div>`);
        $el.append($dragEl);
      }
      Object.assign(scrollbar, {
        $el,
        el: $el[0],
        $dragEl,
        dragEl: $dragEl[0]
      });
      if (params.draggable) {
        enableDraggable();
      }
      if ($el) {
        $el[swiper2.enabled ? "removeClass" : "addClass"](swiper2.params.scrollbar.lockClass);
      }
    }
    function destroy2() {
      const params = swiper2.params.scrollbar;
      const $el = swiper2.scrollbar.$el;
      if ($el) {
        $el.removeClass(swiper2.isHorizontal() ? params.horizontalClass : params.verticalClass);
      }
      disableDraggable();
    }
    on2("init", () => {
      if (swiper2.params.scrollbar.enabled === false) {
        disable();
      } else {
        init();
        updateSize2();
        setTranslate2();
      }
    });
    on2("update resize observerUpdate lock unlock", () => {
      updateSize2();
    });
    on2("setTranslate", () => {
      setTranslate2();
    });
    on2("setTransition", (_s, duration) => {
      setTransition2(duration);
    });
    on2("enable disable", () => {
      const {
        $el
      } = swiper2.scrollbar;
      if ($el) {
        $el[swiper2.enabled ? "removeClass" : "addClass"](swiper2.params.scrollbar.lockClass);
      }
    });
    on2("destroy", () => {
      destroy2();
    });
    const enable = () => {
      swiper2.$el.removeClass(swiper2.params.scrollbar.scrollbarDisabledClass);
      if (swiper2.scrollbar.$el) {
        swiper2.scrollbar.$el.removeClass(swiper2.params.scrollbar.scrollbarDisabledClass);
      }
      init();
      updateSize2();
      setTranslate2();
    };
    const disable = () => {
      swiper2.$el.addClass(swiper2.params.scrollbar.scrollbarDisabledClass);
      if (swiper2.scrollbar.$el) {
        swiper2.scrollbar.$el.addClass(swiper2.params.scrollbar.scrollbarDisabledClass);
      }
      destroy2();
    };
    Object.assign(swiper2.scrollbar, {
      enable,
      disable,
      updateSize: updateSize2,
      setTranslate: setTranslate2,
      init,
      destroy: destroy2
    });
  }

  // node_modules/swiper/modules/parallax/parallax.js
  function Parallax({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      parallax: {
        enabled: false
      }
    });
    const setTransform = (el, progress) => {
      const {
        rtl
      } = swiper2;
      const $el = dom_default(el);
      const rtlFactor = rtl ? -1 : 1;
      const p = $el.attr("data-swiper-parallax") || "0";
      let x = $el.attr("data-swiper-parallax-x");
      let y = $el.attr("data-swiper-parallax-y");
      const scale = $el.attr("data-swiper-parallax-scale");
      const opacity = $el.attr("data-swiper-parallax-opacity");
      if (x || y) {
        x = x || "0";
        y = y || "0";
      } else if (swiper2.isHorizontal()) {
        x = p;
        y = "0";
      } else {
        y = p;
        x = "0";
      }
      if (x.indexOf("%") >= 0) {
        x = `${parseInt(x, 10) * progress * rtlFactor}%`;
      } else {
        x = `${x * progress * rtlFactor}px`;
      }
      if (y.indexOf("%") >= 0) {
        y = `${parseInt(y, 10) * progress}%`;
      } else {
        y = `${y * progress}px`;
      }
      if (typeof opacity !== "undefined" && opacity !== null) {
        const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
        $el[0].style.opacity = currentOpacity;
      }
      if (typeof scale === "undefined" || scale === null) {
        $el.transform(`translate3d(${x}, ${y}, 0px)`);
      } else {
        const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
        $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
      }
    };
    const setTranslate2 = () => {
      const {
        $el,
        slides,
        progress,
        snapGrid
      } = swiper2;
      $el.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((el) => {
        setTransform(el, progress);
      });
      slides.each((slideEl, slideIndex) => {
        let slideProgress = slideEl.progress;
        if (swiper2.params.slidesPerGroup > 1 && swiper2.params.slidesPerView !== "auto") {
          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
        }
        slideProgress = Math.min(Math.max(slideProgress, -1), 1);
        dom_default(slideEl).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((el) => {
          setTransform(el, slideProgress);
        });
      });
    };
    const setTransition2 = (duration = swiper2.params.speed) => {
      const {
        $el
      } = swiper2;
      $el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((parallaxEl) => {
        const $parallaxEl = dom_default(parallaxEl);
        let parallaxDuration = parseInt($parallaxEl.attr("data-swiper-parallax-duration"), 10) || duration;
        if (duration === 0)
          parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
    };
    on2("beforeInit", () => {
      if (!swiper2.params.parallax.enabled)
        return;
      swiper2.params.watchSlidesProgress = true;
      swiper2.originalParams.watchSlidesProgress = true;
    });
    on2("init", () => {
      if (!swiper2.params.parallax.enabled)
        return;
      setTranslate2();
    });
    on2("setTranslate", () => {
      if (!swiper2.params.parallax.enabled)
        return;
      setTranslate2();
    });
    on2("setTransition", (_swiper, duration) => {
      if (!swiper2.params.parallax.enabled)
        return;
      setTransition2(duration);
    });
  }

  // node_modules/swiper/modules/zoom/zoom.js
  function Zoom({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    const window2 = getWindow();
    extendParams({
      zoom: {
        enabled: false,
        maxRatio: 3,
        minRatio: 1,
        toggle: true,
        containerClass: "swiper-zoom-container",
        zoomedSlideClass: "swiper-slide-zoomed"
      }
    });
    swiper2.zoom = {
      enabled: false
    };
    let currentScale = 1;
    let isScaling = false;
    let gesturesEnabled;
    let fakeGestureTouched;
    let fakeGestureMoved;
    const gesture = {
      $slideEl: void 0,
      slideWidth: void 0,
      slideHeight: void 0,
      $imageEl: void 0,
      $imageWrapEl: void 0,
      maxRatio: 3
    };
    const image = {
      isTouched: void 0,
      isMoved: void 0,
      currentX: void 0,
      currentY: void 0,
      minX: void 0,
      minY: void 0,
      maxX: void 0,
      maxY: void 0,
      width: void 0,
      height: void 0,
      startX: void 0,
      startY: void 0,
      touchesStart: {},
      touchesCurrent: {}
    };
    const velocity = {
      x: void 0,
      y: void 0,
      prevPositionX: void 0,
      prevPositionY: void 0,
      prevTime: void 0
    };
    let scale = 1;
    Object.defineProperty(swiper2.zoom, "scale", {
      get() {
        return scale;
      },
      set(value2) {
        if (scale !== value2) {
          const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : void 0;
          const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : void 0;
          emit("zoomChange", value2, imageEl, slideEl);
        }
        scale = value2;
      }
    });
    function getDistanceBetweenTouches(e2) {
      if (e2.targetTouches.length < 2)
        return 1;
      const x1 = e2.targetTouches[0].pageX;
      const y1 = e2.targetTouches[0].pageY;
      const x2 = e2.targetTouches[1].pageX;
      const y2 = e2.targetTouches[1].pageY;
      const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      return distance;
    }
    function onGestureStart(e2) {
      const support2 = swiper2.support;
      const params = swiper2.params.zoom;
      fakeGestureTouched = false;
      fakeGestureMoved = false;
      if (!support2.gestures) {
        if (e2.type !== "touchstart" || e2.type === "touchstart" && e2.targetTouches.length < 2) {
          return;
        }
        fakeGestureTouched = true;
        gesture.scaleStart = getDistanceBetweenTouches(e2);
      }
      if (!gesture.$slideEl || !gesture.$slideEl.length) {
        gesture.$slideEl = dom_default(e2.target).closest(`.${swiper2.params.slideClass}`);
        if (gesture.$slideEl.length === 0)
          gesture.$slideEl = swiper2.slides.eq(swiper2.activeIndex);
        gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0);
        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
        gesture.maxRatio = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
        if (gesture.$imageWrapEl.length === 0) {
          gesture.$imageEl = void 0;
          return;
        }
      }
      if (gesture.$imageEl) {
        gesture.$imageEl.transition(0);
      }
      isScaling = true;
    }
    function onGestureChange(e2) {
      const support2 = swiper2.support;
      const params = swiper2.params.zoom;
      const zoom = swiper2.zoom;
      if (!support2.gestures) {
        if (e2.type !== "touchmove" || e2.type === "touchmove" && e2.targetTouches.length < 2) {
          return;
        }
        fakeGestureMoved = true;
        gesture.scaleMove = getDistanceBetweenTouches(e2);
      }
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        if (e2.type === "gesturechange")
          onGestureStart(e2);
        return;
      }
      if (support2.gestures) {
        zoom.scale = e2.scale * currentScale;
      } else {
        zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
      }
      if (zoom.scale > gesture.maxRatio) {
        zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
      }
      if (zoom.scale < params.minRatio) {
        zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
      }
      gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    }
    function onGestureEnd(e2) {
      const device = swiper2.device;
      const support2 = swiper2.support;
      const params = swiper2.params.zoom;
      const zoom = swiper2.zoom;
      if (!support2.gestures) {
        if (!fakeGestureTouched || !fakeGestureMoved) {
          return;
        }
        if (e2.type !== "touchend" || e2.type === "touchend" && e2.changedTouches.length < 2 && !device.android) {
          return;
        }
        fakeGestureTouched = false;
        fakeGestureMoved = false;
      }
      if (!gesture.$imageEl || gesture.$imageEl.length === 0)
        return;
      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
      gesture.$imageEl.transition(swiper2.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
      currentScale = zoom.scale;
      isScaling = false;
      if (zoom.scale === 1)
        gesture.$slideEl = void 0;
    }
    function onTouchStart2(e2) {
      const device = swiper2.device;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0)
        return;
      if (image.isTouched)
        return;
      if (device.android && e2.cancelable)
        e2.preventDefault();
      image.isTouched = true;
      image.touchesStart.x = e2.type === "touchstart" ? e2.targetTouches[0].pageX : e2.pageX;
      image.touchesStart.y = e2.type === "touchstart" ? e2.targetTouches[0].pageY : e2.pageY;
    }
    function onTouchMove2(e2) {
      const zoom = swiper2.zoom;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0)
        return;
      swiper2.allowClick = false;
      if (!image.isTouched || !gesture.$slideEl)
        return;
      if (!image.isMoved) {
        image.width = gesture.$imageEl[0].offsetWidth;
        image.height = gesture.$imageEl[0].offsetHeight;
        image.startX = getTranslate(gesture.$imageWrapEl[0], "x") || 0;
        image.startY = getTranslate(gesture.$imageWrapEl[0], "y") || 0;
        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
        gesture.$imageWrapEl.transition(0);
      }
      const scaledWidth = image.width * zoom.scale;
      const scaledHeight = image.height * zoom.scale;
      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight)
        return;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.touchesCurrent.x = e2.type === "touchmove" ? e2.targetTouches[0].pageX : e2.pageX;
      image.touchesCurrent.y = e2.type === "touchmove" ? e2.targetTouches[0].pageY : e2.pageY;
      if (!image.isMoved && !isScaling) {
        if (swiper2.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
          image.isTouched = false;
          return;
        }
        if (!swiper2.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
          image.isTouched = false;
          return;
        }
      }
      if (e2.cancelable) {
        e2.preventDefault();
      }
      e2.stopPropagation();
      image.isMoved = true;
      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
      if (image.currentX < image.minX) {
        image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
      }
      if (image.currentX > image.maxX) {
        image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
      }
      if (image.currentY < image.minY) {
        image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
      }
      if (image.currentY > image.maxY) {
        image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
      }
      if (!velocity.prevPositionX)
        velocity.prevPositionX = image.touchesCurrent.x;
      if (!velocity.prevPositionY)
        velocity.prevPositionY = image.touchesCurrent.y;
      if (!velocity.prevTime)
        velocity.prevTime = Date.now();
      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)
        velocity.x = 0;
      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)
        velocity.y = 0;
      velocity.prevPositionX = image.touchesCurrent.x;
      velocity.prevPositionY = image.touchesCurrent.y;
      velocity.prevTime = Date.now();
      gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
    }
    function onTouchEnd2() {
      const zoom = swiper2.zoom;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0)
        return;
      if (!image.isTouched || !image.isMoved) {
        image.isTouched = false;
        image.isMoved = false;
        return;
      }
      image.isTouched = false;
      image.isMoved = false;
      let momentumDurationX = 300;
      let momentumDurationY = 300;
      const momentumDistanceX = velocity.x * momentumDurationX;
      const newPositionX = image.currentX + momentumDistanceX;
      const momentumDistanceY = velocity.y * momentumDurationY;
      const newPositionY = image.currentY + momentumDistanceY;
      if (velocity.x !== 0)
        momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
      if (velocity.y !== 0)
        momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
      const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
      image.currentX = newPositionX;
      image.currentY = newPositionY;
      const scaledWidth = image.width * zoom.scale;
      const scaledHeight = image.height * zoom.scale;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
      gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
    }
    function onTransitionEnd() {
      const zoom = swiper2.zoom;
      if (gesture.$slideEl && swiper2.previousIndex !== swiper2.activeIndex) {
        if (gesture.$imageEl) {
          gesture.$imageEl.transform("translate3d(0,0,0) scale(1)");
        }
        if (gesture.$imageWrapEl) {
          gesture.$imageWrapEl.transform("translate3d(0,0,0)");
        }
        zoom.scale = 1;
        currentScale = 1;
        gesture.$slideEl = void 0;
        gesture.$imageEl = void 0;
        gesture.$imageWrapEl = void 0;
      }
    }
    function zoomIn(e2) {
      const zoom = swiper2.zoom;
      const params = swiper2.params.zoom;
      if (!gesture.$slideEl) {
        if (e2 && e2.target) {
          gesture.$slideEl = dom_default(e2.target).closest(`.${swiper2.params.slideClass}`);
        }
        if (!gesture.$slideEl) {
          if (swiper2.params.virtual && swiper2.params.virtual.enabled && swiper2.virtual) {
            gesture.$slideEl = swiper2.$wrapperEl.children(`.${swiper2.params.slideActiveClass}`);
          } else {
            gesture.$slideEl = swiper2.slides.eq(swiper2.activeIndex);
          }
        }
        gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0);
        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      }
      if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0)
        return;
      if (swiper2.params.cssMode) {
        swiper2.wrapperEl.style.overflow = "hidden";
        swiper2.wrapperEl.style.touchAction = "none";
      }
      gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
      let touchX;
      let touchY;
      let offsetX;
      let offsetY;
      let diffX;
      let diffY;
      let translateX;
      let translateY;
      let imageWidth;
      let imageHeight;
      let scaledWidth;
      let scaledHeight;
      let translateMinX;
      let translateMinY;
      let translateMaxX;
      let translateMaxY;
      let slideWidth;
      let slideHeight;
      if (typeof image.touchesStart.x === "undefined" && e2) {
        touchX = e2.type === "touchend" ? e2.changedTouches[0].pageX : e2.pageX;
        touchY = e2.type === "touchend" ? e2.changedTouches[0].pageY : e2.pageY;
      } else {
        touchX = image.touchesStart.x;
        touchY = image.touchesStart.y;
      }
      zoom.scale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
      currentScale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
      if (e2) {
        slideWidth = gesture.$slideEl[0].offsetWidth;
        slideHeight = gesture.$slideEl[0].offsetHeight;
        offsetX = gesture.$slideEl.offset().left + window2.scrollX;
        offsetY = gesture.$slideEl.offset().top + window2.scrollY;
        diffX = offsetX + slideWidth / 2 - touchX;
        diffY = offsetY + slideHeight / 2 - touchY;
        imageWidth = gesture.$imageEl[0].offsetWidth;
        imageHeight = gesture.$imageEl[0].offsetHeight;
        scaledWidth = imageWidth * zoom.scale;
        scaledHeight = imageHeight * zoom.scale;
        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
        translateMaxX = -translateMinX;
        translateMaxY = -translateMinY;
        translateX = diffX * zoom.scale;
        translateY = diffY * zoom.scale;
        if (translateX < translateMinX) {
          translateX = translateMinX;
        }
        if (translateX > translateMaxX) {
          translateX = translateMaxX;
        }
        if (translateY < translateMinY) {
          translateY = translateMinY;
        }
        if (translateY > translateMaxY) {
          translateY = translateMaxY;
        }
      } else {
        translateX = 0;
        translateY = 0;
      }
      gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
      gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    }
    function zoomOut() {
      const zoom = swiper2.zoom;
      const params = swiper2.params.zoom;
      if (!gesture.$slideEl) {
        if (swiper2.params.virtual && swiper2.params.virtual.enabled && swiper2.virtual) {
          gesture.$slideEl = swiper2.$wrapperEl.children(`.${swiper2.params.slideActiveClass}`);
        } else {
          gesture.$slideEl = swiper2.slides.eq(swiper2.activeIndex);
        }
        gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0);
        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      }
      if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0)
        return;
      if (swiper2.params.cssMode) {
        swiper2.wrapperEl.style.overflow = "";
        swiper2.wrapperEl.style.touchAction = "";
      }
      zoom.scale = 1;
      currentScale = 1;
      gesture.$imageWrapEl.transition(300).transform("translate3d(0,0,0)");
      gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)");
      gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
      gesture.$slideEl = void 0;
    }
    function zoomToggle(e2) {
      const zoom = swiper2.zoom;
      if (zoom.scale && zoom.scale !== 1) {
        zoomOut();
      } else {
        zoomIn(e2);
      }
    }
    function getListeners() {
      const support2 = swiper2.support;
      const passiveListener = swiper2.touchEvents.start === "touchstart" && support2.passiveListener && swiper2.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      const activeListenerWithCapture = support2.passiveListener ? {
        passive: false,
        capture: true
      } : true;
      return {
        passiveListener,
        activeListenerWithCapture
      };
    }
    function getSlideSelector() {
      return `.${swiper2.params.slideClass}`;
    }
    function toggleGestures(method) {
      const {
        passiveListener
      } = getListeners();
      const slideSelector = getSlideSelector();
      swiper2.$wrapperEl[method]("gesturestart", slideSelector, onGestureStart, passiveListener);
      swiper2.$wrapperEl[method]("gesturechange", slideSelector, onGestureChange, passiveListener);
      swiper2.$wrapperEl[method]("gestureend", slideSelector, onGestureEnd, passiveListener);
    }
    function enableGestures() {
      if (gesturesEnabled)
        return;
      gesturesEnabled = true;
      toggleGestures("on");
    }
    function disableGestures() {
      if (!gesturesEnabled)
        return;
      gesturesEnabled = false;
      toggleGestures("off");
    }
    function enable() {
      const zoom = swiper2.zoom;
      if (zoom.enabled)
        return;
      zoom.enabled = true;
      const support2 = swiper2.support;
      const {
        passiveListener,
        activeListenerWithCapture
      } = getListeners();
      const slideSelector = getSlideSelector();
      if (support2.gestures) {
        swiper2.$wrapperEl.on(swiper2.touchEvents.start, enableGestures, passiveListener);
        swiper2.$wrapperEl.on(swiper2.touchEvents.end, disableGestures, passiveListener);
      } else if (swiper2.touchEvents.start === "touchstart") {
        swiper2.$wrapperEl.on(swiper2.touchEvents.start, slideSelector, onGestureStart, passiveListener);
        swiper2.$wrapperEl.on(swiper2.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
        swiper2.$wrapperEl.on(swiper2.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
        if (swiper2.touchEvents.cancel) {
          swiper2.$wrapperEl.on(swiper2.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
        }
      }
      swiper2.$wrapperEl.on(swiper2.touchEvents.move, `.${swiper2.params.zoom.containerClass}`, onTouchMove2, activeListenerWithCapture);
    }
    function disable() {
      const zoom = swiper2.zoom;
      if (!zoom.enabled)
        return;
      const support2 = swiper2.support;
      zoom.enabled = false;
      const {
        passiveListener,
        activeListenerWithCapture
      } = getListeners();
      const slideSelector = getSlideSelector();
      if (support2.gestures) {
        swiper2.$wrapperEl.off(swiper2.touchEvents.start, enableGestures, passiveListener);
        swiper2.$wrapperEl.off(swiper2.touchEvents.end, disableGestures, passiveListener);
      } else if (swiper2.touchEvents.start === "touchstart") {
        swiper2.$wrapperEl.off(swiper2.touchEvents.start, slideSelector, onGestureStart, passiveListener);
        swiper2.$wrapperEl.off(swiper2.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
        swiper2.$wrapperEl.off(swiper2.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
        if (swiper2.touchEvents.cancel) {
          swiper2.$wrapperEl.off(swiper2.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
        }
      }
      swiper2.$wrapperEl.off(swiper2.touchEvents.move, `.${swiper2.params.zoom.containerClass}`, onTouchMove2, activeListenerWithCapture);
    }
    on2("init", () => {
      if (swiper2.params.zoom.enabled) {
        enable();
      }
    });
    on2("destroy", () => {
      disable();
    });
    on2("touchStart", (_s, e2) => {
      if (!swiper2.zoom.enabled)
        return;
      onTouchStart2(e2);
    });
    on2("touchEnd", (_s, e2) => {
      if (!swiper2.zoom.enabled)
        return;
      onTouchEnd2(e2);
    });
    on2("doubleTap", (_s, e2) => {
      if (!swiper2.animating && swiper2.params.zoom.enabled && swiper2.zoom.enabled && swiper2.params.zoom.toggle) {
        zoomToggle(e2);
      }
    });
    on2("transitionEnd", () => {
      if (swiper2.zoom.enabled && swiper2.params.zoom.enabled) {
        onTransitionEnd();
      }
    });
    on2("slideChange", () => {
      if (swiper2.zoom.enabled && swiper2.params.zoom.enabled && swiper2.params.cssMode) {
        onTransitionEnd();
      }
    });
    Object.assign(swiper2.zoom, {
      enable,
      disable,
      in: zoomIn,
      out: zoomOut,
      toggle: zoomToggle
    });
  }

  // node_modules/swiper/modules/lazy/lazy.js
  function Lazy({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    extendParams({
      lazy: {
        checkInView: false,
        enabled: false,
        loadPrevNext: false,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: false,
        scrollingElement: "",
        elementClass: "swiper-lazy",
        loadingClass: "swiper-lazy-loading",
        loadedClass: "swiper-lazy-loaded",
        preloaderClass: "swiper-lazy-preloader"
      }
    });
    swiper2.lazy = {};
    let scrollHandlerAttached = false;
    let initialImageLoaded = false;
    function loadInSlide(index2, loadInDuplicate = true) {
      const params = swiper2.params.lazy;
      if (typeof index2 === "undefined")
        return;
      if (swiper2.slides.length === 0)
        return;
      const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
      const $slideEl = isVirtual ? swiper2.$wrapperEl.children(`.${swiper2.params.slideClass}[data-swiper-slide-index="${index2}"]`) : swiper2.slides.eq(index2);
      const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
        $images.push($slideEl[0]);
      }
      if ($images.length === 0)
        return;
      $images.each((imageEl) => {
        const $imageEl = dom_default(imageEl);
        $imageEl.addClass(params.loadingClass);
        const background = $imageEl.attr("data-background");
        const src = $imageEl.attr("data-src");
        const srcset = $imageEl.attr("data-srcset");
        const sizes = $imageEl.attr("data-sizes");
        const $pictureEl = $imageEl.parent("picture");
        swiper2.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
          if (typeof swiper2 === "undefined" || swiper2 === null || !swiper2 || swiper2 && !swiper2.params || swiper2.destroyed)
            return;
          if (background) {
            $imageEl.css("background-image", `url("${background}")`);
            $imageEl.removeAttr("data-background");
          } else {
            if (srcset) {
              $imageEl.attr("srcset", srcset);
              $imageEl.removeAttr("data-srcset");
            }
            if (sizes) {
              $imageEl.attr("sizes", sizes);
              $imageEl.removeAttr("data-sizes");
            }
            if ($pictureEl.length) {
              $pictureEl.children("source").each((sourceEl) => {
                const $source = dom_default(sourceEl);
                if ($source.attr("data-srcset")) {
                  $source.attr("srcset", $source.attr("data-srcset"));
                  $source.removeAttr("data-srcset");
                }
              });
            }
            if (src) {
              $imageEl.attr("src", src);
              $imageEl.removeAttr("data-src");
            }
          }
          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
          $slideEl.find(`.${params.preloaderClass}`).remove();
          if (swiper2.params.loop && loadInDuplicate) {
            const slideOriginalIndex = $slideEl.attr("data-swiper-slide-index");
            if ($slideEl.hasClass(swiper2.params.slideDuplicateClass)) {
              const originalSlide = swiper2.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper2.params.slideDuplicateClass})`);
              loadInSlide(originalSlide.index(), false);
            } else {
              const duplicatedSlide = swiper2.$wrapperEl.children(`.${swiper2.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
              loadInSlide(duplicatedSlide.index(), false);
            }
          }
          emit("lazyImageReady", $slideEl[0], $imageEl[0]);
          if (swiper2.params.autoHeight) {
            swiper2.updateAutoHeight();
          }
        });
        emit("lazyImageLoad", $slideEl[0], $imageEl[0]);
      });
    }
    function load() {
      const {
        $wrapperEl,
        params: swiperParams,
        slides,
        activeIndex
      } = swiper2;
      const isVirtual = swiper2.virtual && swiperParams.virtual.enabled;
      const params = swiperParams.lazy;
      let slidesPerView = swiperParams.slidesPerView;
      if (slidesPerView === "auto") {
        slidesPerView = 0;
      }
      function slideExist(index2) {
        if (isVirtual) {
          if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index2}"]`).length) {
            return true;
          }
        } else if (slides[index2])
          return true;
        return false;
      }
      function slideIndex(slideEl) {
        if (isVirtual) {
          return dom_default(slideEl).attr("data-swiper-slide-index");
        }
        return dom_default(slideEl).index();
      }
      if (!initialImageLoaded)
        initialImageLoaded = true;
      if (swiper2.params.watchSlidesProgress) {
        $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((slideEl) => {
          const index2 = isVirtual ? dom_default(slideEl).attr("data-swiper-slide-index") : dom_default(slideEl).index();
          loadInSlide(index2);
        });
      } else if (slidesPerView > 1) {
        for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
          if (slideExist(i))
            loadInSlide(i);
        }
      } else {
        loadInSlide(activeIndex);
      }
      if (params.loadPrevNext) {
        if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
          const amount = params.loadPrevNextAmount;
          const spv = Math.ceil(slidesPerView);
          const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
          const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
          for (let i = activeIndex + spv; i < maxIndex; i += 1) {
            if (slideExist(i))
              loadInSlide(i);
          }
          for (let i = minIndex; i < activeIndex; i += 1) {
            if (slideExist(i))
              loadInSlide(i);
          }
        } else {
          const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
          if (nextSlide.length > 0)
            loadInSlide(slideIndex(nextSlide));
          const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
          if (prevSlide.length > 0)
            loadInSlide(slideIndex(prevSlide));
        }
      }
    }
    function checkInViewOnLoad() {
      const window2 = getWindow();
      if (!swiper2 || swiper2.destroyed)
        return;
      const $scrollElement = swiper2.params.lazy.scrollingElement ? dom_default(swiper2.params.lazy.scrollingElement) : dom_default(window2);
      const isWindow = $scrollElement[0] === window2;
      const scrollElementWidth = isWindow ? window2.innerWidth : $scrollElement[0].offsetWidth;
      const scrollElementHeight = isWindow ? window2.innerHeight : $scrollElement[0].offsetHeight;
      const swiperOffset = swiper2.$el.offset();
      const {
        rtlTranslate: rtl
      } = swiper2;
      let inView = false;
      if (rtl)
        swiperOffset.left -= swiper2.$el[0].scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper2.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper2.height], [swiperOffset.left + swiper2.width, swiperOffset.top + swiper2.height]];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
          if (point[0] === 0 && point[1] === 0)
            continue;
          inView = true;
        }
      }
      const passiveListener = swiper2.touchEvents.start === "touchstart" && swiper2.support.passiveListener && swiper2.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      if (inView) {
        load();
        $scrollElement.off("scroll", checkInViewOnLoad, passiveListener);
      } else if (!scrollHandlerAttached) {
        scrollHandlerAttached = true;
        $scrollElement.on("scroll", checkInViewOnLoad, passiveListener);
      }
    }
    on2("beforeInit", () => {
      if (swiper2.params.lazy.enabled && swiper2.params.preloadImages) {
        swiper2.params.preloadImages = false;
      }
    });
    on2("init", () => {
      if (swiper2.params.lazy.enabled) {
        if (swiper2.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    });
    on2("scroll", () => {
      if (swiper2.params.freeMode && swiper2.params.freeMode.enabled && !swiper2.params.freeMode.sticky) {
        load();
      }
    });
    on2("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
      if (swiper2.params.lazy.enabled) {
        if (swiper2.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    });
    on2("transitionStart", () => {
      if (swiper2.params.lazy.enabled) {
        if (swiper2.params.lazy.loadOnTransitionStart || !swiper2.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
          if (swiper2.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      }
    });
    on2("transitionEnd", () => {
      if (swiper2.params.lazy.enabled && !swiper2.params.lazy.loadOnTransitionStart) {
        if (swiper2.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    });
    on2("slideChange", () => {
      const {
        lazy,
        cssMode,
        watchSlidesProgress,
        touchReleaseOnEdges,
        resistanceRatio
      } = swiper2.params;
      if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
        load();
      }
    });
    on2("destroy", () => {
      if (!swiper2.$el)
        return;
      swiper2.$el.find(`.${swiper2.params.lazy.loadingClass}`).removeClass(swiper2.params.lazy.loadingClass);
    });
    Object.assign(swiper2.lazy, {
      load,
      loadInSlide
    });
  }

  // node_modules/swiper/modules/controller/controller.js
  function Controller({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      controller: {
        control: void 0,
        inverse: false,
        by: "slide"
      }
    });
    swiper2.controller = {
      control: void 0
    };
    function LinearSpline(x, y) {
      const binarySearch = function search() {
        let maxIndex;
        let minIndex;
        let guess;
        return (array, val) => {
          minIndex = -1;
          maxIndex = array.length;
          while (maxIndex - minIndex > 1) {
            guess = maxIndex + minIndex >> 1;
            if (array[guess] <= val) {
              minIndex = guess;
            } else {
              maxIndex = guess;
            }
          }
          return maxIndex;
        };
      }();
      this.x = x;
      this.y = y;
      this.lastIndex = x.length - 1;
      let i1;
      let i3;
      this.interpolate = function interpolate(x2) {
        if (!x2)
          return 0;
        i3 = binarySearch(this.x, x2);
        i1 = i3 - 1;
        return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
      };
      return this;
    }
    function getInterpolateFunction(c) {
      if (!swiper2.controller.spline) {
        swiper2.controller.spline = swiper2.params.loop ? new LinearSpline(swiper2.slidesGrid, c.slidesGrid) : new LinearSpline(swiper2.snapGrid, c.snapGrid);
      }
    }
    function setTranslate2(_t, byController) {
      const controlled = swiper2.controller.control;
      let multiplier;
      let controlledTranslate;
      const Swiper2 = swiper2.constructor;
      function setControlledTranslate(c) {
        const translate = swiper2.rtlTranslate ? -swiper2.translate : swiper2.translate;
        if (swiper2.params.controller.by === "slide") {
          getInterpolateFunction(c);
          controlledTranslate = -swiper2.controller.spline.interpolate(-translate);
        }
        if (!controlledTranslate || swiper2.params.controller.by === "container") {
          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper2.maxTranslate() - swiper2.minTranslate());
          controlledTranslate = (translate - swiper2.minTranslate()) * multiplier + c.minTranslate();
        }
        if (swiper2.params.controller.inverse) {
          controlledTranslate = c.maxTranslate() - controlledTranslate;
        }
        c.updateProgress(controlledTranslate);
        c.setTranslate(controlledTranslate, swiper2);
        c.updateActiveIndex();
        c.updateSlidesClasses();
      }
      if (Array.isArray(controlled)) {
        for (let i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {
            setControlledTranslate(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper2 && byController !== controlled) {
        setControlledTranslate(controlled);
      }
    }
    function setTransition2(duration, byController) {
      const Swiper2 = swiper2.constructor;
      const controlled = swiper2.controller.control;
      let i;
      function setControlledTransition(c) {
        c.setTransition(duration, swiper2);
        if (duration !== 0) {
          c.transitionStart();
          if (c.params.autoHeight) {
            nextTick(() => {
              c.updateAutoHeight();
            });
          }
          c.$wrapperEl.transitionEnd(() => {
            if (!controlled)
              return;
            if (c.params.loop && swiper2.params.controller.by === "slide") {
              c.loopFix();
            }
            c.transitionEnd();
          });
        }
      }
      if (Array.isArray(controlled)) {
        for (i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {
            setControlledTransition(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper2 && byController !== controlled) {
        setControlledTransition(controlled);
      }
    }
    function removeSpline() {
      if (!swiper2.controller.control)
        return;
      if (swiper2.controller.spline) {
        swiper2.controller.spline = void 0;
        delete swiper2.controller.spline;
      }
    }
    on2("beforeInit", () => {
      swiper2.controller.control = swiper2.params.controller.control;
    });
    on2("update", () => {
      removeSpline();
    });
    on2("resize", () => {
      removeSpline();
    });
    on2("observerUpdate", () => {
      removeSpline();
    });
    on2("setTranslate", (_s, translate, byController) => {
      if (!swiper2.controller.control)
        return;
      swiper2.controller.setTranslate(translate, byController);
    });
    on2("setTransition", (_s, duration, byController) => {
      if (!swiper2.controller.control)
        return;
      swiper2.controller.setTransition(duration, byController);
    });
    Object.assign(swiper2.controller, {
      setTranslate: setTranslate2,
      setTransition: setTransition2
    });
  }

  // node_modules/swiper/modules/a11y/a11y.js
  function A11y({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      a11y: {
        enabled: true,
        notificationClass: "swiper-notification",
        prevSlideMessage: "Previous slide",
        nextSlideMessage: "Next slide",
        firstSlideMessage: "This is the first slide",
        lastSlideMessage: "This is the last slide",
        paginationBulletMessage: "Go to slide {{index}}",
        slideLabelMessage: "{{index}} / {{slidesLength}}",
        containerMessage: null,
        containerRoleDescriptionMessage: null,
        itemRoleDescriptionMessage: null,
        slideRole: "group",
        id: null
      }
    });
    swiper2.a11y = {
      clicked: false
    };
    let liveRegion = null;
    function notify(message) {
      const notification = liveRegion;
      if (notification.length === 0)
        return;
      notification.html("");
      notification.html(message);
    }
    function getRandomNumber(size = 16) {
      const randomChar = () => Math.round(16 * Math.random()).toString(16);
      return "x".repeat(size).replace(/x/g, randomChar);
    }
    function makeElFocusable($el) {
      $el.attr("tabIndex", "0");
    }
    function makeElNotFocusable($el) {
      $el.attr("tabIndex", "-1");
    }
    function addElRole($el, role) {
      $el.attr("role", role);
    }
    function addElRoleDescription($el, description) {
      $el.attr("aria-roledescription", description);
    }
    function addElControls($el, controls) {
      $el.attr("aria-controls", controls);
    }
    function addElLabel($el, label) {
      $el.attr("aria-label", label);
    }
    function addElId($el, id) {
      $el.attr("id", id);
    }
    function addElLive($el, live) {
      $el.attr("aria-live", live);
    }
    function disableEl($el) {
      $el.attr("aria-disabled", true);
    }
    function enableEl($el) {
      $el.attr("aria-disabled", false);
    }
    function onEnterOrSpaceKey(e2) {
      if (e2.keyCode !== 13 && e2.keyCode !== 32)
        return;
      const params = swiper2.params.a11y;
      const $targetEl = dom_default(e2.target);
      if (swiper2.navigation && swiper2.navigation.$nextEl && $targetEl.is(swiper2.navigation.$nextEl)) {
        if (!(swiper2.isEnd && !swiper2.params.loop)) {
          swiper2.slideNext();
        }
        if (swiper2.isEnd) {
          notify(params.lastSlideMessage);
        } else {
          notify(params.nextSlideMessage);
        }
      }
      if (swiper2.navigation && swiper2.navigation.$prevEl && $targetEl.is(swiper2.navigation.$prevEl)) {
        if (!(swiper2.isBeginning && !swiper2.params.loop)) {
          swiper2.slidePrev();
        }
        if (swiper2.isBeginning) {
          notify(params.firstSlideMessage);
        } else {
          notify(params.prevSlideMessage);
        }
      }
      if (swiper2.pagination && $targetEl.is(classesToSelector(swiper2.params.pagination.bulletClass))) {
        $targetEl[0].click();
      }
    }
    function updateNavigation() {
      if (swiper2.params.loop || swiper2.params.rewind || !swiper2.navigation)
        return;
      const {
        $nextEl,
        $prevEl
      } = swiper2.navigation;
      if ($prevEl && $prevEl.length > 0) {
        if (swiper2.isBeginning) {
          disableEl($prevEl);
          makeElNotFocusable($prevEl);
        } else {
          enableEl($prevEl);
          makeElFocusable($prevEl);
        }
      }
      if ($nextEl && $nextEl.length > 0) {
        if (swiper2.isEnd) {
          disableEl($nextEl);
          makeElNotFocusable($nextEl);
        } else {
          enableEl($nextEl);
          makeElFocusable($nextEl);
        }
      }
    }
    function hasPagination() {
      return swiper2.pagination && swiper2.pagination.bullets && swiper2.pagination.bullets.length;
    }
    function hasClickablePagination() {
      return hasPagination() && swiper2.params.pagination.clickable;
    }
    function updatePagination() {
      const params = swiper2.params.a11y;
      if (!hasPagination())
        return;
      swiper2.pagination.bullets.each((bulletEl) => {
        const $bulletEl = dom_default(bulletEl);
        if (swiper2.params.pagination.clickable) {
          makeElFocusable($bulletEl);
          if (!swiper2.params.pagination.renderBullet) {
            addElRole($bulletEl, "button");
            addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
          }
        }
        if ($bulletEl.is(`.${swiper2.params.pagination.bulletActiveClass}`)) {
          $bulletEl.attr("aria-current", "true");
        } else {
          $bulletEl.removeAttr("aria-current");
        }
      });
    }
    const initNavEl = ($el, wrapperId, message) => {
      makeElFocusable($el);
      if ($el[0].tagName !== "BUTTON") {
        addElRole($el, "button");
        $el.on("keydown", onEnterOrSpaceKey);
      }
      addElLabel($el, message);
      addElControls($el, wrapperId);
    };
    const handlePointerDown = () => {
      swiper2.a11y.clicked = true;
    };
    const handlePointerUp = () => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          swiper2.a11y.clicked = false;
        });
      });
    };
    const handleFocus = (e2) => {
      if (swiper2.a11y.clicked)
        return;
      const slideEl = e2.target.closest(`.${swiper2.params.slideClass}`);
      if (!slideEl || !swiper2.slides.includes(slideEl))
        return;
      const isActive = swiper2.slides.indexOf(slideEl) === swiper2.activeIndex;
      const isVisible = swiper2.params.watchSlidesProgress && swiper2.visibleSlides && swiper2.visibleSlides.includes(slideEl);
      if (isActive || isVisible)
        return;
      if (swiper2.isHorizontal()) {
        swiper2.el.scrollLeft = 0;
      } else {
        swiper2.el.scrollTop = 0;
      }
      swiper2.slideTo(swiper2.slides.indexOf(slideEl), 0);
    };
    const initSlides = () => {
      const params = swiper2.params.a11y;
      if (params.itemRoleDescriptionMessage) {
        addElRoleDescription(dom_default(swiper2.slides), params.itemRoleDescriptionMessage);
      }
      if (params.slideRole) {
        addElRole(dom_default(swiper2.slides), params.slideRole);
      }
      const slidesLength = swiper2.params.loop ? swiper2.slides.filter((el) => !el.classList.contains(swiper2.params.slideDuplicateClass)).length : swiper2.slides.length;
      if (params.slideLabelMessage) {
        swiper2.slides.each((slideEl, index2) => {
          const $slideEl = dom_default(slideEl);
          const slideIndex = swiper2.params.loop ? parseInt($slideEl.attr("data-swiper-slide-index"), 10) : index2;
          const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
          addElLabel($slideEl, ariaLabelMessage);
        });
      }
    };
    const init = () => {
      const params = swiper2.params.a11y;
      swiper2.$el.append(liveRegion);
      const $containerEl = swiper2.$el;
      if (params.containerRoleDescriptionMessage) {
        addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
      }
      if (params.containerMessage) {
        addElLabel($containerEl, params.containerMessage);
      }
      const $wrapperEl = swiper2.$wrapperEl;
      const wrapperId = params.id || $wrapperEl.attr("id") || `swiper-wrapper-${getRandomNumber(16)}`;
      const live = swiper2.params.autoplay && swiper2.params.autoplay.enabled ? "off" : "polite";
      addElId($wrapperEl, wrapperId);
      addElLive($wrapperEl, live);
      initSlides();
      let $nextEl;
      let $prevEl;
      if (swiper2.navigation && swiper2.navigation.$nextEl) {
        $nextEl = swiper2.navigation.$nextEl;
      }
      if (swiper2.navigation && swiper2.navigation.$prevEl) {
        $prevEl = swiper2.navigation.$prevEl;
      }
      if ($nextEl && $nextEl.length) {
        initNavEl($nextEl, wrapperId, params.nextSlideMessage);
      }
      if ($prevEl && $prevEl.length) {
        initNavEl($prevEl, wrapperId, params.prevSlideMessage);
      }
      if (hasClickablePagination()) {
        swiper2.pagination.$el.on("keydown", classesToSelector(swiper2.params.pagination.bulletClass), onEnterOrSpaceKey);
      }
      swiper2.$el.on("focus", handleFocus, true);
      swiper2.$el.on("pointerdown", handlePointerDown, true);
      swiper2.$el.on("pointerup", handlePointerUp, true);
    };
    function destroy2() {
      if (liveRegion && liveRegion.length > 0)
        liveRegion.remove();
      let $nextEl;
      let $prevEl;
      if (swiper2.navigation && swiper2.navigation.$nextEl) {
        $nextEl = swiper2.navigation.$nextEl;
      }
      if (swiper2.navigation && swiper2.navigation.$prevEl) {
        $prevEl = swiper2.navigation.$prevEl;
      }
      if ($nextEl) {
        $nextEl.off("keydown", onEnterOrSpaceKey);
      }
      if ($prevEl) {
        $prevEl.off("keydown", onEnterOrSpaceKey);
      }
      if (hasClickablePagination()) {
        swiper2.pagination.$el.off("keydown", classesToSelector(swiper2.params.pagination.bulletClass), onEnterOrSpaceKey);
      }
      swiper2.$el.off("focus", handleFocus, true);
      swiper2.$el.off("pointerdown", handlePointerDown, true);
      swiper2.$el.off("pointerup", handlePointerUp, true);
    }
    on2("beforeInit", () => {
      liveRegion = dom_default(`<span class="${swiper2.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
    });
    on2("afterInit", () => {
      if (!swiper2.params.a11y.enabled)
        return;
      init();
    });
    on2("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
      if (!swiper2.params.a11y.enabled)
        return;
      initSlides();
    });
    on2("fromEdge toEdge afterInit lock unlock", () => {
      if (!swiper2.params.a11y.enabled)
        return;
      updateNavigation();
    });
    on2("paginationUpdate", () => {
      if (!swiper2.params.a11y.enabled)
        return;
      updatePagination();
    });
    on2("destroy", () => {
      if (!swiper2.params.a11y.enabled)
        return;
      destroy2();
    });
  }

  // node_modules/swiper/modules/history/history.js
  function History({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      history: {
        enabled: false,
        root: "",
        replaceState: false,
        key: "slides",
        keepQuery: false
      }
    });
    let initialized = false;
    let paths = {};
    const slugify = (text2) => {
      return text2.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
    };
    const getPathValues = (urlOverride) => {
      const window2 = getWindow();
      let location2;
      if (urlOverride) {
        location2 = new URL(urlOverride);
      } else {
        location2 = window2.location;
      }
      const pathArray = location2.pathname.slice(1).split("/").filter((part) => part !== "");
      const total = pathArray.length;
      const key = pathArray[total - 2];
      const value2 = pathArray[total - 1];
      return {
        key,
        value: value2
      };
    };
    const setHistory = (key, index2) => {
      const window2 = getWindow();
      if (!initialized || !swiper2.params.history.enabled)
        return;
      let location2;
      if (swiper2.params.url) {
        location2 = new URL(swiper2.params.url);
      } else {
        location2 = window2.location;
      }
      const slide = swiper2.slides.eq(index2);
      let value2 = slugify(slide.attr("data-history"));
      if (swiper2.params.history.root.length > 0) {
        let root = swiper2.params.history.root;
        if (root[root.length - 1] === "/")
          root = root.slice(0, root.length - 1);
        value2 = `${root}/${key}/${value2}`;
      } else if (!location2.pathname.includes(key)) {
        value2 = `${key}/${value2}`;
      }
      if (swiper2.params.history.keepQuery) {
        value2 += location2.search;
      }
      const currentState = window2.history.state;
      if (currentState && currentState.value === value2) {
        return;
      }
      if (swiper2.params.history.replaceState) {
        window2.history.replaceState({
          value: value2
        }, null, value2);
      } else {
        window2.history.pushState({
          value: value2
        }, null, value2);
      }
    };
    const scrollToSlide = (speed, value2, runCallbacks) => {
      if (value2) {
        for (let i = 0, length = swiper2.slides.length; i < length; i += 1) {
          const slide = swiper2.slides.eq(i);
          const slideHistory = slugify(slide.attr("data-history"));
          if (slideHistory === value2 && !slide.hasClass(swiper2.params.slideDuplicateClass)) {
            const index2 = slide.index();
            swiper2.slideTo(index2, speed, runCallbacks);
          }
        }
      } else {
        swiper2.slideTo(0, speed, runCallbacks);
      }
    };
    const setHistoryPopState = () => {
      paths = getPathValues(swiper2.params.url);
      scrollToSlide(swiper2.params.speed, paths.value, false);
    };
    const init = () => {
      const window2 = getWindow();
      if (!swiper2.params.history)
        return;
      if (!window2.history || !window2.history.pushState) {
        swiper2.params.history.enabled = false;
        swiper2.params.hashNavigation.enabled = true;
        return;
      }
      initialized = true;
      paths = getPathValues(swiper2.params.url);
      if (!paths.key && !paths.value)
        return;
      scrollToSlide(0, paths.value, swiper2.params.runCallbacksOnInit);
      if (!swiper2.params.history.replaceState) {
        window2.addEventListener("popstate", setHistoryPopState);
      }
    };
    const destroy2 = () => {
      const window2 = getWindow();
      if (!swiper2.params.history.replaceState) {
        window2.removeEventListener("popstate", setHistoryPopState);
      }
    };
    on2("init", () => {
      if (swiper2.params.history.enabled) {
        init();
      }
    });
    on2("destroy", () => {
      if (swiper2.params.history.enabled) {
        destroy2();
      }
    });
    on2("transitionEnd _freeModeNoMomentumRelease", () => {
      if (initialized) {
        setHistory(swiper2.params.history.key, swiper2.activeIndex);
      }
    });
    on2("slideChange", () => {
      if (initialized && swiper2.params.cssMode) {
        setHistory(swiper2.params.history.key, swiper2.activeIndex);
      }
    });
  }

  // node_modules/swiper/modules/hash-navigation/hash-navigation.js
  function HashNavigation({
    swiper: swiper2,
    extendParams,
    emit,
    on: on2
  }) {
    let initialized = false;
    const document2 = getDocument();
    const window2 = getWindow();
    extendParams({
      hashNavigation: {
        enabled: false,
        replaceState: false,
        watchState: false
      }
    });
    const onHashChange = () => {
      emit("hashChange");
      const newHash = document2.location.hash.replace("#", "");
      const activeSlideHash = swiper2.slides.eq(swiper2.activeIndex).attr("data-hash");
      if (newHash !== activeSlideHash) {
        const newIndex = swiper2.$wrapperEl.children(`.${swiper2.params.slideClass}[data-hash="${newHash}"]`).index();
        if (typeof newIndex === "undefined")
          return;
        swiper2.slideTo(newIndex);
      }
    };
    const setHash = () => {
      if (!initialized || !swiper2.params.hashNavigation.enabled)
        return;
      if (swiper2.params.hashNavigation.replaceState && window2.history && window2.history.replaceState) {
        window2.history.replaceState(null, null, `#${swiper2.slides.eq(swiper2.activeIndex).attr("data-hash")}` || "");
        emit("hashSet");
      } else {
        const slide = swiper2.slides.eq(swiper2.activeIndex);
        const hash = slide.attr("data-hash") || slide.attr("data-history");
        document2.location.hash = hash || "";
        emit("hashSet");
      }
    };
    const init = () => {
      if (!swiper2.params.hashNavigation.enabled || swiper2.params.history && swiper2.params.history.enabled)
        return;
      initialized = true;
      const hash = document2.location.hash.replace("#", "");
      if (hash) {
        const speed = 0;
        for (let i = 0, length = swiper2.slides.length; i < length; i += 1) {
          const slide = swiper2.slides.eq(i);
          const slideHash = slide.attr("data-hash") || slide.attr("data-history");
          if (slideHash === hash && !slide.hasClass(swiper2.params.slideDuplicateClass)) {
            const index2 = slide.index();
            swiper2.slideTo(index2, speed, swiper2.params.runCallbacksOnInit, true);
          }
        }
      }
      if (swiper2.params.hashNavigation.watchState) {
        dom_default(window2).on("hashchange", onHashChange);
      }
    };
    const destroy2 = () => {
      if (swiper2.params.hashNavigation.watchState) {
        dom_default(window2).off("hashchange", onHashChange);
      }
    };
    on2("init", () => {
      if (swiper2.params.hashNavigation.enabled) {
        init();
      }
    });
    on2("destroy", () => {
      if (swiper2.params.hashNavigation.enabled) {
        destroy2();
      }
    });
    on2("transitionEnd _freeModeNoMomentumRelease", () => {
      if (initialized) {
        setHash();
      }
    });
    on2("slideChange", () => {
      if (initialized && swiper2.params.cssMode) {
        setHash();
      }
    });
  }

  // node_modules/swiper/modules/autoplay/autoplay.js
  function Autoplay({
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  }) {
    let timeout;
    swiper2.autoplay = {
      running: false,
      paused: false
    };
    extendParams({
      autoplay: {
        enabled: false,
        delay: 3e3,
        waitForTransition: true,
        disableOnInteraction: true,
        stopOnLastSlide: false,
        reverseDirection: false,
        pauseOnMouseEnter: false
      }
    });
    function run() {
      if (!swiper2.size) {
        swiper2.autoplay.running = false;
        swiper2.autoplay.paused = false;
        return;
      }
      const $activeSlideEl = swiper2.slides.eq(swiper2.activeIndex);
      let delay = swiper2.params.autoplay.delay;
      if ($activeSlideEl.attr("data-swiper-autoplay")) {
        delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper2.params.autoplay.delay;
      }
      clearTimeout(timeout);
      timeout = nextTick(() => {
        let autoplayResult;
        if (swiper2.params.autoplay.reverseDirection) {
          if (swiper2.params.loop) {
            swiper2.loopFix();
            autoplayResult = swiper2.slidePrev(swiper2.params.speed, true, true);
            emit("autoplay");
          } else if (!swiper2.isBeginning) {
            autoplayResult = swiper2.slidePrev(swiper2.params.speed, true, true);
            emit("autoplay");
          } else if (!swiper2.params.autoplay.stopOnLastSlide) {
            autoplayResult = swiper2.slideTo(swiper2.slides.length - 1, swiper2.params.speed, true, true);
            emit("autoplay");
          } else {
            stop();
          }
        } else if (swiper2.params.loop) {
          swiper2.loopFix();
          autoplayResult = swiper2.slideNext(swiper2.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper2.isEnd) {
          autoplayResult = swiper2.slideNext(swiper2.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper2.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper2.slideTo(0, swiper2.params.speed, true, true);
          emit("autoplay");
        } else {
          stop();
        }
        if (swiper2.params.cssMode && swiper2.autoplay.running)
          run();
        else if (autoplayResult === false) {
          run();
        }
      }, delay);
    }
    function start() {
      if (typeof timeout !== "undefined")
        return false;
      if (swiper2.autoplay.running)
        return false;
      swiper2.autoplay.running = true;
      emit("autoplayStart");
      run();
      return true;
    }
    function stop() {
      if (!swiper2.autoplay.running)
        return false;
      if (typeof timeout === "undefined")
        return false;
      if (timeout) {
        clearTimeout(timeout);
        timeout = void 0;
      }
      swiper2.autoplay.running = false;
      emit("autoplayStop");
      return true;
    }
    function pause(speed) {
      if (!swiper2.autoplay.running)
        return;
      if (swiper2.autoplay.paused)
        return;
      if (timeout)
        clearTimeout(timeout);
      swiper2.autoplay.paused = true;
      if (speed === 0 || !swiper2.params.autoplay.waitForTransition) {
        swiper2.autoplay.paused = false;
        run();
      } else {
        ["transitionend", "webkitTransitionEnd"].forEach((event2) => {
          swiper2.$wrapperEl[0].addEventListener(event2, onTransitionEnd);
        });
      }
    }
    function onVisibilityChange() {
      const document2 = getDocument();
      if (document2.visibilityState === "hidden" && swiper2.autoplay.running) {
        pause();
      }
      if (document2.visibilityState === "visible" && swiper2.autoplay.paused) {
        run();
        swiper2.autoplay.paused = false;
      }
    }
    function onTransitionEnd(e2) {
      if (!swiper2 || swiper2.destroyed || !swiper2.$wrapperEl)
        return;
      if (e2.target !== swiper2.$wrapperEl[0])
        return;
      ["transitionend", "webkitTransitionEnd"].forEach((event2) => {
        swiper2.$wrapperEl[0].removeEventListener(event2, onTransitionEnd);
      });
      swiper2.autoplay.paused = false;
      if (!swiper2.autoplay.running) {
        stop();
      } else {
        run();
      }
    }
    function onMouseEnter() {
      if (swiper2.params.autoplay.disableOnInteraction) {
        stop();
      } else {
        emit("autoplayPause");
        pause();
      }
      ["transitionend", "webkitTransitionEnd"].forEach((event2) => {
        swiper2.$wrapperEl[0].removeEventListener(event2, onTransitionEnd);
      });
    }
    function onMouseLeave() {
      if (swiper2.params.autoplay.disableOnInteraction) {
        return;
      }
      swiper2.autoplay.paused = false;
      emit("autoplayResume");
      run();
    }
    function attachMouseEvents() {
      if (swiper2.params.autoplay.pauseOnMouseEnter) {
        swiper2.$el.on("mouseenter", onMouseEnter);
        swiper2.$el.on("mouseleave", onMouseLeave);
      }
    }
    function detachMouseEvents() {
      swiper2.$el.off("mouseenter", onMouseEnter);
      swiper2.$el.off("mouseleave", onMouseLeave);
    }
    on2("init", () => {
      if (swiper2.params.autoplay.enabled) {
        start();
        const document2 = getDocument();
        document2.addEventListener("visibilitychange", onVisibilityChange);
        attachMouseEvents();
      }
    });
    on2("beforeTransitionStart", (_s, speed, internal) => {
      if (swiper2.autoplay.running) {
        if (internal || !swiper2.params.autoplay.disableOnInteraction) {
          swiper2.autoplay.pause(speed);
        } else {
          stop();
        }
      }
    });
    on2("sliderFirstMove", () => {
      if (swiper2.autoplay.running) {
        if (swiper2.params.autoplay.disableOnInteraction) {
          stop();
        } else {
          pause();
        }
      }
    });
    on2("touchEnd", () => {
      if (swiper2.params.cssMode && swiper2.autoplay.paused && !swiper2.params.autoplay.disableOnInteraction) {
        run();
      }
    });
    on2("destroy", () => {
      detachMouseEvents();
      if (swiper2.autoplay.running) {
        stop();
      }
      const document2 = getDocument();
      document2.removeEventListener("visibilitychange", onVisibilityChange);
    });
    Object.assign(swiper2.autoplay, {
      pause,
      run,
      start,
      stop
    });
  }

  // node_modules/swiper/modules/thumbs/thumbs.js
  function Thumb({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      thumbs: {
        swiper: null,
        multipleActiveThumbs: true,
        autoScrollOffset: 0,
        slideThumbActiveClass: "swiper-slide-thumb-active",
        thumbsContainerClass: "swiper-thumbs"
      }
    });
    let initialized = false;
    let swiperCreated = false;
    swiper2.thumbs = {
      swiper: null
    };
    function onThumbClick() {
      const thumbsSwiper = swiper2.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed)
        return;
      const clickedIndex = thumbsSwiper.clickedIndex;
      const clickedSlide = thumbsSwiper.clickedSlide;
      if (clickedSlide && dom_default(clickedSlide).hasClass(swiper2.params.thumbs.slideThumbActiveClass))
        return;
      if (typeof clickedIndex === "undefined" || clickedIndex === null)
        return;
      let slideToIndex;
      if (thumbsSwiper.params.loop) {
        slideToIndex = parseInt(dom_default(thumbsSwiper.clickedSlide).attr("data-swiper-slide-index"), 10);
      } else {
        slideToIndex = clickedIndex;
      }
      if (swiper2.params.loop) {
        let currentIndex = swiper2.activeIndex;
        if (swiper2.slides.eq(currentIndex).hasClass(swiper2.params.slideDuplicateClass)) {
          swiper2.loopFix();
          swiper2._clientLeft = swiper2.$wrapperEl[0].clientLeft;
          currentIndex = swiper2.activeIndex;
        }
        const prevIndex = swiper2.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
        const nextIndex = swiper2.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
        if (typeof prevIndex === "undefined")
          slideToIndex = nextIndex;
        else if (typeof nextIndex === "undefined")
          slideToIndex = prevIndex;
        else if (nextIndex - currentIndex < currentIndex - prevIndex)
          slideToIndex = nextIndex;
        else
          slideToIndex = prevIndex;
      }
      swiper2.slideTo(slideToIndex);
    }
    function init() {
      const {
        thumbs: thumbsParams
      } = swiper2.params;
      if (initialized)
        return false;
      initialized = true;
      const SwiperClass = swiper2.constructor;
      if (thumbsParams.swiper instanceof SwiperClass) {
        swiper2.thumbs.swiper = thumbsParams.swiper;
        Object.assign(swiper2.thumbs.swiper.originalParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        Object.assign(swiper2.thumbs.swiper.params, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
      } else if (isObject2(thumbsParams.swiper)) {
        const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
        Object.assign(thumbsSwiperParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        swiper2.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
        swiperCreated = true;
      }
      swiper2.thumbs.swiper.$el.addClass(swiper2.params.thumbs.thumbsContainerClass);
      swiper2.thumbs.swiper.on("tap", onThumbClick);
      return true;
    }
    function update2(initial) {
      const thumbsSwiper = swiper2.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed)
        return;
      const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
      let thumbsToActivate = 1;
      const thumbActiveClass = swiper2.params.thumbs.slideThumbActiveClass;
      if (swiper2.params.slidesPerView > 1 && !swiper2.params.centeredSlides) {
        thumbsToActivate = swiper2.params.slidesPerView;
      }
      if (!swiper2.params.thumbs.multipleActiveThumbs) {
        thumbsToActivate = 1;
      }
      thumbsToActivate = Math.floor(thumbsToActivate);
      thumbsSwiper.slides.removeClass(thumbActiveClass);
      if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper2.realIndex + i}"]`).addClass(thumbActiveClass);
        }
      } else {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.slides.eq(swiper2.realIndex + i).addClass(thumbActiveClass);
        }
      }
      const autoScrollOffset = swiper2.params.thumbs.autoScrollOffset;
      const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
      if (swiper2.realIndex !== thumbsSwiper.realIndex || useOffset) {
        let currentThumbsIndex = thumbsSwiper.activeIndex;
        let newThumbsIndex;
        let direction;
        if (thumbsSwiper.params.loop) {
          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
            thumbsSwiper.loopFix();
            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
            currentThumbsIndex = thumbsSwiper.activeIndex;
          }
          const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper2.realIndex}"]`).eq(0).index();
          const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper2.realIndex}"]`).eq(0).index();
          if (typeof prevThumbsIndex === "undefined") {
            newThumbsIndex = nextThumbsIndex;
          } else if (typeof nextThumbsIndex === "undefined") {
            newThumbsIndex = prevThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = nextThumbsIndex;
          } else {
            newThumbsIndex = prevThumbsIndex;
          }
          direction = swiper2.activeIndex > swiper2.previousIndex ? "next" : "prev";
        } else {
          newThumbsIndex = swiper2.realIndex;
          direction = newThumbsIndex > swiper2.previousIndex ? "next" : "prev";
        }
        if (useOffset) {
          newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
        }
        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
          if (thumbsSwiper.params.centeredSlides) {
            if (newThumbsIndex > currentThumbsIndex) {
              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
            } else {
              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
            }
          } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {
          }
          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
        }
      }
    }
    on2("beforeInit", () => {
      const {
        thumbs
      } = swiper2.params;
      if (!thumbs || !thumbs.swiper)
        return;
      init();
      update2(true);
    });
    on2("slideChange update resize observerUpdate", () => {
      update2();
    });
    on2("setTransition", (_s, duration) => {
      const thumbsSwiper = swiper2.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed)
        return;
      thumbsSwiper.setTransition(duration);
    });
    on2("beforeDestroy", () => {
      const thumbsSwiper = swiper2.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed)
        return;
      if (swiperCreated) {
        thumbsSwiper.destroy();
      }
    });
    Object.assign(swiper2.thumbs, {
      init,
      update: update2
    });
  }

  // node_modules/swiper/modules/free-mode/free-mode.js
  function freeMode({
    swiper: swiper2,
    extendParams,
    emit,
    once: once2
  }) {
    extendParams({
      freeMode: {
        enabled: false,
        momentum: true,
        momentumRatio: 1,
        momentumBounce: true,
        momentumBounceRatio: 1,
        momentumVelocityRatio: 1,
        sticky: false,
        minimumVelocity: 0.02
      }
    });
    function onTouchStart2() {
      const translate = swiper2.getTranslate();
      swiper2.setTranslate(translate);
      swiper2.setTransition(0);
      swiper2.touchEventsData.velocities.length = 0;
      swiper2.freeMode.onTouchEnd({
        currentPos: swiper2.rtl ? swiper2.translate : -swiper2.translate
      });
    }
    function onTouchMove2() {
      const {
        touchEventsData: data,
        touches
      } = swiper2;
      if (data.velocities.length === 0) {
        data.velocities.push({
          position: touches[swiper2.isHorizontal() ? "startX" : "startY"],
          time: data.touchStartTime
        });
      }
      data.velocities.push({
        position: touches[swiper2.isHorizontal() ? "currentX" : "currentY"],
        time: now()
      });
    }
    function onTouchEnd2({
      currentPos
    }) {
      const {
        params,
        $wrapperEl,
        rtlTranslate: rtl,
        snapGrid,
        touchEventsData: data
      } = swiper2;
      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime;
      if (currentPos < -swiper2.minTranslate()) {
        swiper2.slideTo(swiper2.activeIndex);
        return;
      }
      if (currentPos > -swiper2.maxTranslate()) {
        if (swiper2.slides.length < snapGrid.length) {
          swiper2.slideTo(snapGrid.length - 1);
        } else {
          swiper2.slideTo(swiper2.slides.length - 1);
        }
        return;
      }
      if (params.freeMode.momentum) {
        if (data.velocities.length > 1) {
          const lastMoveEvent = data.velocities.pop();
          const velocityEvent = data.velocities.pop();
          const distance = lastMoveEvent.position - velocityEvent.position;
          const time = lastMoveEvent.time - velocityEvent.time;
          swiper2.velocity = distance / time;
          swiper2.velocity /= 2;
          if (Math.abs(swiper2.velocity) < params.freeMode.minimumVelocity) {
            swiper2.velocity = 0;
          }
          if (time > 150 || now() - lastMoveEvent.time > 300) {
            swiper2.velocity = 0;
          }
        } else {
          swiper2.velocity = 0;
        }
        swiper2.velocity *= params.freeMode.momentumVelocityRatio;
        data.velocities.length = 0;
        let momentumDuration = 1e3 * params.freeMode.momentumRatio;
        const momentumDistance = swiper2.velocity * momentumDuration;
        let newPosition = swiper2.translate + momentumDistance;
        if (rtl)
          newPosition = -newPosition;
        let doBounce = false;
        let afterBouncePosition;
        const bounceAmount = Math.abs(swiper2.velocity) * 20 * params.freeMode.momentumBounceRatio;
        let needsLoopFix;
        if (newPosition < swiper2.maxTranslate()) {
          if (params.freeMode.momentumBounce) {
            if (newPosition + swiper2.maxTranslate() < -bounceAmount) {
              newPosition = swiper2.maxTranslate() - bounceAmount;
            }
            afterBouncePosition = swiper2.maxTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper2.maxTranslate();
          }
          if (params.loop && params.centeredSlides)
            needsLoopFix = true;
        } else if (newPosition > swiper2.minTranslate()) {
          if (params.freeMode.momentumBounce) {
            if (newPosition - swiper2.minTranslate() > bounceAmount) {
              newPosition = swiper2.minTranslate() + bounceAmount;
            }
            afterBouncePosition = swiper2.minTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper2.minTranslate();
          }
          if (params.loop && params.centeredSlides)
            needsLoopFix = true;
        } else if (params.freeMode.sticky) {
          let nextSlide;
          for (let j = 0; j < snapGrid.length; j += 1) {
            if (snapGrid[j] > -newPosition) {
              nextSlide = j;
              break;
            }
          }
          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper2.swipeDirection === "next") {
            newPosition = snapGrid[nextSlide];
          } else {
            newPosition = snapGrid[nextSlide - 1];
          }
          newPosition = -newPosition;
        }
        if (needsLoopFix) {
          once2("transitionEnd", () => {
            swiper2.loopFix();
          });
        }
        if (swiper2.velocity !== 0) {
          if (rtl) {
            momentumDuration = Math.abs((-newPosition - swiper2.translate) / swiper2.velocity);
          } else {
            momentumDuration = Math.abs((newPosition - swiper2.translate) / swiper2.velocity);
          }
          if (params.freeMode.sticky) {
            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper2.translate);
            const currentSlideSize = swiper2.slidesSizesGrid[swiper2.activeIndex];
            if (moveDistance < currentSlideSize) {
              momentumDuration = params.speed;
            } else if (moveDistance < 2 * currentSlideSize) {
              momentumDuration = params.speed * 1.5;
            } else {
              momentumDuration = params.speed * 2.5;
            }
          }
        } else if (params.freeMode.sticky) {
          swiper2.slideToClosest();
          return;
        }
        if (params.freeMode.momentumBounce && doBounce) {
          swiper2.updateProgress(afterBouncePosition);
          swiper2.setTransition(momentumDuration);
          swiper2.setTranslate(newPosition);
          swiper2.transitionStart(true, swiper2.swipeDirection);
          swiper2.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper2 || swiper2.destroyed || !data.allowMomentumBounce)
              return;
            emit("momentumBounce");
            swiper2.setTransition(params.speed);
            setTimeout(() => {
              swiper2.setTranslate(afterBouncePosition);
              $wrapperEl.transitionEnd(() => {
                if (!swiper2 || swiper2.destroyed)
                  return;
                swiper2.transitionEnd();
              });
            }, 0);
          });
        } else if (swiper2.velocity) {
          emit("_freeModeNoMomentumRelease");
          swiper2.updateProgress(newPosition);
          swiper2.setTransition(momentumDuration);
          swiper2.setTranslate(newPosition);
          swiper2.transitionStart(true, swiper2.swipeDirection);
          if (!swiper2.animating) {
            swiper2.animating = true;
            $wrapperEl.transitionEnd(() => {
              if (!swiper2 || swiper2.destroyed)
                return;
              swiper2.transitionEnd();
            });
          }
        } else {
          swiper2.updateProgress(newPosition);
        }
        swiper2.updateActiveIndex();
        swiper2.updateSlidesClasses();
      } else if (params.freeMode.sticky) {
        swiper2.slideToClosest();
        return;
      } else if (params.freeMode) {
        emit("_freeModeNoMomentumRelease");
      }
      if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
        swiper2.updateProgress();
        swiper2.updateActiveIndex();
        swiper2.updateSlidesClasses();
      }
    }
    Object.assign(swiper2, {
      freeMode: {
        onTouchStart: onTouchStart2,
        onTouchMove: onTouchMove2,
        onTouchEnd: onTouchEnd2
      }
    });
  }

  // node_modules/swiper/modules/grid/grid.js
  function Grid({
    swiper: swiper2,
    extendParams
  }) {
    extendParams({
      grid: {
        rows: 1,
        fill: "column"
      }
    });
    let slidesNumberEvenToRows;
    let slidesPerRow;
    let numFullColumns;
    const initSlides = (slidesLength) => {
      const {
        slidesPerView
      } = swiper2.params;
      const {
        rows,
        fill
      } = swiper2.params.grid;
      slidesPerRow = slidesNumberEvenToRows / rows;
      numFullColumns = Math.floor(slidesLength / rows);
      if (Math.floor(slidesLength / rows) === slidesLength / rows) {
        slidesNumberEvenToRows = slidesLength;
      } else {
        slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
      }
      if (slidesPerView !== "auto" && fill === "row") {
        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
      }
    };
    const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
      const {
        slidesPerGroup,
        spaceBetween
      } = swiper2.params;
      const {
        rows,
        fill
      } = swiper2.params.grid;
      let newSlideOrderIndex;
      let column;
      let row;
      if (fill === "row" && slidesPerGroup > 1) {
        const groupIndex = Math.floor(i / (slidesPerGroup * rows));
        const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
        const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
        newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
        slide.css({
          "-webkit-order": newSlideOrderIndex,
          order: newSlideOrderIndex
        });
      } else if (fill === "column") {
        column = Math.floor(i / rows);
        row = i - column * rows;
        if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
          row += 1;
          if (row >= rows) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - row * slidesPerRow;
      }
      slide.css(getDirectionLabel("margin-top"), row !== 0 ? spaceBetween && `${spaceBetween}px` : "");
    };
    const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
      const {
        spaceBetween,
        centeredSlides,
        roundLengths
      } = swiper2.params;
      const {
        rows
      } = swiper2.params.grid;
      swiper2.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
      swiper2.virtualSize = Math.ceil(swiper2.virtualSize / rows) - spaceBetween;
      swiper2.$wrapperEl.css({
        [getDirectionLabel("width")]: `${swiper2.virtualSize + spaceBetween}px`
      });
      if (centeredSlides) {
        snapGrid.splice(0, snapGrid.length);
        const newSlidesGrid = [];
        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (roundLengths)
            slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[i] < swiper2.virtualSize + snapGrid[0])
            newSlidesGrid.push(slidesGridItem);
        }
        snapGrid.push(...newSlidesGrid);
      }
    };
    swiper2.grid = {
      initSlides,
      updateSlide,
      updateWrapperSize
    };
  }

  // node_modules/swiper/modules/manipulation/methods/appendSlide.js
  function appendSlide(slides) {
    const swiper2 = this;
    const {
      $wrapperEl,
      params
    } = swiper2;
    if (params.loop) {
      swiper2.loopDestroy();
    }
    if (typeof slides === "object" && "length" in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          $wrapperEl.append(slides[i]);
      }
    } else {
      $wrapperEl.append(slides);
    }
    if (params.loop) {
      swiper2.loopCreate();
    }
    if (!params.observer) {
      swiper2.update();
    }
  }

  // node_modules/swiper/modules/manipulation/methods/prependSlide.js
  function prependSlide(slides) {
    const swiper2 = this;
    const {
      params,
      $wrapperEl,
      activeIndex
    } = swiper2;
    if (params.loop) {
      swiper2.loopDestroy();
    }
    let newActiveIndex = activeIndex + 1;
    if (typeof slides === "object" && "length" in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          $wrapperEl.prepend(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
    } else {
      $wrapperEl.prepend(slides);
    }
    if (params.loop) {
      swiper2.loopCreate();
    }
    if (!params.observer) {
      swiper2.update();
    }
    swiper2.slideTo(newActiveIndex, 0, false);
  }

  // node_modules/swiper/modules/manipulation/methods/addSlide.js
  function addSlide(index2, slides) {
    const swiper2 = this;
    const {
      $wrapperEl,
      params,
      activeIndex
    } = swiper2;
    let activeIndexBuffer = activeIndex;
    if (params.loop) {
      activeIndexBuffer -= swiper2.loopedSlides;
      swiper2.loopDestroy();
      swiper2.slides = $wrapperEl.children(`.${params.slideClass}`);
    }
    const baseLength = swiper2.slides.length;
    if (index2 <= 0) {
      swiper2.prependSlide(slides);
      return;
    }
    if (index2 >= baseLength) {
      swiper2.appendSlide(slides);
      return;
    }
    let newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + 1 : activeIndexBuffer;
    const slidesBuffer = [];
    for (let i = baseLength - 1; i >= index2; i -= 1) {
      const currentSlide = swiper2.slides.eq(i);
      currentSlide.remove();
      slidesBuffer.unshift(currentSlide);
    }
    if (typeof slides === "object" && "length" in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          $wrapperEl.append(slides[i]);
      }
      newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
      $wrapperEl.append(slides);
    }
    for (let i = 0; i < slidesBuffer.length; i += 1) {
      $wrapperEl.append(slidesBuffer[i]);
    }
    if (params.loop) {
      swiper2.loopCreate();
    }
    if (!params.observer) {
      swiper2.update();
    }
    if (params.loop) {
      swiper2.slideTo(newActiveIndex + swiper2.loopedSlides, 0, false);
    } else {
      swiper2.slideTo(newActiveIndex, 0, false);
    }
  }

  // node_modules/swiper/modules/manipulation/methods/removeSlide.js
  function removeSlide(slidesIndexes) {
    const swiper2 = this;
    const {
      params,
      $wrapperEl,
      activeIndex
    } = swiper2;
    let activeIndexBuffer = activeIndex;
    if (params.loop) {
      activeIndexBuffer -= swiper2.loopedSlides;
      swiper2.loopDestroy();
      swiper2.slides = $wrapperEl.children(`.${params.slideClass}`);
    }
    let newActiveIndex = activeIndexBuffer;
    let indexToRemove;
    if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
      for (let i = 0; i < slidesIndexes.length; i += 1) {
        indexToRemove = slidesIndexes[i];
        if (swiper2.slides[indexToRemove])
          swiper2.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex)
          newActiveIndex -= 1;
      }
      newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
      indexToRemove = slidesIndexes;
      if (swiper2.slides[indexToRemove])
        swiper2.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex)
        newActiveIndex -= 1;
      newActiveIndex = Math.max(newActiveIndex, 0);
    }
    if (params.loop) {
      swiper2.loopCreate();
    }
    if (!params.observer) {
      swiper2.update();
    }
    if (params.loop) {
      swiper2.slideTo(newActiveIndex + swiper2.loopedSlides, 0, false);
    } else {
      swiper2.slideTo(newActiveIndex, 0, false);
    }
  }

  // node_modules/swiper/modules/manipulation/methods/removeAllSlides.js
  function removeAllSlides() {
    const swiper2 = this;
    const slidesIndexes = [];
    for (let i = 0; i < swiper2.slides.length; i += 1) {
      slidesIndexes.push(i);
    }
    swiper2.removeSlide(slidesIndexes);
  }

  // node_modules/swiper/modules/manipulation/manipulation.js
  function Manipulation({
    swiper: swiper2
  }) {
    Object.assign(swiper2, {
      appendSlide: appendSlide.bind(swiper2),
      prependSlide: prependSlide.bind(swiper2),
      addSlide: addSlide.bind(swiper2),
      removeSlide: removeSlide.bind(swiper2),
      removeAllSlides: removeAllSlides.bind(swiper2)
    });
  }

  // node_modules/swiper/shared/effect-init.js
  function effectInit(params) {
    const {
      effect,
      swiper: swiper2,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      overwriteParams,
      perspective,
      recreateShadows,
      getEffectParams
    } = params;
    on2("beforeInit", () => {
      if (swiper2.params.effect !== effect)
        return;
      swiper2.classNames.push(`${swiper2.params.containerModifierClass}${effect}`);
      if (perspective && perspective()) {
        swiper2.classNames.push(`${swiper2.params.containerModifierClass}3d`);
      }
      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
      Object.assign(swiper2.params, overwriteParamsResult);
      Object.assign(swiper2.originalParams, overwriteParamsResult);
    });
    on2("setTranslate", () => {
      if (swiper2.params.effect !== effect)
        return;
      setTranslate2();
    });
    on2("setTransition", (_s, duration) => {
      if (swiper2.params.effect !== effect)
        return;
      setTransition2(duration);
    });
    on2("transitionEnd", () => {
      if (swiper2.params.effect !== effect)
        return;
      if (recreateShadows) {
        if (!getEffectParams || !getEffectParams().slideShadows)
          return;
        swiper2.slides.each((slideEl) => {
          const $slideEl = swiper2.$(slideEl);
          $slideEl.find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove();
        });
        recreateShadows();
      }
    });
    let requireUpdateOnVirtual;
    on2("virtualUpdate", () => {
      if (swiper2.params.effect !== effect)
        return;
      if (!swiper2.slides.length) {
        requireUpdateOnVirtual = true;
      }
      requestAnimationFrame(() => {
        if (requireUpdateOnVirtual && swiper2.slides && swiper2.slides.length) {
          setTranslate2();
          requireUpdateOnVirtual = false;
        }
      });
    });
  }

  // node_modules/swiper/shared/effect-target.js
  function effectTarget(effectParams, $slideEl) {
    if (effectParams.transformEl) {
      return $slideEl.find(effectParams.transformEl).css({
        "backface-visibility": "hidden",
        "-webkit-backface-visibility": "hidden"
      });
    }
    return $slideEl;
  }

  // node_modules/swiper/shared/effect-virtual-transition-end.js
  function effectVirtualTransitionEnd({
    swiper: swiper2,
    duration,
    transformEl,
    allSlides
  }) {
    const {
      slides,
      activeIndex,
      $wrapperEl
    } = swiper2;
    if (swiper2.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      let $transitionEndTarget;
      if (allSlides) {
        $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
      } else {
        $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
      }
      $transitionEndTarget.transitionEnd(() => {
        if (eventTriggered)
          return;
        if (!swiper2 || swiper2.destroyed)
          return;
        eventTriggered = true;
        swiper2.animating = false;
        const triggerEvents = ["webkitTransitionEnd", "transitionend"];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }

  // node_modules/swiper/modules/effect-fade/effect-fade.js
  function EffectFade({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      fadeEffect: {
        crossFade: false,
        transformEl: null
      }
    });
    const setTranslate2 = () => {
      const {
        slides
      } = swiper2;
      const params = swiper2.params.fadeEffect;
      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = swiper2.slides.eq(i);
        const offset2 = $slideEl[0].swiperSlideOffset;
        let tx = -offset2;
        if (!swiper2.params.virtualTranslate)
          tx -= swiper2.translate;
        let ty = 0;
        if (!swiper2.isHorizontal()) {
          ty = tx;
          tx = 0;
        }
        const slideOpacity = swiper2.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.css({
          opacity: slideOpacity
        }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
      }
    };
    const setTransition2 = (duration) => {
      const {
        transformEl
      } = swiper2.params.fadeEffect;
      const $transitionElements = transformEl ? swiper2.slides.find(transformEl) : swiper2.slides;
      $transitionElements.transition(duration);
      effectVirtualTransitionEnd({
        swiper: swiper2,
        duration,
        transformEl,
        allSlides: true
      });
    };
    effectInit({
      effect: "fade",
      swiper: swiper2,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: !swiper2.params.cssMode
      })
    });
  }

  // node_modules/swiper/modules/effect-cube/effect-cube.js
  function EffectCube({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      cubeEffect: {
        slideShadows: true,
        shadow: true,
        shadowOffset: 20,
        shadowScale: 0.94
      }
    });
    const createSlideShadows = ($slideEl, progress, isHorizontal) => {
      let shadowBefore = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
      let shadowAfter = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
      if (shadowBefore.length === 0) {
        shadowBefore = dom_default(`<div class="swiper-slide-shadow-${isHorizontal ? "left" : "top"}"></div>`);
        $slideEl.append(shadowBefore);
      }
      if (shadowAfter.length === 0) {
        shadowAfter = dom_default(`<div class="swiper-slide-shadow-${isHorizontal ? "right" : "bottom"}"></div>`);
        $slideEl.append(shadowAfter);
      }
      if (shadowBefore.length)
        shadowBefore[0].style.opacity = Math.max(-progress, 0);
      if (shadowAfter.length)
        shadowAfter[0].style.opacity = Math.max(progress, 0);
    };
    const recreateShadows = () => {
      const isHorizontal = swiper2.isHorizontal();
      swiper2.slides.each((slideEl) => {
        const progress = Math.max(Math.min(slideEl.progress, 1), -1);
        createSlideShadows(dom_default(slideEl), progress, isHorizontal);
      });
    };
    const setTranslate2 = () => {
      const {
        $el,
        $wrapperEl,
        slides,
        width: swiperWidth,
        height: swiperHeight,
        rtlTranslate: rtl,
        size: swiperSize,
        browser: browser2
      } = swiper2;
      const params = swiper2.params.cubeEffect;
      const isHorizontal = swiper2.isHorizontal();
      const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
      let wrapperRotate = 0;
      let $cubeShadowEl;
      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl = $wrapperEl.find(".swiper-cube-shadow");
          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = dom_default('<div class="swiper-cube-shadow"></div>');
            $wrapperEl.append($cubeShadowEl);
          }
          $cubeShadowEl.css({
            height: `${swiperWidth}px`
          });
        } else {
          $cubeShadowEl = $el.find(".swiper-cube-shadow");
          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = dom_default('<div class="swiper-cube-shadow"></div>');
            $el.append($cubeShadowEl);
          }
        }
      }
      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        let slideIndex = i;
        if (isVirtual) {
          slideIndex = parseInt($slideEl.attr("data-swiper-slide-index"), 10);
        }
        let slideAngle = slideIndex * 90;
        let round = Math.floor(slideAngle / 360);
        if (rtl) {
          slideAngle = -slideAngle;
          round = Math.floor(-slideAngle / 360);
        }
        const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        let tx = 0;
        let ty = 0;
        let tz = 0;
        if (slideIndex % 4 === 0) {
          tx = -round * 4 * swiperSize;
          tz = 0;
        } else if ((slideIndex - 1) % 4 === 0) {
          tx = 0;
          tz = -round * 4 * swiperSize;
        } else if ((slideIndex - 2) % 4 === 0) {
          tx = swiperSize + round * 4 * swiperSize;
          tz = swiperSize;
        } else if ((slideIndex - 3) % 4 === 0) {
          tx = -swiperSize;
          tz = 3 * swiperSize + swiperSize * 4 * round;
        }
        if (rtl) {
          tx = -tx;
        }
        if (!isHorizontal) {
          ty = tx;
          tx = 0;
        }
        const transform2 = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
        if (progress <= 1 && progress > -1) {
          wrapperRotate = slideIndex * 90 + progress * 90;
          if (rtl)
            wrapperRotate = -slideIndex * 90 - progress * 90;
        }
        $slideEl.transform(transform2);
        if (params.slideShadows) {
          createSlideShadows($slideEl, progress, isHorizontal);
        }
      }
      $wrapperEl.css({
        "-webkit-transform-origin": `50% 50% -${swiperSize / 2}px`,
        "transform-origin": `50% 50% -${swiperSize / 2}px`
      });
      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
        } else {
          const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
          const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
          const scale1 = params.shadowScale;
          const scale2 = params.shadowScale / multiplier;
          const offset2 = params.shadowOffset;
          $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset2}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
        }
      }
      const zFactor = browser2.isSafari || browser2.isWebView ? -swiperSize / 2 : 0;
      $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper2.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper2.isHorizontal() ? -wrapperRotate : 0}deg)`);
      $wrapperEl[0].style.setProperty("--swiper-cube-translate-z", `${zFactor}px`);
    };
    const setTransition2 = (duration) => {
      const {
        $el,
        slides
      } = swiper2;
      slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
      if (swiper2.params.cubeEffect.shadow && !swiper2.isHorizontal()) {
        $el.find(".swiper-cube-shadow").transition(duration);
      }
    };
    effectInit({
      effect: "cube",
      swiper: swiper2,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      recreateShadows,
      getEffectParams: () => swiper2.params.cubeEffect,
      perspective: () => true,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true
      })
    });
  }

  // node_modules/swiper/shared/create-shadow.js
  function createShadow(params, $slideEl, side) {
    const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ""}`;
    const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
    let $shadowEl = $shadowContainer.children(`.${shadowClass}`);
    if (!$shadowEl.length) {
      $shadowEl = dom_default(`<div class="swiper-slide-shadow${side ? `-${side}` : ""}"></div>`);
      $shadowContainer.append($shadowEl);
    }
    return $shadowEl;
  }

  // node_modules/swiper/modules/effect-flip/effect-flip.js
  function EffectFlip({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      flipEffect: {
        slideShadows: true,
        limitRotation: true,
        transformEl: null
      }
    });
    const createSlideShadows = ($slideEl, progress, params) => {
      let shadowBefore = swiper2.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
      let shadowAfter = swiper2.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
      if (shadowBefore.length === 0) {
        shadowBefore = createShadow(params, $slideEl, swiper2.isHorizontal() ? "left" : "top");
      }
      if (shadowAfter.length === 0) {
        shadowAfter = createShadow(params, $slideEl, swiper2.isHorizontal() ? "right" : "bottom");
      }
      if (shadowBefore.length)
        shadowBefore[0].style.opacity = Math.max(-progress, 0);
      if (shadowAfter.length)
        shadowAfter[0].style.opacity = Math.max(progress, 0);
    };
    const recreateShadows = () => {
      const params = swiper2.params.flipEffect;
      swiper2.slides.each((slideEl) => {
        const $slideEl = dom_default(slideEl);
        let progress = $slideEl[0].progress;
        if (swiper2.params.flipEffect.limitRotation) {
          progress = Math.max(Math.min(slideEl.progress, 1), -1);
        }
        createSlideShadows($slideEl, progress, params);
      });
    };
    const setTranslate2 = () => {
      const {
        slides,
        rtlTranslate: rtl
      } = swiper2;
      const params = swiper2.params.flipEffect;
      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        let progress = $slideEl[0].progress;
        if (swiper2.params.flipEffect.limitRotation) {
          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        }
        const offset2 = $slideEl[0].swiperSlideOffset;
        const rotate = -180 * progress;
        let rotateY = rotate;
        let rotateX = 0;
        let tx = swiper2.params.cssMode ? -offset2 - swiper2.translate : -offset2;
        let ty = 0;
        if (!swiper2.isHorizontal()) {
          ty = tx;
          tx = 0;
          rotateX = -rotateY;
          rotateY = 0;
        } else if (rtl) {
          rotateY = -rotateY;
        }
        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
        if (params.slideShadows) {
          createSlideShadows($slideEl, progress, params);
        }
        const transform2 = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.transform(transform2);
      }
    };
    const setTransition2 = (duration) => {
      const {
        transformEl
      } = swiper2.params.flipEffect;
      const $transitionElements = transformEl ? swiper2.slides.find(transformEl) : swiper2.slides;
      $transitionElements.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
      effectVirtualTransitionEnd({
        swiper: swiper2,
        duration,
        transformEl
      });
    };
    effectInit({
      effect: "flip",
      swiper: swiper2,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      recreateShadows,
      getEffectParams: () => swiper2.params.flipEffect,
      perspective: () => true,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: !swiper2.params.cssMode
      })
    });
  }

  // node_modules/swiper/modules/effect-coverflow/effect-coverflow.js
  function EffectCoverflow({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        scale: 1,
        modifier: 1,
        slideShadows: true,
        transformEl: null
      }
    });
    const setTranslate2 = () => {
      const {
        width: swiperWidth,
        height: swiperHeight,
        slides,
        slidesSizesGrid
      } = swiper2;
      const params = swiper2.params.coverflowEffect;
      const isHorizontal = swiper2.isHorizontal();
      const transform2 = swiper2.translate;
      const center = isHorizontal ? -transform2 + swiperWidth / 2 : -transform2 + swiperHeight / 2;
      const rotate = isHorizontal ? params.rotate : -params.rotate;
      const translate = params.depth;
      for (let i = 0, length = slides.length; i < length; i += 1) {
        const $slideEl = slides.eq(i);
        const slideSize = slidesSizesGrid[i];
        const slideOffset = $slideEl[0].swiperSlideOffset;
        const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
        const offsetMultiplier = typeof params.modifier === "function" ? params.modifier(centerOffset) : centerOffset * params.modifier;
        let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
        let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
        let translateZ = -translate * Math.abs(offsetMultiplier);
        let stretch = params.stretch;
        if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
          stretch = parseFloat(params.stretch) / 100 * slideSize;
        }
        let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
        let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
        let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
        if (Math.abs(translateX) < 1e-3)
          translateX = 0;
        if (Math.abs(translateY) < 1e-3)
          translateY = 0;
        if (Math.abs(translateZ) < 1e-3)
          translateZ = 0;
        if (Math.abs(rotateY) < 1e-3)
          rotateY = 0;
        if (Math.abs(rotateX) < 1e-3)
          rotateX = 0;
        if (Math.abs(scale) < 1e-3)
          scale = 0;
        const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.transform(slideTransform);
        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
        if (params.slideShadows) {
          let $shadowBeforeEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
          let $shadowAfterEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
          if ($shadowBeforeEl.length === 0) {
            $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? "left" : "top");
          }
          if ($shadowAfterEl.length === 0) {
            $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? "right" : "bottom");
          }
          if ($shadowBeforeEl.length)
            $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
          if ($shadowAfterEl.length)
            $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
        }
      }
    };
    const setTransition2 = (duration) => {
      const {
        transformEl
      } = swiper2.params.coverflowEffect;
      const $transitionElements = transformEl ? swiper2.slides.find(transformEl) : swiper2.slides;
      $transitionElements.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
    };
    effectInit({
      effect: "coverflow",
      swiper: swiper2,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      perspective: () => true,
      overwriteParams: () => ({
        watchSlidesProgress: true
      })
    });
  }

  // node_modules/swiper/modules/effect-creative/effect-creative.js
  function EffectCreative({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      creativeEffect: {
        transformEl: null,
        limitProgress: 1,
        shadowPerProgress: false,
        progressMultiplier: 1,
        perspective: true,
        prev: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        },
        next: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        }
      }
    });
    const getTranslateValue = (value2) => {
      if (typeof value2 === "string")
        return value2;
      return `${value2}px`;
    };
    const setTranslate2 = () => {
      const {
        slides,
        $wrapperEl,
        slidesSizesGrid
      } = swiper2;
      const params = swiper2.params.creativeEffect;
      const {
        progressMultiplier: multiplier
      } = params;
      const isCenteredSlides = swiper2.params.centeredSlides;
      if (isCenteredSlides) {
        const margin = slidesSizesGrid[0] / 2 - swiper2.params.slidesOffsetBefore || 0;
        $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
      }
      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        const slideProgress = $slideEl[0].progress;
        const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
        let originalProgress = progress;
        if (!isCenteredSlides) {
          originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
        }
        const offset2 = $slideEl[0].swiperSlideOffset;
        const t = [swiper2.params.cssMode ? -offset2 - swiper2.translate : -offset2, 0, 0];
        const r = [0, 0, 0];
        let custom = false;
        if (!swiper2.isHorizontal()) {
          t[1] = t[0];
          t[0] = 0;
        }
        let data = {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          scale: 1,
          opacity: 1
        };
        if (progress < 0) {
          data = params.next;
          custom = true;
        } else if (progress > 0) {
          data = params.prev;
          custom = true;
        }
        t.forEach((value2, index2) => {
          t[index2] = `calc(${value2}px + (${getTranslateValue(data.translate[index2])} * ${Math.abs(progress * multiplier)}))`;
        });
        r.forEach((value2, index2) => {
          r[index2] = data.rotate[index2] * Math.abs(progress * multiplier);
        });
        $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
        const translateString = t.join(", ");
        const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
        const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
        const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
        const transform2 = `translate3d(${translateString}) ${rotateString} ${scaleString}`;
        if (custom && data.shadow || !custom) {
          let $shadowEl = $slideEl.children(".swiper-slide-shadow");
          if ($shadowEl.length === 0 && data.shadow) {
            $shadowEl = createShadow(params, $slideEl);
          }
          if ($shadowEl.length) {
            const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
            $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
          }
        }
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.transform(transform2).css({
          opacity: opacityString
        });
        if (data.origin) {
          $targetEl.css("transform-origin", data.origin);
        }
      }
    };
    const setTransition2 = (duration) => {
      const {
        transformEl
      } = swiper2.params.creativeEffect;
      const $transitionElements = transformEl ? swiper2.slides.find(transformEl) : swiper2.slides;
      $transitionElements.transition(duration).find(".swiper-slide-shadow").transition(duration);
      effectVirtualTransitionEnd({
        swiper: swiper2,
        duration,
        transformEl,
        allSlides: true
      });
    };
    effectInit({
      effect: "creative",
      swiper: swiper2,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      perspective: () => swiper2.params.creativeEffect.perspective,
      overwriteParams: () => ({
        watchSlidesProgress: true,
        virtualTranslate: !swiper2.params.cssMode
      })
    });
  }

  // node_modules/swiper/modules/effect-cards/effect-cards.js
  function EffectCards({
    swiper: swiper2,
    extendParams,
    on: on2
  }) {
    extendParams({
      cardsEffect: {
        slideShadows: true,
        transformEl: null,
        rotate: true,
        perSlideRotate: 2,
        perSlideOffset: 8
      }
    });
    const setTranslate2 = () => {
      const {
        slides,
        activeIndex
      } = swiper2;
      const params = swiper2.params.cardsEffect;
      const {
        startTranslate,
        isTouched
      } = swiper2.touchEventsData;
      const currentTranslate = swiper2.translate;
      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        const slideProgress = $slideEl[0].progress;
        const progress = Math.min(Math.max(slideProgress, -4), 4);
        let offset2 = $slideEl[0].swiperSlideOffset;
        if (swiper2.params.centeredSlides && !swiper2.params.cssMode) {
          swiper2.$wrapperEl.transform(`translateX(${swiper2.minTranslate()}px)`);
        }
        if (swiper2.params.centeredSlides && swiper2.params.cssMode) {
          offset2 -= slides[0].swiperSlideOffset;
        }
        let tX = swiper2.params.cssMode ? -offset2 - swiper2.translate : -offset2;
        let tY = 0;
        const tZ = -100 * Math.abs(progress);
        let scale = 1;
        let rotate = -params.perSlideRotate * progress;
        let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
        const slideIndex = swiper2.virtual && swiper2.params.virtual.enabled ? swiper2.virtual.from + i : i;
        const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper2.params.cssMode) && currentTranslate < startTranslate;
        const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper2.params.cssMode) && currentTranslate > startTranslate;
        if (isSwipeToNext || isSwipeToPrev) {
          const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
          rotate += -28 * progress * subProgress;
          scale += -0.5 * subProgress;
          tXAdd += 96 * subProgress;
          tY = `${-25 * subProgress * Math.abs(progress)}%`;
        }
        if (progress < 0) {
          tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
        } else if (progress > 0) {
          tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
        } else {
          tX = `${tX}px`;
        }
        if (!swiper2.isHorizontal()) {
          const prevY = tY;
          tY = tX;
          tX = prevY;
        }
        const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
        const transform2 = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rotate : 0}deg)
        scale(${scaleString})
      `;
        if (params.slideShadows) {
          let $shadowEl = $slideEl.find(".swiper-slide-shadow");
          if ($shadowEl.length === 0) {
            $shadowEl = createShadow(params, $slideEl);
          }
          if ($shadowEl.length)
            $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
        }
        $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
        const $targetEl = effectTarget(params, $slideEl);
        $targetEl.transform(transform2);
      }
    };
    const setTransition2 = (duration) => {
      const {
        transformEl
      } = swiper2.params.cardsEffect;
      const $transitionElements = transformEl ? swiper2.slides.find(transformEl) : swiper2.slides;
      $transitionElements.transition(duration).find(".swiper-slide-shadow").transition(duration);
      effectVirtualTransitionEnd({
        swiper: swiper2,
        duration,
        transformEl
      });
    };
    effectInit({
      effect: "cards",
      swiper: swiper2,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      perspective: () => true,
      overwriteParams: () => ({
        watchSlidesProgress: true,
        virtualTranslate: !swiper2.params.cssMode
      })
    });
  }

  // node_modules/swiper/swiper-bundle.esm.js
  var modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
  core_default.use(modules);

  // src/components/slider/slider.js
  document.addEventListener("DOMContentLoaded", () => {
    let loaderRevContent = document.querySelector(".js-loader-review-content");
    let loaderRev = document.querySelector(".js-loader-review");
    !!loaderRevContent && loaderRevContent.removeAttribute("style");
    !!loaderRev && loaderRev.remove();
  });
  function initSwiper(slider3, index2 = 0) {
    const sliderParams = JSON.parse(slider3.getAttribute("data-slider"));
    const sliderPagination = slider3.querySelector(".swiper-pagination");
    const sliderBtnNext = slider3.querySelector(".swiper-button-next");
    const sliderBtnPrev = slider3.querySelector(".swiper-button-prev");
    let clikbleParam = false;
    if (!slider3.classList.contains("card-product__slider") && !slider3.classList.contains("slider__product")) {
      clikbleParam = true;
    }
    let elementsPerSide = sliderParams.slidesPerView ?? null;
    if (!elementsPerSide && sliderParams.breakpoints) {
      for (let breakpoint in sliderParams.breakpoints) {
        if (window.innerWidth >= +breakpoint) {
          elementsPerSide = sliderParams.breakpoints[breakpoint].slidesPerView;
        } else
          break;
      }
    } else
      elementsPerSide = 3;
    const numberOfSlides = slider3.querySelector(".swiper-wrapper").children.length;
    if ((slider3.classList.contains("slider__reviews") || slider3.classList.contains("slider__product")) && (elementsPerSide >= numberOfSlides || elementsPerSide === "auto")) {
      sliderBtnNext.classList.add("is-hidden");
      sliderBtnPrev.classList.add("is-hidden");
    }
    const swiper2 = new core_default(slider3, {
      pagination: {
        el: sliderPagination,
        clickable: clikbleParam
      },
      navigation: {
        nextEl: sliderBtnNext,
        prevEl: sliderBtnPrev
      },
      ...sliderParams
    });
    if (slider3.matches(".card-product__slider")) {
      slider3.addEventListener("mouseleave", () => {
        swiper2.slideTo(0);
      });
    }
  }
  var sliders = document.querySelectorAll(".js-slider");
  function initAllSliders() {
    sliders.length > 0 && sliders.forEach((slider3, index2) => initSwiper(slider3, index2));
  }
  initAllSliders();
  var swiperBlock = document.querySelector(".js-slider-progress.swiper");
  !!swiperBlock && window.innerWidth > 1280 && document.addEventListener("mouseenter", (event2) => {
    const el = event2.target;
    if (el && el.matches && el.matches(".js-slider-progress.swiper")) {
      el.swiper.autoplay.pause();
      el.classList.add("swiper-paused");
    }
  }, true);
  !!swiperBlock && window.innerWidth > 1280 && document.addEventListener("mouseleave", (event2) => {
    const el = event2.target;
    if (el && el.matches && el.matches(".js-slider-progress.swiper")) {
      el.swiper.autoplay.run();
      el.classList.remove("swiper-paused");
    }
  }, true);
  var listeners = [];
  function changeSlidesOnMouseOver(paginationClass) {
    const swiperBtnOnHover = document.querySelectorAll(paginationClass);
    listeners.forEach((listener) => listener[0].removeEventListener("mouseover", listener[1]));
    window.innerWidth > 1280 && swiperBtnOnHover.forEach((el, i) => {
      const paginationBullet = el.querySelectorAll(".swiper-pagination-bullet");
      paginationBullet.forEach((dot, idx) => {
        listeners.push([dot, dot.addEventListener("mouseover", (e2) => {
          const slider3 = e2.target.closest(".swiper").swiper;
          !!slider3 && slider3.slideTo(idx);
        })]);
      });
    });
  }
  changeSlidesOnMouseOver(".js-pagination-hover");
  var toggleMutation = false;
  document.addEventListener("click", (event2) => {
    toggleMutation = [
      ".pagination__item",
      ".sort-products__item",
      ".pagination__more-link"
    ].findIndex((className) => !!event2.target.closest(className)) !== -1;
  });
  var mutationObserver = new MutationObserver((mutations) => {
    toggleMutation && mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (!!node?.querySelector) {
          node?.querySelectorAll(".js-slider").forEach((slider3) => {
            !!slider3 && initSwiper(slider3);
          });
          changeSlidesOnMouseOver(".js-pagination-hover");
        }
      });
    });
  });
  mutationObserver.observe(document.documentElement, {
    childList: true,
    subtree: true,
    characterData: true
  });

  // src/components/header/catalog-popup/catalog-popup.js
  var catalogBtn = document.querySelector(".js-catalog");
  var catalogPopup = document.querySelector(".js-catalog-popup");
  var catalogList = document.querySelector(".catalog-popup__menu-list");
  var catalogPopupPanel = document.querySelector(".catalog-popup__panel");
  var catalogPopupWrapper = document.querySelector(".js-catalog-perfect-scroll");
  !!catalogPopupWrapper && new perfect_scrollbar_esm_default(catalogPopupWrapper, {
    wheelSpeed: 0.5,
    wheelPropagation: false
  });
  var wrapperPsY = document.querySelector("body > .wrapper > .ps__rail-y");
  !!catalogBtn && catalogBtn.addEventListener("click", () => {
    catalogBtn.classList.toggle("open-catalog");
    if (catalogPopup.classList.contains("hide-catalog")) {
      catalogPopup.classList.remove("hide-catalog");
      document.addEventListener("click", hideCatalog);
      setTimeout(() => {
        changeSlidesOnMouseOver(".catalog-popup__product-slider .js-pagination-hover");
      }, 100);
    } else {
      catalogPopup.classList.add("hide-catalog");
      document.removeEventListener("click", hideCatalog);
    }
  });
  !!catalogPopup && document.documentElement.addEventListener("click", (e2) => {
    if (!e2.target.closest(".js-catalog-popup") && !e2.target.closest(".js-catalog") && !e2.target.closest(".catalog-popup__product-slider")) {
      catalogPopup.classList.add("hide-catalog");
      catalogBtn.classList.remove("open-catalog");
    }
  });
  var hideCatalog = (event2) => {
    if (event2.target.closest(".catalog-popup__backdrop")) {
      catalogBtn.classList.toggle("open-catalog");
      catalogPopup.classList.add("hide-catalog");
    }
  };
  var sendCatalogId = (0, import_debounce.debounce)((evt) => {
    const linkItem = evt.target.closest(".catalog-popup__menu-item");
    const dataId = linkItem && linkItem.getAttribute("data-id");
    if (linkItem && !catalogPopup.classList.contains("hide-catalog")) {
      fetch(`/local/ajax/get_category_list.php?id=${dataId}`).then((response) => response.text()).then((data) => {
        catalogPopupPanel.innerHTML = data;
      }).catch((error) => {
        catalogPopupPanel.innerHTML = "<p>\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0435 \u043C\u0435\u043D\u044E</p>";
      });
    }
  }, 500);
  !!catalogList && catalogList.addEventListener("mouseover", sendCatalogId);

  // src/components/header/catalog-popup/catalog-slider/catalog-slider.js
  var slider = document.querySelector(".catalog-slider");
  var value = document.querySelector(".catalog-slider__buttons-count");
  var swiper = new core_default(slider, {
    modules: [Navigation],
    slidesPerView: 1,
    slideClass: "slider__product-item",
    allowTouchMove: true,
    navigation: {
      prevEl: ".catalog-slider-button--prev",
      nextEl: ".catalog-slider-button--next"
    },
    pagination: {
      clickable: false
    }
  });
  function addNumSlide() {
    if (!!value) {
      value.textContent = `${swiper.activeIndex + 1} \u0438\u0437 ${swiper.slides.length}`;
    }
  }
  swiper.on("slideChange", () => {
    addNumSlide();
  });

  // src/components/header/navigation/navigation.js
  document.addEventListener("DOMContentLoaded", () => {
    const navDropdown = document.querySelector(".navigation__top-dropdown");
    const geoModal = document.getElementById("geo-popup");
    const currentCity2 = document.querySelector(".navigation__top-geo-text");
    const cityListBlock = document.querySelector(".geo-popup__city-list");
    const currentCityPopup = document.querySelector(".navigation__top-dropdown-city");
    const submitBtn2 = !!navDropdown && navDropdown.querySelector(".navigation__top-dropdown-confirm");
    const negativeBtn = !!navDropdown && navDropdown.querySelector(".navigation__top-dropdown-negative");
    !!submitBtn2 && submitBtn2.addEventListener("click", () => {
      !!navDropdown && navDropdown.classList.add("hidden");
      setCookie("city", currentCityPopup.textContent);
      const inputForChecked = document.querySelector(`.geo-popup__city-item-input[value="${currentCityPopup.textContent}"]`);
      if (!!inputForChecked) {
        inputForChecked.checked = true;
      } else {
        const popupGeoItemHtml = `<li class="geo-popup__city-item">
            <input class="geo-popup__city-item-input" type="radio" id="city-00" name="city" value="${getCookie("city")}" checked>
            <label class="geo-popup__city-item-label" for="city-00"><span>${getCookie("city")}</span></label>
          </li>`;
        !!cityListBlock && cityListBlock.insertAdjacentHTML("afterbegin", popupGeoItemHtml);
      }
    });
    !!negativeBtn && negativeBtn.addEventListener("click", () => {
      !!navDropdown && navDropdown.classList.add("hidden");
    });
  });

  // src/components/header/header-search.js
  var import_axios2 = __toModule(require_axios2());
  var import_debounce2 = __toModule(require_debounce());
  var headerSearchDrop = document.querySelectorAll(".js-header-search-drop");
  var searchHeaderForm = document.querySelectorAll(".js-header-search");
  if (headerSearchDrop.length > 0) {
    headerSearchDrop.forEach((searchDrop) => {
      let ps = new perfect_scrollbar_esm_default(searchDrop, {
        wheelSpeed: 2,
        minScrollbarLength: 2
      });
      ;
    });
  }
  var searchInput = document.querySelectorAll(".js-search-input");
  var searchBtnInputReset = document.querySelectorAll(".js-search-btn-reset");
  var searchDropBtnDel = document.querySelectorAll(".js-search-drop-del-btn");
  var searchHistoryBtnRemoveAll = document.querySelectorAll(".js-header-history-remove-all");
  !!searchHeaderForm.length > 0 && searchHeaderForm.forEach((form3) => {
    form3.addEventListener("submit", (e2) => {
      e2.preventDefault();
      const url2 = form3.getAttribute("action");
      const formInput = form3.querySelector(".js-search-input");
      const value2 = !!formInput && formInput.value;
      const formBtn = form3.querySelector(".header__search-btn");
      !!formInput.value.trim() && !!formBtn && formBtn.getAttribute("disabled", true);
      !!formInput.value.trim() && import_axios2.default.get(`${url2}?search=${value2}`).then(function(response) {
        !!formBtn && formBtn.removeAttribute("disabled");
        history.pushState({}, "", `/catalog/?search=${value2}`);
        location.reload();
      }).catch(function(error) {
        !!formBtn && formBtn.removeAttribute("disabled");
      });
    });
  });
  searchDropBtnDel.length > 0 && searchDropBtnDel.forEach((btn) => {
    btn.addEventListener("click", (e2) => {
      e2.preventDefault();
      const form3 = btn.closest(".js-header-search");
      const historyDrop = btn.previousSibling;
      const historyDropText = historyDrop.textContent;
      import_axios2.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:Search&action=clearHistory&word=${historyDropText}`).then(function(response) {
        const btnParent = btn.closest(".header__search-drop-history-body-item");
        const history2 = !!form3 && form3.querySelector(".js-search-drop-history");
        const historyBody = !!history2 && history2.querySelector(".header__search-drop-history-body");
        if (historyBody.childElementCount <= 1) {
          history2.classList.remove("is-show");
        }
        btnParent.remove();
      }).catch(function(error) {
      });
    });
  });
  searchHistoryBtnRemoveAll.length > 0 && searchHistoryBtnRemoveAll.forEach((btn) => {
    btn.addEventListener("click", (e2) => {
      e2.preventDefault();
      const historyBlock = btn.closest(".js-search-drop-history");
      btn.setAttribute("disabled", true);
      import_axios2.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:Search&action=clearHistory&word=all`).then(function(response) {
        historyBlock.remove();
      }).catch(function(error) {
        btn.removeAttribute("disabled");
      });
    });
  });
  function getSearchList(e2, searchBtnReset, searchDropHistory, searchDropSearchs) {
    const inputValue = e2.target.value;
    !!inputValue.trim() && import_axios2.default.get(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:Search&action=search&name=${encodeURIComponent(inputValue)}`).then(function(response) {
      searchBtnReset.classList.add("is-show");
      !!searchDropHistory && searchDropHistory.classList.remove("is-show");
      searchDropSearchs.classList.add("is-show");
      const { data } = response;
      if (data.data.length > 0) {
        searchDropSearchs.innerHTML = data.data.slice(0, 8).map((item) => `<a class="header__search-drop-searchs-item" href="${item.DETAIL_PAGE_URL}">
                    ${window.innerWidth > 1022 ? `<svg class="icon search-icon-mobile" width="14px" height="14px">
                            <use xlink:href="${item.PATH}/sprite.svg#search-icon-mobile"></use>
                    </svg>` : ""}
                    <div class="header__search-drop-searchs-item-text">${item.NAME}</div>
                </a>`).join("");
      } else {
        searchDropSearchs.innerHTML = "";
      }
    }).catch(function(error) {
    });
    if (!inputValue.trim()) {
      const searchDropHistoryChild = !!searchDropHistory && searchDropHistory.querySelector(".header__search-drop-history-body-item");
      !!searchDropHistory && !!searchDropHistoryChild && searchDropHistory.classList.add("is-show");
      searchBtnReset.classList.remove("is-show");
      searchDropSearchs.classList.remove("is-show");
    }
  }
  var debouncedOnInputSearch = (0, import_debounce2.debounce)(getSearchList, 500);
  searchInput.length > 0 && searchInput.forEach((el) => {
    const dropId = el.getAttribute("data-drop");
    const searchDrop = document.querySelector(`#${dropId}`);
    const parentElInputSearch = el.parentElement;
    const searchBtnReset = parentElInputSearch.querySelector(".js-search-btn-reset");
    const searchDropHistory = searchDrop.querySelector(".js-search-drop-history");
    const searchDropSearchs = searchDrop.querySelector(".js-search-drop-searchs");
    const searchDropInner = searchDrop.querySelector(".js-header-search-drop");
    el.addEventListener("focus", (e2) => {
      const dropId2 = el.getAttribute("data-drop");
      const searchDrop2 = document.querySelector(`#${dropId2}`);
      searchDrop2.classList.add("is-active");
      if (window.innerWidth <= 1023) {
        disableBodyScroll(searchDropInner);
      }
    });
    el.addEventListener("input", (e2) => debouncedOnInputSearch(e2, searchBtnReset, searchDropHistory, searchDropSearchs));
  });
  searchBtnInputReset.length > 0 && searchBtnInputReset.forEach((btn) => {
    btn.addEventListener("click", (e2) => {
      const btnParentElement = btn.parentElement;
      const inputs2 = btnParentElement.querySelectorAll("input");
      inputs2.forEach((inp) => {
        const inpAttrDrop = inp.classList.contains("js-search-input") && inp.getAttribute("data-drop");
        const dropBlock = !!inpAttrDrop && document.querySelector(`#${inpAttrDrop}`);
        const searchDropHistory = !!dropBlock && dropBlock.querySelector(".js-search-drop-history");
        const searchDropHistoryChild = !!searchDropHistory && searchDropHistory.querySelector(".header__search-drop-history-body-item");
        const searchDropSearchs = !!dropBlock && dropBlock.querySelector(".js-search-drop-searchs");
        !!searchDropHistory && !!searchDropHistoryChild && searchDropHistory.classList.add("is-show");
        btn.classList.remove("is-show");
        !!searchDropSearchs && searchDropSearchs.classList.remove("is-show");
        inp.value = "";
      });
    });
  });
  searchInput.length > 0 && document.addEventListener("click", (e2) => {
    if (!e2.target.closest(".js-search-drop") && !e2.target.closest(".js-search-input") && !e2.target.closest(".js-mobile-catalog")) {
      const searchDrop = document.querySelectorAll(".js-search-drop");
      searchDrop.forEach((el) => {
        el.classList.remove("is-active");
        const searchDropInner = el.querySelector(".js-header-search-drop");
        if (window.innerWidth <= 1023) {
          enableBodyScroll(searchDropInner);
        }
      });
    }
  });

  // src/js/utils/timer.js
  var timer = (blockClass, deadline) => {
    function getTime(endtime) {
      const t = Date.parse(endtime) - Date.parse(new Date()), days = Math.floor(t / (1e3 * 60 * 60 * 24)), hours = Math.floor(t / (1e3 * 60 * 60) % 24), minutes = Math.floor(t / 1e3 / 60 % 60), seconds = Math.floor(t / 1e3 % 60);
      return {
        "total": t,
        "days": days,
        "hours": hours,
        "minutes": minutes,
        "seconds": seconds
      };
    }
    function changeSecondsText(number, titles) {
      cases = [2, 0, 1, 1, 1, 2];
      return titles[number % 100 > 4 && number % 100 < 20 ? 2 : cases[number % 10 < 5 ? number % 10 : 5]];
    }
    function changeDaysText(daysNum, titles) {
      return daysNum == 1 || daysNum > 19 && daysNum % 10 == 1 ? titles[0] : daysNum > 1 && daysNum < 5 || daysNum > 19 && daysNum % 10 > 1 && daysNum % 10 < 5 ? titles[1] : titles[2];
    }
    function getZero(num) {
      if (num >= 0 && num < 10) {
        return `0${num}`;
      } else {
        return num;
      }
    }
    function setClock(selector, endtime) {
      const timer2 = document.querySelector(selector), days = timer2.querySelector("#days"), hours = timer2.querySelector("#hours"), minutes = timer2.querySelector("#minutes"), seconds = timer2.querySelector("#seconds"), daysText = timer2.querySelector("#daysText"), hoursText = timer2.querySelector("#hoursText"), minutesText = timer2.querySelector("#minutesText"), secondsText = timer2.querySelector("#secondsText"), timeInterval = setInterval(updateClock, 1e3);
      updateClock();
      function updateClock() {
        const t = getTime(endtime);
        days.innerHTML = t.days;
        hours.innerHTML = getZero(t.hours);
        minutes.innerHTML = getZero(t.minutes);
        seconds.innerHTML = getZero(t.seconds);
        daysText.innerHTML = changeDaysText(days, ["\u0434\u0435\u043D\u044C", "\u0434\u043D\u044F", "\u0434\u043D\u0435\u0439"]);
        hoursText.innerHTML = changeDaysText(getZero(t.hours), ["\u0447\u0430\u0441", "\u0447\u0430\u0441\u0430", "\u0447\u0430\u0441\u043E\u0432"]);
        minutesText.innerHTML = changeDaysText(getZero(t.minutes), ["\u043C\u0438\u043D\u0443\u0442\u0430", "\u043C\u0438\u043D\u0443\u0442\u044B", "\u043C\u0438\u043D\u0443\u0442"]);
        secondsText.innerHTML = changeSecondsText(getZero(t.seconds), ["\u0441\u0435\u043A\u0443\u043D\u0434\u0430", "\u0441\u0435\u043A\u0443\u043D\u0434\u044B", "\u0441\u0435\u043A\u0443\u043D\u0434"]);
        if (t.total <= 0) {
          clearInterval(timeInterval);
        }
      }
    }
    setClock(blockClass, deadline);
  };

  // src/components/banners/stock-banner/stock-banner.js
  var timerElem = document.querySelector(".js-timer");
  var timerDate = !!timerElem && timerElem.getAttribute("data-timer");
  !!timerElem && timer(".js-timer", timerDate);

  // src/components/mobile-menu/mobile-menu.js
  var catalogMobileBtn = document.querySelector(".js-mobile-catalog");
  var catalogMobile = document.querySelector(".js-catalog-popup-mobile");
  var popupMenuDetail = document.querySelector(".js-popup#mobile-menu-detail .popup__container");
  var isOpen = false;
  !!catalogMobileBtn && catalogMobileBtn.addEventListener("click", () => {
    isOpen = !isOpen;
    catalogMobile.style.display = isOpen ? "block" : "none";
    isOpen ? disableBodyScroll(catalogMobile) : enableBodyScroll(catalogMobile);
    !isOpen && document.body.classList.remove("overflow");
    !isOpen && !!popupMenuDetail && enableBodyScroll(popupMenuDetail);
    document.body.style = !isOpen ? "" : "overflow: hidden";
  });

  // src/components/popup/geo-popup/geo-popup.js
  var currentCity = document.querySelectorAll(".navigation__top-geo-text");
  var cityListRadio = document.querySelectorAll(".geo-popup__city-item-input");
  var searchCityInput = document.querySelector(".geo-popup__search-input");
  var cityList = document.querySelector(".geo-popup__city-list");
  var citySmallPopup = document.querySelector(".navigation__top-dropdown");
  var citiPopup = document.querySelector("#geo-popup");
  var citiPopupList = !!citiPopup && citiPopup.querySelector(".geo-popup__city-list");
  var citiPopupListHtml = citiPopupList.innerHTML;
  document.addEventListener("DOMContentLoaded", function(event2) {
    if (getCookie("city") && currentCity.length) {
      !!citySmallPopup && citySmallPopup.classList.add("hidden");
      currentCity.forEach((city) => city.textContent = getCookie("city"));
    }
    ;
  });
  document.addEventListener("click", function(event2) {
    const cityListRadio2 = event2.target.closest(".geo-popup__city-item-input");
    if (cityListRadio2) {
      currentCity.forEach((city) => city.textContent = event2.target.value);
      setCookie("city", event2.target.value);
      !!citiPopup && citiPopup.click();
    }
  });
  searchCityInput && searchCityInput.addEventListener("input", (evt) => {
    const value2 = evt.target.value.trim();
    if (value2.length >= 3) {
      fetch(`/local/ajax/get_list_city.php?city=${value2}`).then((res) => res.json()).then((data) => {
        if (data.length > 0) {
          cityList.innerHTML = data.map((elCity, index2) => `<li class="geo-popup__city-item">
            <input class="geo-popup__city-item-input" type="radio" id="city-${index2}" name="city" value="${elCity}">
             <label class="geo-popup__city-item-label" for="city-${index2}"><span>${elCity}</span></label>
           </li>`).join("");
        } else {
          cityList.innerHTML = "<p>\u0422\u0430\u043A\u043E\u0433\u043E \u0433\u043E\u0440\u043E\u0434\u0430 \u043D\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442</p>";
        }
      }).catch((error) => {
        cityList.innerHTML = "<p>\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0435 \u0434\u0430\u043D\u043D\u044B\u0445</p>";
      });
    }
    if (!value2.length) {
      citiPopupList.innerHTML = citiPopupListHtml;
      if (getCookie("city")) {
        const inputCitiCurrent = document.querySelector(`.geo-popup__city-item-input[value="${getCookie("city")}"]`);
        if (!!inputCitiCurrent) {
          inputCitiCurrent.checked = true;
        } else {
          const popupGeoItemHtml = `<li class="geo-popup__city-item">
            <input class="geo-popup__city-item-input" type="radio" id="city-00" name="city" value="${getCookie("city")}" checked>
            <label class="geo-popup__city-item-label" for="city-00"><span>${getCookie("city")}</span></label>
          </li>`;
          cityList.insertAdjacentHTML("afterbegin", popupGeoItemHtml);
        }
      }
    }
  });

  // src/components/popup/sign-in-popup/sign-in-popup.js
  var import_inputmask = __toModule(require_inputmask());
  var import_axios3 = __toModule(require_axios2());
  var form = document.querySelector(".js-form-sign-in");
  var phoneInputs = !!form && form.querySelectorAll(".js-input-phone");
  var submitBtn = !!form && form.querySelector(".sign-in-popup__phone-button");
  var submitBtnConfifirm = !!form && form.querySelector(".js-submit-btn-confirm-sign-in");
  var inputSignInConfirmCode = !!form && form.querySelector(".js-code-sign-in");
  var signInWrapper = document.querySelector(".js-sign-in-wrap");
  var signInTitlePhone = document.querySelector(".js-sign-in-phone-subtitle");
  if (!!phoneInputs.length) {
    for (const input of phoneInputs) {
      (0, import_inputmask.default)({
        mask: phonePattern,
        showMaskOnHover: false
      }).mask(input);
      input.addEventListener("input", () => {
        const isValid2 = import_inputmask.default.isValid(input.value, {
          mask: phonePattern
        });
        submitBtn.disabled = !isValid2;
      });
    }
  }
  !!inputSignInConfirmCode && inputSignInConfirmCode.addEventListener("input", (e2) => {
    const val = inputSignInConfirmCode.value;
    val.length >= 4 ? submitBtnConfifirm.removeAttribute("disabled") : submitBtnConfifirm.setAttribute("disabled", true);
  });
  var timerSignInField = document.querySelector(".js-sign-in-time");
  var updateSignInTimeField = () => {
    if (!!timerSignInField) {
      timerSignInField.textContent = Number(timerSignInField.textContent) - 1;
    }
  };
  var setIntervalAction = (btn, text2, time = 60) => {
    timerSignInField.textContent = time;
    const timeoutTime = Number(time) * 1e3;
    const timeInterval = setInterval(updateSignInTimeField, 1e3);
    setTimeout(() => {
      btn.classList.remove("hide");
      text2.classList.add("hide");
      clearInterval(timeInterval);
      timerSignInField.textContent = time;
    }, timeoutTime);
  };
  var btnGetConfirmCode = !!form && form.querySelector(".js-submit-btn-phone-sign-in");
  var btnConfirmSignIn = !!form && form.querySelector(".js-submit-btn-confirm-sign-in");
  var btnConfirmRepeatSignIn = !!form && form.querySelector(".js-btn-wait-sign-in");
  var formWaitBtn = !!form && form.querySelector(".js-btn-wait-sign-in");
  var formWaitText = !!form && form.querySelector(".js-btn-text-sign-in");
  var url = !!form && form.getAttribute("action");
  !!btnGetConfirmCode && btnGetConfirmCode.addEventListener("click", (event2) => {
    event2.preventDefault();
    const inputPhoneVal = form.querySelector(".js-input-phone").value;
    btnGetConfirmCode.insertAdjacentHTML("beforeend", `<div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`);
    btnGetConfirmCode.setAttribute("disabled", true);
    import_axios3.default.post(url, { phone: inputPhoneVal }).then((response) => {
      if (response.status === 200) {
        const { data } = response;
        const time = data.time;
        !!signInWrapper && signInWrapper.classList.add("is-confirm");
        signInTitlePhone.textContent = inputPhoneVal;
        formWaitBtn.classList.add("hide");
        setIntervalAction(formWaitBtn, formWaitText, time);
      } else {
        btnGetConfirmCode.removeAttribute("disabled");
      }
    }).catch(function(error) {
      !!signInWrapper && signInWrapper.insertAdjacentHTML("beforeend", '<p class="error-sigi-in">\u041E\u0448\u0438\u0431\u043A\u0430! \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.</p>');
      btnGetConfirmCode.removeAttribute("disabled");
      const loader2 = form.querySelector(".lds-ring-mob-wrap");
      !!loader2 && loader2.remove();
    }).finally(function() {
      setTimeout(() => {
        const errForm = !!signInWrapper && signInWrapper.querySelectorAll(".error-sigi-in");
        const loader2 = form.querySelector(".lds-ring-mob-wrap");
        !!errForm.length && errForm.forEach((err) => err.remove());
        !!loader2 && loader2.remove();
      }, 3e3);
    });
  });
  !!btnConfirmSignIn && btnConfirmSignIn.addEventListener("click", (event2) => {
    event2.preventDefault();
    const inputConfirmCodeVal = form.querySelector(".js-code-sign-in").value;
    const inputPhoneVal = form.querySelector(".js-input-phone").value;
    btnConfirmSignIn.insertAdjacentHTML("beforeend", `<div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`);
    btnConfirmSignIn.setAttribute("disabled", true);
    import_axios3.default.post(url, { code: inputConfirmCodeVal, phone: inputPhoneVal }).then((response) => {
      const { data } = response;
      data.register ? window.location.href = "/profile" : window.location.reload();
    }).catch(function(error) {
      !!signInWrapper && signInWrapper.insertAdjacentHTML("beforeend", '<p class="error-sigi-in">\u041E\u0448\u0438\u0431\u043A\u0430! \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.</p>');
    }).finally(function() {
      setTimeout(() => {
        const errForm = !!signInWrapper && signInWrapper.querySelector(".error-sigi-in");
        const loader2 = form.querySelector(".lds-ring-mob-wrap");
        !!errForm && errForm.remove();
        !!loader2 && loader2.remove();
      }, 2e3);
    });
  });
  !!btnConfirmRepeatSignIn && btnConfirmRepeatSignIn.addEventListener("click", (event2) => {
    event2.preventDefault();
    const inputPhoneVal = form.querySelector(".js-input-phone").value;
    btnGetConfirmCode.setAttribute("disabled", true);
    import_axios3.default.post(url, { phone: inputPhoneVal }).then((response) => {
      const { data } = response;
      const time = data.time;
      formWaitBtn.classList.add("hide");
      formWaitText.classList.remove("hide");
      setIntervalAction(formWaitBtn, formWaitText, time);
    }).catch(function(error) {
      !!signInWrapper && signInWrapper.insertAdjacentHTML("beforeend", '<p class="error-sigi-in">\u041E\u0448\u0438\u0431\u043A\u0430! \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.</p>');
    }).finally(function() {
      setTimeout(() => {
        const errForm = !!signInWrapper && signInWrapper.querySelector(".error-sigi-in");
        !!errForm && errForm.remove();
      }, 2e3);
    });
  });

  // src/components/popup/reviews-new/reviews-new.js
  var import_axios4 = __toModule(require_axios2());
  var reviewForm = document.querySelector(".js-form-reviews");
  var reviewArea = !!reviewForm && reviewForm.querySelector(".js-reviews-area");
  var reviewAreaRate = !!reviewForm && reviewForm.querySelector(".js-rater");
  var reviewsSubmitBtn = !!reviewForm && reviewForm.querySelector(".js-reviews-submit-btn");
  var reviewAreaSymb = !!reviewForm && reviewForm.querySelector(".js-area-symb");
  var reviewInputFile = !!reviewForm && reviewForm.querySelector(".js-file-input");
  var reviewPreview = !!reviewForm && reviewForm.querySelector(".js-preview");
  var reviewImgCount = !!reviewForm && reviewForm.querySelector(".js-count-file");
  var reviewSuccess = !!reviewForm && reviewForm.querySelector(".js-review-success");
  var reviewError = !!reviewForm && reviewForm.querySelector(".js-review-error");
  var reviewsPopupBtn = document.querySelector(".reviews-block__rating-block-write");
  var reviewsPopupBtnText = document.querySelector(".reviews-block__rating-block-write span span");
  var reviewProfileModeration = document.querySelector(".js-reviews-profile-moderation-block");
  var raterEl = document.querySelector("#rater");
  var popupReviewRater;
  if (!!raterEl) {
    const rater = require_rater_js();
    popupReviewRater = rater({
      element: raterEl,
      rateCallback: function rateCallback(rating, done) {
        this.setRating(rating);
        done();
        if (!!reviewArea && reviewArea.value.trim()) {
          !!reviewAreaRate && reviewAreaRate.getAttribute("data-rating") && reviewsSubmitBtn.removeAttribute("disabled", true);
        }
      },
      starSize: 25,
      max: 5,
      step: 1
    });
  }
  var reviewAreaSymbText = reviewAreaSymb.textContent;
  !!reviewArea && reviewArea.addEventListener("input", (e2) => {
    if (!reviewArea.value.trim()) {
      reviewsSubmitBtn.setAttribute("disabled", true);
      reviewAreaSymb.textContent = reviewAreaSymbText;
    } else {
      !!reviewAreaRate && reviewAreaRate.getAttribute("data-rating") && reviewsSubmitBtn.removeAttribute("disabled", true);
      reviewAreaSymb.textContent = reviewAreaSymbText - reviewArea.value.length;
    }
  });
  var fileLength = 0;
  var files = [];
  var filesImgs = [];
  !!reviewInputFile && reviewInputFile.addEventListener("change", function(e2) {
    if (!e2.target.files.length) {
      return;
    }
    files = Array.from(e2.target.files);
    fileLength += files.length;
    fileLength <= 5 && files.forEach((file) => {
      reviewImgCount.textContent = fileLength;
      if (!file.type.match("image")) {
        return;
      }
      filesImgs.push(file);
      const reader = new FileReader();
      reader.onload = (e3) => {
        const src = e3.target.result;
        reviewPreview.insertAdjacentHTML("afterbegin", `
            <div class="reviews__imag-wrap">
            <img src ="${src}"/>
            <span class="js-reviews-img-close"></span>
            </div>`);
      };
      reader.readAsDataURL(file);
    });
    if (fileLength > 5 && document.querySelectorAll(".reviews__imag-wrap").length <= 0) {
      fileLength = 0;
    }
    setTimeout(() => {
      if (fileLength >= 5 && document.querySelectorAll(".reviews__imag-wrap").length > 0) {
        reviewInputFile.parentElement.classList.add("disabled");
      }
    }, 10);
  });
  !!reviewPreview && reviewPreview.childNodes.length > 0 && document.addEventListener("click", (e2) => {
    const btnReviewImgRemove = e2.target.closest(".js-reviews-img-close");
    if (!!btnReviewImgRemove) {
      const block = btnReviewImgRemove.closest(".reviews__imag-wrap");
      const im\u0430ges = document.querySelectorAll(".reviews__imag-wrap");
      files = files.filter((file, i) => i !== [...im\u0430ges].indexOf(block));
      filesImgs = filesImgs.filter((file, i) => i !== [...im\u0430ges].indexOf(block));
      setTimeout(() => {
        block.remove();
        fileLength = fileLength - 1;
        reviewImgCount.textContent = fileLength;
        reviewInputFile.parentElement.classList.remove("disabled");
      }, 200);
    }
  });
  !!reviewForm && reviewForm.addEventListener("submit", function(e2) {
    e2.preventDefault();
    const rate = this.querySelector(".js-rater");
    const rateInput = this.querySelector(".js-rater-input");
    rateInput.value = rate.getAttribute("data-rating");
    const data = new FormData(this);
    filesImgs.forEach((file, i) => {
      data.append(filesImgs[i].name, file);
    });
    reviewsSubmitBtn.innerHTML = `\u041E\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u043E\u0442\u0437\u044B\u0432 <div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`;
    reviewsSubmitBtn.setAttribute("disabled", true);
    import_axios4.default.post(`${this.getAttribute("action")}`, data, {
      headers: {
        "Content-Type": "multipart/form-data"
      }
    }).then((response) => {
      reviewSuccess.classList.add("show");
      const popupRewiew = document.querySelector("#reviews-new");
      setTimeout(() => {
        !!popupRewiew && popupRewiew.click();
        reviewAreaSymb.textContent = "1000";
        reviewImgCount.textContent = "0";
        reviewPreview.innerHTML = "";
        popupReviewRater.clear();
        fileLength = 0;
        !!reviewsPopupBtn && reviewsPopupBtn.classList.add("disabled");
        if (!!reviewsPopupBtnText) {
          reviewsPopupBtnText.textContent = "\u0412\u0430\u0448 \u043E\u0442\u0437\u044B\u0432 \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D \u043D\u0430 \u043C\u043E\u0434\u0435\u0440\u0430\u0446\u0438\u044E";
        }
        if (!!reviewProfileModeration) {
          const { data: data2 } = response;
          const productCadr = document.querySelector(`.js-popup-btn-profile-review[data-id='${data2.PROPERTY_VALUES.PRODUCT}']`);
          const moderationTetle = reviewProfileModeration.querySelector(".profile-section__reviews-title");
          const moderationTextNoReviews = reviewProfileModeration.querySelector(".profile-section__reviews-text");
          const moderationHTML = `<div class="reviews-block__item">
                                            <div class="reviews-block__item-head">
                                                <div class="reviews-block__item-name">${data2.NAME}</div>
                                                <div class="reviews-block__item-date">${data2.ACTIVE_FROM}</div>
                                            </div>
                                            <div class="reviews-block__item-stars">
                                                ${[...Array(data2.PROPERTY_VALUES.MARK)].map((star) => '<svg class="icon " width="20" height="18"><use xlink:href="/local/templates/DoBuy/assets/images/sprite.svg#star"></use></svg>').join("")}
                                                ${[...Array(5 - data2.PROPERTY_VALUES.MARK)].map((star) => '<svg class="icon " width="20" height="18"><use xlink:href="/local/templates/DoBuy/assets/images/sprite.svg#star-not-selected"></use></svg>').join("")}
                                            </div>
                                            <p class="reviews-block__item-title">${data2.PROPERTY_VALUES.PRODUCT_NAME}</p>
                                            <div class="reviews-block__item-body">
                                                <p class="reviews-block__item-text">${data2.PREVIEW_TEXT}</p>
                                                ${data2.PROPERTY_VALUES.PHOTO ? `<div class="reviews-block__item-images">
                                                ${data2.PROPERTY_VALUES.PHOTO.map((img) => `<img class="reviews-block__reviews-gallery-img"
                                                        src="${img}" alt="review image">`).join("")}
                                                </div>` : ``}
                                            </div>
                                        </div>`;
          !!moderationTextNoReviews && moderationTextNoReviews.remove();
          moderationTetle.insertAdjacentHTML("afterend", moderationHTML);
          if (!!productCadr) {
            productCadr.classList.add("disabled");
            const container = productCadr.closest(".cards__inner");
            const swiper2 = productCadr.closest(".swiper").swiper;
            const slideId = +productCadr.closest(".swiper-slide").ariaLabel[0] - 1;
            swiper2.removeSlide(slideId);
            if (swiper2.slides.length < 1) {
              container.insertAdjacentHTML("beforeend", `<p class="profile-section__reviews-text">\u0423 \u0432\u0430\u0441 \u043F\u043E\u043A\u0430 \u043D\u0435\u0442 \u043F\u043E\u0434\u0445\u043E\u0434\u044F\u0449\u0438\u0445 \u0442\u043E\u0432\u0430\u0440\u043E\u0432</p>`);
            }
          }
        }
      }, 1e3);
    }).catch(function(error) {
      reviewError.classList.add("show");
    }).finally(function() {
      setTimeout(() => {
        reviewSuccess.classList.remove("show");
        reviewError.classList.remove("show");
        reviewsSubmitBtn.removeAttribute("disabled", true);
        reviewsSubmitBtn.innerHTML = `\u041E\u0441\u0442\u0430\u0432\u0438\u0442\u044C \u043E\u0442\u0437\u044B\u0432`;
      }, 1e3);
    });
  });
  var popupsBtnReviewProfile = document.querySelectorAll(".js-popup-btn-profile-review");
  popupsBtnReviewProfile.length > 0 && popupsBtnReviewProfile.forEach((btn) => {
    const productId = btn.getAttribute("data-id");
    btn.addEventListener("click", (e2) => {
      const productName = btn.getAttribute("data-name");
      const popupReviewNameElem = document.querySelector("#reviews-new .reviews__text");
      const popupReviewIdInput = document.querySelector('#reviews-new input[name="product_id"]');
      const popupReviewTextInput = document.querySelector("#reviews-new textarea");
      const popupReviewImageInput = document.querySelector('#reviews-new input[type="file"]');
      popupReviewNameElem.textContent = productName;
      popupReviewIdInput.value = Number(productId);
      popupReviewImageInput.value = "";
      popupReviewTextInput.value = "";
      popupReviewRater.setRating(0);
    });
  });

  // src/components/popup/tooltip-popup/tooltip-popup.js
  var openTooltipLink = document.querySelectorAll(".js-tooltip");
  !!openTooltipLink.length && openTooltipLink.forEach((link) => {
    const target = document.querySelector(`#${link.dataset.popupid}`).closest(".tooltip-popup");
    link.addEventListener("mouseover", (evt) => {
      target.classList.add("is-show");
    });
    link.addEventListener("mouseleave", (evt) => {
      target.classList.remove("is-show");
    });
  });

  // node_modules/just-validate/dist/just-validate.es.js
  var __defProp2 = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp2.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __publicField = (obj, key, value2) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
    return value2;
  };
  var EMAIL_REGEXP = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  var NUMBER_REGEXP = /^[0-9]+$/;
  var PASSWORD_REGEXP = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/;
  var STRONG_PASSWORD_REGEXP = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  var isEmpty = (value2) => {
    let newVal = value2;
    if (typeof value2 === "string") {
      newVal = value2.trim();
    }
    return !newVal;
  };
  var isEmail = (value2) => {
    return EMAIL_REGEXP.test(value2);
  };
  var isLengthMoreThanMax = (value2, len) => {
    return value2.length > len;
  };
  var isLengthLessThanMin = (value2, len) => {
    return value2.length < len;
  };
  var isNumber = (value2) => {
    return NUMBER_REGEXP.test(value2);
  };
  var isPassword = (value2) => {
    return PASSWORD_REGEXP.test(value2);
  };
  var isStrongPassword = (value2) => {
    return STRONG_PASSWORD_REGEXP.test(value2);
  };
  var isNumberMoreThanMax = (value2, len) => {
    return value2 > len;
  };
  var isNumberLessThanMin = (value2, len) => {
    return value2 < len;
  };
  var Rules = /* @__PURE__ */ ((Rules2) => {
    Rules2["Required"] = "required";
    Rules2["Email"] = "email";
    Rules2["MinLength"] = "minLength";
    Rules2["MaxLength"] = "maxLength";
    Rules2["Password"] = "password";
    Rules2["Number"] = "number";
    Rules2["MaxNumber"] = "maxNumber";
    Rules2["MinNumber"] = "minNumber";
    Rules2["StrongPassword"] = "strongPassword";
    Rules2["CustomRegexp"] = "customRegexp";
    Rules2["MinFilesCount"] = "minFilesCount";
    Rules2["MaxFilesCount"] = "maxFilesCount";
    Rules2["Files"] = "files";
    return Rules2;
  })(Rules || {});
  var GroupRules = /* @__PURE__ */ ((GroupRules2) => {
    GroupRules2["Required"] = "required";
    return GroupRules2;
  })(GroupRules || {});
  var CustomStyleTagIds = /* @__PURE__ */ ((CustomStyleTagIds2) => {
    CustomStyleTagIds2["Label"] = "label";
    CustomStyleTagIds2["LabelArrow"] = "labelArrow";
    return CustomStyleTagIds2;
  })(CustomStyleTagIds || {});
  var getDefaultFieldMessage = (rule, ruleValue) => {
    switch (rule) {
      case Rules.Required:
        return "The field is required";
      case Rules.Email:
        return "Email has invalid format";
      case Rules.MaxLength:
        return "The field must contain a maximum of :value characters".replace(":value", String(ruleValue));
      case Rules.MinLength:
        return "The field must contain a minimum of :value characters".replace(":value", String(ruleValue));
      case Rules.Password:
        return "Password must contain minimum eight characters, at least one letter and one number";
      case Rules.Number:
        return "Value should be a number";
      case Rules.StrongPassword:
        return "Password should contain minimum eight characters, at least one uppercase letter, one lowercase letter, one number and one special character";
      case Rules.MaxNumber:
        return "Number should be less or equal than :value".replace(":value", String(ruleValue));
      case Rules.MinNumber:
        return "Number should be more or equal than :value".replace(":value", String(ruleValue));
      case Rules.MinFilesCount:
        return "Files count should be more or equal than :value".replace(":value", String(ruleValue));
      case Rules.MaxFilesCount:
        return "Files count should be less or equal than :value".replace(":value", String(ruleValue));
      case Rules.Files:
        return "Uploaded files have one or several invalid properties (extension/size/type etc)";
      default:
        return "Value is incorrect";
    }
  };
  var getDefaultGroupMessage = (rule) => {
    switch (rule) {
      case GroupRules.Required:
        return "The field is required";
      default:
        return "Group is incorrect";
    }
  };
  var isPromise = (val) => !!val && typeof val.then === "function";
  var getNodeParents = (el) => {
    let elem = el;
    const els = [];
    while (elem) {
      els.unshift(elem);
      elem = elem.parentNode;
    }
    return els;
  };
  var getClosestParent = (groups, parents2) => {
    const reversedParents = [...parents2].reverse();
    for (let i = 0, len = reversedParents.length; i < len; ++i) {
      const parent2 = reversedParents[i];
      for (const key in groups) {
        const group = groups[key];
        if (group.groupElem === parent2) {
          return [key, group];
        }
      }
    }
    return null;
  };
  var getClassList = (classList) => {
    if (Array.isArray(classList)) {
      return classList.filter((cls2) => cls2.length > 0);
    }
    if (typeof classList === "string" && classList.trim()) {
      return [...classList.split(" ").filter((cls2) => cls2.length > 0)];
    }
    return [];
  };
  var errorLabelCss = `.just-validate-error-label[data-tooltip=true]{position:fixed;padding:4px 8px;background:#423f3f;color:#fff;white-space:nowrap;z-index:10;border-radius:4px;transform:translateY(-5px)}.just-validate-error-label[data-tooltip=true]:before{content:'';width:0;height:0;border-left:solid 5px transparent;border-right:solid 5px transparent;border-bottom:solid 5px #423f3f;position:absolute;z-index:3;display:block;bottom:-5px;transform:rotate(180deg);left:calc(50% - 5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]{transform:translateX(-5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]:before{right:-7px;bottom:auto;left:auto;top:calc(50% - 2px);transform:rotate(90deg)}.just-validate-error-label[data-tooltip=true][data-direction=right]{transform:translateX(5px)}.just-validate-error-label[data-tooltip=true][data-direction=right]:before{right:auto;bottom:auto;left:-7px;top:calc(50% - 2px);transform:rotate(-90deg)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]{transform:translateY(5px)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]:before{right:auto;bottom:auto;left:calc(50% - 5px);top:-5px;transform:rotate(0)}`;
  var TOOLTIP_ARROW_HEIGHT = 5;
  var defaultGlobalConfig = {
    errorFieldStyle: {
      color: "#b81111",
      border: "1px solid #B81111"
    },
    errorFieldCssClass: "just-validate-error-field",
    successFieldCssClass: "just-validate-success-field",
    errorLabelStyle: {
      color: "#b81111"
    },
    errorLabelCssClass: "just-validate-error-label",
    successLabelCssClass: "just-validate-success-label",
    focusInvalidField: true,
    lockForm: true,
    testingMode: false
  };
  var JustValidate = class {
    constructor(form3, globalConfig, dictLocale) {
      __publicField(this, "form", null);
      __publicField(this, "fields", {});
      __publicField(this, "groupFields", {});
      __publicField(this, "errors", {});
      __publicField(this, "isValid", false);
      __publicField(this, "isSubmitted", false);
      __publicField(this, "globalConfig", defaultGlobalConfig);
      __publicField(this, "errorLabels", {});
      __publicField(this, "successLabels", {});
      __publicField(this, "eventListeners", []);
      __publicField(this, "dictLocale", []);
      __publicField(this, "currentLocale");
      __publicField(this, "customStyleTags", {});
      __publicField(this, "onSuccessCallback");
      __publicField(this, "onFailCallback");
      __publicField(this, "tooltips", []);
      __publicField(this, "lastScrollPosition");
      __publicField(this, "isScrollTick");
      __publicField(this, "refreshAllTooltips", () => {
        this.tooltips.forEach((item) => {
          item.refresh();
        });
      });
      __publicField(this, "handleDocumentScroll", () => {
        this.lastScrollPosition = window.scrollY;
        if (!this.isScrollTick) {
          window.requestAnimationFrame(() => {
            this.refreshAllTooltips();
            this.isScrollTick = false;
          });
          this.isScrollTick = true;
        }
      });
      __publicField(this, "formSubmitHandler", (ev) => {
        ev.preventDefault();
        this.isSubmitted = true;
        this.validateHandler(ev);
      });
      __publicField(this, "handleFieldChange", (target) => {
        let currentFieldName;
        for (const fieldName in this.fields) {
          const field = this.fields[fieldName];
          if (field.elem === target) {
            currentFieldName = fieldName;
            break;
          }
        }
        if (!currentFieldName) {
          return;
        }
        this.validateField(currentFieldName, true);
      });
      __publicField(this, "handleGroupChange", (target) => {
        let currentGroup;
        let currentGroupName;
        for (const groupName in this.groupFields) {
          const group = this.groupFields[groupName];
          if (group.elems.find((elem) => elem === target)) {
            currentGroup = group;
            currentGroupName = groupName;
            break;
          }
        }
        if (!currentGroup || !currentGroupName) {
          return;
        }
        this.validateGroup(currentGroupName, currentGroup);
      });
      __publicField(this, "handlerChange", (ev) => {
        if (!ev.target) {
          return;
        }
        this.handleFieldChange(ev.target);
        this.handleGroupChange(ev.target);
        this.renderErrors();
      });
      this.initialize(form3, globalConfig, dictLocale);
    }
    initialize(form3, globalConfig, dictLocale) {
      this.form = null;
      this.errors = {};
      this.isValid = false;
      this.isSubmitted = false;
      this.globalConfig = defaultGlobalConfig;
      this.errorLabels = {};
      this.successLabels = {};
      this.eventListeners = [];
      this.customStyleTags = {};
      this.tooltips = [];
      if (typeof form3 === "string") {
        const elem = document.querySelector(form3);
        if (!elem) {
          throw Error(`Form with ${form3} selector not found! Please check the form selector`);
        }
        this.setForm(elem);
      } else if (form3 instanceof HTMLFormElement) {
        this.setForm(form3);
      } else {
        throw Error(`Form selector is not valid. Please specify a string selector or a DOM element.`);
      }
      this.globalConfig = __spreadValues(__spreadValues({}, defaultGlobalConfig), globalConfig);
      if (dictLocale) {
        this.dictLocale = dictLocale;
      }
      if (this.isTooltip()) {
        const styleTag = document.createElement("style");
        styleTag.textContent = errorLabelCss;
        this.customStyleTags[CustomStyleTagIds.Label] = document.head.appendChild(styleTag);
        this.addListener("scroll", document, this.handleDocumentScroll);
      }
    }
    getLocalisedString(str) {
      var _a;
      if (!this.currentLocale || !this.dictLocale.length) {
        return str;
      }
      const localisedStr = (_a = this.dictLocale.find((item) => item.key === str)) == null ? void 0 : _a.dict[this.currentLocale];
      return localisedStr || str;
    }
    getFieldErrorMessage(fieldRule, elem) {
      const msg = typeof fieldRule.errorMessage === "function" ? fieldRule.errorMessage(this.getElemValue(elem), this.fields) : fieldRule.errorMessage;
      return this.getLocalisedString(msg) || getDefaultFieldMessage(fieldRule.rule, fieldRule.value);
    }
    getFieldSuccessMessage(successMessage, elem) {
      const msg = typeof successMessage === "function" ? successMessage(this.getElemValue(elem), this.fields) : successMessage;
      return this.getLocalisedString(msg);
    }
    getGroupErrorMessage(groupRule) {
      return this.getLocalisedString(groupRule.errorMessage) || getDefaultGroupMessage(groupRule.rule);
    }
    getGroupSuccessMessage(groupRule) {
      return this.getLocalisedString(groupRule.successMessage);
    }
    setFieldInvalid(field, fieldRule) {
      this.fields[field].isValid = false;
      this.fields[field].errorMessage = this.getFieldErrorMessage(fieldRule, this.fields[field].elem);
    }
    setFieldValid(field, successMessage) {
      this.fields[field].isValid = true;
      if (successMessage !== void 0) {
        this.fields[field].successMessage = this.getFieldSuccessMessage(successMessage, this.fields[field].elem);
      }
    }
    setGroupInvalid(groupName, groupRule) {
      this.groupFields[groupName].isValid = false;
      this.groupFields[groupName].errorMessage = this.getGroupErrorMessage(groupRule);
    }
    setGroupValid(groupName, groupRule) {
      this.groupFields[groupName].isValid = true;
      this.groupFields[groupName].successMessage = this.getGroupSuccessMessage(groupRule);
    }
    getElemValue(elem) {
      switch (elem.type) {
        case "checkbox":
          return elem.checked;
        case "file":
          return elem.files;
        default:
          return elem.value;
      }
    }
    validateGroupRule(groupName, elems, groupRule) {
      switch (groupRule.rule) {
        case GroupRules.Required: {
          if (elems.every((elem) => !elem.checked)) {
            this.setGroupInvalid(groupName, groupRule);
          } else {
            this.setGroupValid(groupName, groupRule);
          }
        }
      }
    }
    validateFieldRule(field, elem, fieldRule, afterInputChanged = false) {
      const ruleValue = fieldRule.value;
      const elemValue = this.getElemValue(elem);
      if (fieldRule.plugin) {
        const result = fieldRule.plugin(elemValue, this.fields);
        if (!result) {
          this.setFieldInvalid(field, fieldRule);
        }
        return;
      }
      switch (fieldRule.rule) {
        case Rules.Required: {
          if (isEmpty(elemValue)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.Email: {
          if (typeof elemValue !== "string") {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (!isEmail(elemValue)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.MaxLength: {
          if (ruleValue === void 0) {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field is not defined. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof ruleValue !== "number") {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] should be a number. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof elemValue !== "string") {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (elemValue === "") {
            break;
          }
          if (isLengthMoreThanMax(elemValue, ruleValue)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.MinLength: {
          if (ruleValue === void 0) {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field is not defined. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof ruleValue !== "number") {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] should be a number. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof elemValue !== "string") {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (elemValue === "") {
            break;
          }
          if (isLengthLessThanMin(elemValue, ruleValue)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.Password: {
          if (typeof elemValue !== "string") {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (elemValue === "") {
            break;
          }
          if (!isPassword(elemValue)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.StrongPassword: {
          if (typeof elemValue !== "string") {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (elemValue === "") {
            break;
          }
          if (!isStrongPassword(elemValue)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.Number: {
          if (typeof elemValue !== "string") {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (elemValue === "") {
            break;
          }
          if (!isNumber(elemValue)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.MaxNumber: {
          if (ruleValue === void 0) {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field is not defined. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof ruleValue !== "number") {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field should be a number. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof elemValue !== "string") {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (elemValue === "") {
            break;
          }
          const num = +elemValue;
          if (Number.isNaN(num) || isNumberMoreThanMax(num, ruleValue)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.MinNumber: {
          if (ruleValue === void 0) {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field is not defined. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof ruleValue !== "number") {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field should be a number. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof elemValue !== "string") {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (elemValue === "") {
            break;
          }
          const num = +elemValue;
          if (Number.isNaN(num) || isNumberLessThanMin(num, ruleValue)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.CustomRegexp: {
          if (ruleValue === void 0) {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field is not defined. This field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            return;
          }
          let regexp;
          try {
            regexp = new RegExp(ruleValue);
          } catch (e2) {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] should be a valid regexp. This field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          const str = String(elemValue);
          if (str !== "" && !regexp.test(str)) {
            this.setFieldInvalid(field, fieldRule);
          }
          break;
        }
        case Rules.MinFilesCount: {
          if (ruleValue === void 0) {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field is not defined. This field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof ruleValue !== "number") {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field should be a number. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length < ruleValue) {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          break;
        }
        case Rules.MaxFilesCount: {
          if (ruleValue === void 0) {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field is not defined. This field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (typeof ruleValue !== "number") {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field should be a number. The field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length > ruleValue) {
            this.setFieldInvalid(field, fieldRule);
            break;
          }
          break;
        }
        case Rules.Files: {
          if (ruleValue === void 0) {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field is not defined. This field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            return;
          }
          if (typeof ruleValue !== "object") {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field should be an object. This field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            return;
          }
          const filesConfig = ruleValue.files;
          if (typeof filesConfig !== "object") {
            console.error(`Value for ${fieldRule.rule} rule for [${field}] field should be an object with files array. This field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            return;
          }
          const isFilePropsInvalid = (file, fileConfig) => {
            const minSizeInvalid = Number.isFinite(fileConfig.minSize) && file.size < fileConfig.minSize;
            const maxSizeInvalid = Number.isFinite(fileConfig.maxSize) && file.size > fileConfig.maxSize;
            const nameInvalid = Array.isArray(fileConfig.names) && !fileConfig.names.includes(file.name);
            const extInvalid = Array.isArray(fileConfig.extensions) && !fileConfig.extensions.includes(file.name.split(".")[file.name.split(".").length - 1]);
            const typeInvalid = Array.isArray(fileConfig.types) && !fileConfig.types.includes(file.type);
            return minSizeInvalid || maxSizeInvalid || nameInvalid || extInvalid || typeInvalid;
          };
          if (typeof elemValue === "object" && elemValue !== null) {
            for (let fileIdx = 0, len = elemValue.length; fileIdx < len; ++fileIdx) {
              const file = elemValue.item(fileIdx);
              if (!file) {
                this.setFieldInvalid(field, fieldRule);
                break;
              }
              const filesInvalid = isFilePropsInvalid(file, filesConfig);
              if (filesInvalid) {
                this.setFieldInvalid(field, fieldRule);
                break;
              }
            }
          }
          break;
        }
        default: {
          if (typeof fieldRule.validator !== "function") {
            console.error(`Validator for custom rule for [${field}] field should be a function. This field will be always invalid.`);
            this.setFieldInvalid(field, fieldRule);
            return;
          }
          const result = fieldRule.validator(elemValue, this.fields);
          if (typeof result !== "boolean" && typeof result !== "function") {
            console.error(`Validator return value for [${field}] field should be boolean or function. It will be cast to boolean.`);
          }
          if (typeof result === "function") {
            if (afterInputChanged) {
              this.fields[field].asyncCheckPending = true;
            } else {
              this.fields[field].asyncCheckPending = false;
              const promise = result();
              if (!isPromise(promise)) {
                console.error(`Validator function for custom rule for [${field}] field should return a Promise. This field will be always invalid.`);
                this.setFieldInvalid(field, fieldRule);
                return;
              }
              return promise.then((resp) => {
                if (!resp) {
                  this.setFieldInvalid(field, fieldRule);
                }
              }).catch(() => {
                this.setFieldInvalid(field, fieldRule);
              });
            }
          }
          if (!result) {
            this.setFieldInvalid(field, fieldRule);
          }
        }
      }
    }
    validateField(fieldName, afterInputChanged = false) {
      var _a;
      const field = this.fields[fieldName];
      field.isValid = true;
      const promises = [];
      [...field.rules].reverse().forEach((rule) => {
        const res = this.validateFieldRule(fieldName, field.elem, rule, afterInputChanged);
        if (isPromise(res)) {
          promises.push(res);
        }
      });
      if (field.isValid) {
        this.setFieldValid(fieldName, (_a = field.config) == null ? void 0 : _a.successMessage);
      }
      return Promise.allSettled(promises);
    }
    revalidateField(field) {
      if (typeof field !== "string") {
        throw Error(`Field selector is not valid. Please specify a string selector.`);
      }
      if (!this.fields[field]) {
        console.error(`Field not found. Check the field selector.`);
        return Promise.reject();
      }
      return new Promise((resolve) => {
        this.validateField(field, true).finally(() => {
          this.clearFieldStyle(field);
          this.clearFieldLabel(field);
          this.renderFieldError(field);
          resolve(!!this.fields[field].isValid);
        });
      });
    }
    validateGroup(groupName, group) {
      const promises = [];
      [...group.rules].reverse().forEach((rule) => {
        const res = this.validateGroupRule(groupName, group.elems, rule);
        if (isPromise(res)) {
          promises.push(res);
        }
      });
      return Promise.allSettled(promises);
    }
    focusInvalidField() {
      for (const fieldName in this.fields) {
        const field = this.fields[fieldName];
        if (!field.isValid) {
          setTimeout(() => field.elem.focus(), 0);
          break;
        }
      }
    }
    afterSubmitValidation(forceRevalidation = false) {
      this.renderErrors(forceRevalidation);
      if (this.globalConfig.focusInvalidField) {
        this.focusInvalidField();
      }
    }
    validate(forceRevalidation = false) {
      return new Promise((resolve) => {
        const promises = [];
        Object.keys(this.fields).forEach((fieldName) => {
          const promise = this.validateField(fieldName);
          if (isPromise(promise)) {
            promises.push(promise);
          }
        });
        Object.keys(this.groupFields).forEach((groupName) => {
          const group = this.groupFields[groupName];
          const promise = this.validateGroup(groupName, group);
          if (isPromise(promise)) {
            promises.push(promise);
          }
        });
        if (promises.length) {
          Promise.allSettled(promises).then(() => {
            this.afterSubmitValidation(forceRevalidation);
            resolve(true);
          });
        } else {
          this.afterSubmitValidation(forceRevalidation);
          resolve(false);
        }
      });
    }
    revalidate() {
      return new Promise((resolve) => {
        this.validateHandler(void 0, true).finally(() => {
          if (this.globalConfig.focusInvalidField) {
            this.focusInvalidField();
          }
          resolve(this.isValid);
        });
      });
    }
    validateHandler(ev, forceRevalidation = false) {
      if (this.globalConfig.lockForm) {
        this.lockForm();
      }
      return this.validate(forceRevalidation).finally(() => {
        var _a, _b;
        if (this.globalConfig.lockForm) {
          this.unlockForm();
        }
        if (this.isValid) {
          (_a = this.onSuccessCallback) == null ? void 0 : _a.call(this, ev);
        } else {
          (_b = this.onFailCallback) == null ? void 0 : _b.call(this, this.fields, this.groupFields);
        }
      });
    }
    setForm(form3) {
      this.form = form3;
      this.form.setAttribute("novalidate", "novalidate");
      this.removeListener("submit", this.form, this.formSubmitHandler);
      this.addListener("submit", this.form, this.formSubmitHandler);
    }
    addListener(type, elem, handler) {
      elem.addEventListener(type, handler);
      this.eventListeners.push({ type, elem, func: handler });
    }
    removeListener(type, elem, handler) {
      elem.removeEventListener(type, handler);
      this.eventListeners = this.eventListeners.filter((item) => item.type !== type || item.elem !== elem);
    }
    addField(field, rules, config) {
      if (typeof field !== "string") {
        throw Error(`Field selector is not valid. Please specify a string selector.`);
      }
      const elem = this.form.querySelector(field);
      if (!elem) {
        throw Error(`Field with ${field} selector not found! Please check the field selector.`);
      }
      if (!Array.isArray(rules) || !rules.length) {
        throw Error(`Rules argument for the field [${field}] should be an array and should contain at least 1 element.`);
      }
      rules.forEach((item) => {
        if (!("rule" in item || "validator" in item || "plugin" in item)) {
          throw Error(`Rules argument for the field [${field}] must contain at least one rule or validator property.`);
        }
        if (!item.validator && !item.plugin && (!item.rule || !Object.values(Rules).includes(item.rule))) {
          throw Error(`Rule should be one of these types: ${Object.values(Rules).join(", ")}. Provided value: ${item.rule}`);
        }
      });
      this.fields[field] = {
        elem,
        rules,
        isValid: void 0,
        config
      };
      this.setListeners(elem);
      if (this.isSubmitted) {
        this.validate();
      }
      return this;
    }
    removeField(field) {
      if (typeof field !== "string") {
        throw Error(`Field selector is not valid. Please specify a string selector.`);
      }
      if (!this.fields[field]) {
        console.error(`Field not found. Check the field selector.`);
        return this;
      }
      const type = this.getListenerType(this.fields[field].elem.type);
      this.removeListener(type, this.fields[field].elem, this.handlerChange);
      this.clearErrors();
      delete this.fields[field];
      return this;
    }
    removeGroup(group) {
      if (typeof group !== "string") {
        throw Error(`Group selector is not valid. Please specify a string selector.`);
      }
      if (!this.groupFields[group]) {
        console.error(`Group not found. Check the group selector.`);
        return this;
      }
      this.groupFields[group].elems.forEach((elem) => {
        const type = this.getListenerType(elem.type);
        this.removeListener(type, elem, this.handlerChange);
      });
      this.clearErrors();
      delete this.groupFields[group];
      return this;
    }
    addRequiredGroup(groupField, errorMessage, config, successMessage) {
      if (typeof groupField !== "string") {
        throw Error(`Group selector is not valid. Please specify a string selector.`);
      }
      const elem = this.form.querySelector(groupField);
      if (!elem) {
        throw Error(`Group with ${groupField} selector not found! Please check the group selector.`);
      }
      const inputs2 = elem.querySelectorAll("input");
      const childrenInputs = Array.from(inputs2).filter((input) => {
        const parent2 = getClosestParent(this.groupFields, getNodeParents(input));
        if (!parent2) {
          return true;
        }
        return parent2[1].elems.find((elem2) => elem2 !== input);
      });
      this.groupFields[groupField] = {
        rules: [
          {
            rule: GroupRules.Required,
            errorMessage,
            successMessage
          }
        ],
        groupElem: elem,
        elems: childrenInputs,
        isDirty: false,
        isValid: void 0,
        config
      };
      inputs2.forEach((input) => {
        this.setListeners(input);
      });
      return this;
    }
    getListenerType(type) {
      switch (type) {
        case "checkbox":
        case "select-one":
        case "file":
        case "radio": {
          return "change";
        }
        default: {
          return "input";
        }
      }
    }
    setListeners(elem) {
      const type = this.getListenerType(elem.type);
      this.removeListener(type, elem, this.handlerChange);
      this.addListener(type, elem, this.handlerChange);
    }
    clearFieldLabel(fieldName) {
      var _a, _b;
      (_a = this.errorLabels[fieldName]) == null ? void 0 : _a.remove();
      (_b = this.successLabels[fieldName]) == null ? void 0 : _b.remove();
    }
    clearFieldStyle(fieldName) {
      var _a, _b, _c, _d;
      const field = this.fields[fieldName];
      const errorStyle = ((_a = field.config) == null ? void 0 : _a.errorFieldStyle) || this.globalConfig.errorFieldStyle;
      Object.keys(errorStyle).forEach((key) => {
        field.elem.style[key] = "";
      });
      const successStyle = ((_b = field.config) == null ? void 0 : _b.successFieldStyle) || this.globalConfig.successFieldStyle || {};
      Object.keys(successStyle).forEach((key) => {
        field.elem.style[key] = "";
      });
      field.elem.classList.remove(...getClassList(((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass), ...getClassList(((_d = field.config) == null ? void 0 : _d.successFieldCssClass) || this.globalConfig.successFieldCssClass));
    }
    clearErrors() {
      var _a, _b;
      Object.keys(this.errorLabels).forEach((key) => this.errorLabels[key].remove());
      Object.keys(this.successLabels).forEach((key) => this.successLabels[key].remove());
      for (const fieldName in this.fields) {
        this.clearFieldStyle(fieldName);
      }
      for (const groupName in this.groupFields) {
        const group = this.groupFields[groupName];
        const errorStyle = ((_a = group.config) == null ? void 0 : _a.errorFieldStyle) || this.globalConfig.errorFieldStyle;
        Object.keys(errorStyle).forEach((key) => {
          group.elems.forEach((elem) => {
            var _a2;
            elem.style[key] = "";
            elem.classList.remove(...getClassList(((_a2 = group.config) == null ? void 0 : _a2.errorFieldCssClass) || this.globalConfig.errorFieldCssClass));
          });
        });
        const successStyle = ((_b = group.config) == null ? void 0 : _b.successFieldStyle) || this.globalConfig.successFieldStyle || {};
        Object.keys(successStyle).forEach((key) => {
          group.elems.forEach((elem) => {
            var _a2;
            elem.style[key] = "";
            elem.classList.remove(...getClassList(((_a2 = group.config) == null ? void 0 : _a2.successFieldCssClass) || this.globalConfig.successFieldCssClass));
          });
        });
      }
      this.tooltips = [];
    }
    isTooltip() {
      return !!this.globalConfig.tooltip;
    }
    lockForm() {
      const elems = this.form.querySelectorAll("input, textarea, button, select");
      for (let i = 0, len = elems.length; i < len; ++i) {
        elems[i].setAttribute("data-just-validate-fallback-disabled", elems[i].disabled ? "true" : "false");
        elems[i].setAttribute("disabled", "disabled");
        elems[i].style.pointerEvents = "none";
        elems[i].style.webkitFilter = "grayscale(100%)";
        elems[i].style.filter = "grayscale(100%)";
      }
    }
    unlockForm() {
      const elems = this.form.querySelectorAll("input, textarea, button, select");
      for (let i = 0, len = elems.length; i < len; ++i) {
        if (elems[i].getAttribute("data-just-validate-fallback-disabled") !== "true") {
          elems[i].removeAttribute("disabled");
        }
        elems[i].style.pointerEvents = "";
        elems[i].style.webkitFilter = "";
        elems[i].style.filter = "";
      }
    }
    renderTooltip(elem, errorLabel, position) {
      var _a;
      const { top, left, width, height } = elem.getBoundingClientRect();
      const errorLabelRect = errorLabel.getBoundingClientRect();
      const pos = position || ((_a = this.globalConfig.tooltip) == null ? void 0 : _a.position);
      switch (pos) {
        case "left": {
          errorLabel.style.top = `${top + height / 2 - errorLabelRect.height / 2}px`;
          errorLabel.style.left = `${left - errorLabelRect.width - TOOLTIP_ARROW_HEIGHT}px`;
          break;
        }
        case "top": {
          errorLabel.style.top = `${top - errorLabelRect.height - TOOLTIP_ARROW_HEIGHT}px`;
          errorLabel.style.left = `${left + width / 2 - errorLabelRect.width / 2}px`;
          break;
        }
        case "right": {
          errorLabel.style.top = `${top + height / 2 - errorLabelRect.height / 2}px`;
          errorLabel.style.left = `${left + width + TOOLTIP_ARROW_HEIGHT}px`;
          break;
        }
        case "bottom": {
          errorLabel.style.top = `${top + height + TOOLTIP_ARROW_HEIGHT}px`;
          errorLabel.style.left = `${left + width / 2 - errorLabelRect.width / 2}px`;
          break;
        }
      }
      errorLabel.dataset.direction = pos;
      const refresh = () => {
        this.renderTooltip(elem, errorLabel, position);
      };
      return {
        refresh
      };
    }
    createErrorLabelElem(name, errorMessage, config) {
      const errorLabel = document.createElement("div");
      errorLabel.innerHTML = errorMessage;
      const customErrorLabelStyle = this.isTooltip() ? config == null ? void 0 : config.errorLabelStyle : (config == null ? void 0 : config.errorLabelStyle) || this.globalConfig.errorLabelStyle;
      Object.assign(errorLabel.style, customErrorLabelStyle);
      errorLabel.classList.add(...getClassList((config == null ? void 0 : config.errorLabelCssClass) || this.globalConfig.errorLabelCssClass), "just-validate-error-label");
      if (this.isTooltip()) {
        errorLabel.dataset.tooltip = "true";
      }
      if (this.globalConfig.testingMode) {
        errorLabel.dataset.testId = `error-label-${name}`;
      }
      this.errorLabels[name] = errorLabel;
      return errorLabel;
    }
    createSuccessLabelElem(name, successMessage, config) {
      if (successMessage === void 0) {
        return null;
      }
      const successLabel = document.createElement("div");
      successLabel.innerHTML = successMessage;
      const customSuccessLabelStyle = (config == null ? void 0 : config.successLabelStyle) || this.globalConfig.successLabelStyle;
      Object.assign(successLabel.style, customSuccessLabelStyle);
      successLabel.classList.add(...getClassList((config == null ? void 0 : config.successLabelCssClass) || this.globalConfig.successLabelCssClass), "just-validate-success-label");
      if (this.globalConfig.testingMode) {
        successLabel.dataset.testId = `success-label-${name}`;
      }
      this.successLabels[name] = successLabel;
      return successLabel;
    }
    renderErrorsContainer(label, errorsContainer) {
      const container = errorsContainer || this.globalConfig.errorsContainer;
      if (typeof container === "string") {
        const elem = this.form.querySelector(container);
        if (elem) {
          elem.appendChild(label);
          return true;
        } else {
          console.error(`Error container with ${container} selector not found. Errors will be rendered as usual`);
        }
      }
      if (container instanceof Element) {
        container.appendChild(label);
        return true;
      }
      if (container !== void 0) {
        console.error(`Error container not found. It should be a string or existing Element. Errors will be rendered as usual`);
      }
      return false;
    }
    renderGroupLabel(elem, label, errorsContainer, isSuccess) {
      if (!isSuccess) {
        const renderedInErrorsContainer = this.renderErrorsContainer(label, errorsContainer);
        if (renderedInErrorsContainer) {
          return;
        }
      }
      elem.appendChild(label);
    }
    renderFieldLabel(elem, label, errorsContainer, isSuccess) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!isSuccess) {
        const renderedInErrorsContainer = this.renderErrorsContainer(label, errorsContainer);
        if (renderedInErrorsContainer) {
          return;
        }
      }
      if (elem.type === "checkbox" || elem.type === "radio") {
        const labelElem = document.querySelector(`label[for="${elem.getAttribute("id")}"]`);
        if (((_b = (_a = elem.parentElement) == null ? void 0 : _a.tagName) == null ? void 0 : _b.toLowerCase()) === "label") {
          (_d = (_c = elem.parentElement) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.appendChild(label);
        } else if (labelElem) {
          (_e = labelElem.parentElement) == null ? void 0 : _e.appendChild(label);
        } else {
          (_f = elem.parentElement) == null ? void 0 : _f.appendChild(label);
        }
      } else {
        (_g = elem.parentElement) == null ? void 0 : _g.appendChild(label);
      }
    }
    showLabels(fields, isError) {
      Object.keys(fields).forEach((fieldName, i) => {
        const error = fields[fieldName];
        const field = this.fields[fieldName];
        field.isValid = !isError;
        this.clearFieldStyle(fieldName);
        this.clearFieldLabel(fieldName);
        this.renderFieldError(fieldName, error);
        if (i === 0 && this.globalConfig.focusInvalidField) {
          setTimeout(() => field.elem.focus(), 0);
        }
      });
    }
    showErrors(fields) {
      if (typeof fields !== "object") {
        throw Error("[showErrors]: Errors should be an object with key: value format");
      }
      this.showLabels(fields, true);
    }
    showSuccessLabels(fields) {
      if (typeof fields !== "object") {
        throw Error("[showSuccessLabels]: Labels should be an object with key: value format");
      }
      this.showLabels(fields, false);
    }
    renderFieldError(fieldName, message) {
      var _a, _b, _c, _d, _e, _f;
      const field = this.fields[fieldName];
      if (field.isValid) {
        if (!field.asyncCheckPending) {
          const successLabel = this.createSuccessLabelElem(fieldName, message !== void 0 ? message : field.successMessage, field.config);
          if (successLabel) {
            this.renderFieldLabel(field.elem, successLabel, (_a = field.config) == null ? void 0 : _a.errorsContainer, true);
          }
          field.elem.classList.add(...getClassList(((_b = field.config) == null ? void 0 : _b.successFieldCssClass) || this.globalConfig.successFieldCssClass));
        }
        return;
      }
      this.isValid = false;
      field.elem.classList.add(...getClassList(((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass));
      const errorLabel = this.createErrorLabelElem(fieldName, message !== void 0 ? message : field.errorMessage, field.config);
      this.renderFieldLabel(field.elem, errorLabel, (_d = field.config) == null ? void 0 : _d.errorsContainer);
      if (this.isTooltip()) {
        this.tooltips.push(this.renderTooltip(field.elem, errorLabel, (_f = (_e = field.config) == null ? void 0 : _e.tooltip) == null ? void 0 : _f.position));
      }
    }
    renderErrors(forceRevalidation = false) {
      var _a, _b, _c, _d;
      if (!this.isSubmitted && !forceRevalidation) {
        return;
      }
      this.clearErrors();
      this.isValid = true;
      for (const groupName in this.groupFields) {
        const group = this.groupFields[groupName];
        if (group.isValid) {
          group.elems.forEach((elem) => {
            var _a2, _b2;
            Object.assign(elem.style, ((_a2 = group.config) == null ? void 0 : _a2.successFieldStyle) || this.globalConfig.successFieldStyle);
            elem.classList.add(...getClassList(((_b2 = group.config) == null ? void 0 : _b2.successFieldCssClass) || this.globalConfig.successFieldCssClass));
          });
          const successLabel = this.createSuccessLabelElem(groupName, group.successMessage, group.config);
          if (successLabel) {
            this.renderGroupLabel(group.groupElem, successLabel, (_a = group.config) == null ? void 0 : _a.errorsContainer, true);
          }
          continue;
        }
        this.isValid = false;
        group.elems.forEach((elem) => {
          var _a2, _b2;
          Object.assign(elem.style, ((_a2 = group.config) == null ? void 0 : _a2.errorFieldStyle) || this.globalConfig.errorFieldStyle);
          elem.classList.add(...getClassList(((_b2 = group.config) == null ? void 0 : _b2.errorFieldCssClass) || this.globalConfig.errorFieldCssClass));
        });
        const errorLabel = this.createErrorLabelElem(groupName, group.errorMessage, group.config);
        this.renderGroupLabel(group.groupElem, errorLabel, (_b = group.config) == null ? void 0 : _b.errorsContainer);
        if (this.isTooltip()) {
          this.tooltips.push(this.renderTooltip(group.groupElem, errorLabel, (_d = (_c = group.config) == null ? void 0 : _c.tooltip) == null ? void 0 : _d.position));
        }
      }
      for (const fieldName in this.fields) {
        this.renderFieldError(fieldName);
      }
    }
    destroy() {
      this.eventListeners.forEach((event2) => {
        this.removeListener(event2.type, event2.elem, event2.func);
      });
      Object.keys(this.customStyleTags).forEach((key) => {
        this.customStyleTags[key].remove();
      });
      this.clearErrors();
      if (this.globalConfig.lockForm) {
        this.unlockForm();
      }
    }
    refresh() {
      this.destroy();
      if (!this.form) {
        console.error("Cannot initialize the library! Form is not defined");
      } else {
        this.initialize(this.form, this.globalConfig);
        Object.keys(this.fields).forEach((key) => {
          this.addField(key, [...this.fields[key].rules], this.fields[key].config);
        });
      }
    }
    setCurrentLocale(locale2) {
      if (typeof locale2 !== "string" && locale2 !== void 0) {
        console.error("Current locale should be a string");
        return;
      }
      this.currentLocale = locale2;
      if (this.isSubmitted) {
        this.validate();
      }
    }
    onSuccess(callback) {
      this.onSuccessCallback = callback;
      return this;
    }
    onFail(callback) {
      this.onFailCallback = callback;
      return this;
    }
  };

  // node_modules/just-validate-plugin-date/dist/just-validate-plugin-date.es.js
  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  var formatDistance = function(token, count, options) {
    var result;
    var tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options !== null && options !== void 0 && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };
  var formatDistance$1 = formatDistance;
  function buildFormatLongFn(args) {
    return function() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var width = options.width ? String(options.width) : args.defaultWidth;
      var format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }
  var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  var formatLong$1 = formatLong;
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  var formatRelative = function(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  };
  var formatRelative$1 = formatRelative;
  function buildLocalizeFn(args) {
    return function(dirtyIndex, dirtyOptions) {
      var options = dirtyOptions || {};
      var context = options.context ? String(options.context) : "standalone";
      var valuesArray;
      if (context === "formatting" && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;
        var _width = options.width ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }
      var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index2];
    };
  }
  var eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  };
  var dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  };
  var dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  var ordinalNumber = function(dirtyNumber, _options) {
    var number = Number(dirtyNumber);
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  var localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: function(quarter) {
        return quarter - 1;
      }
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  var localize$1 = localize;
  function buildMatchFn(args) {
    return function(string) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var width = options.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      }) : findKey(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      });
      var value2;
      value2 = args.valueCallback ? args.valueCallback(key) : key;
      value2 = options.valueCallback ? options.valueCallback(value2) : value2;
      var rest = string.slice(matchedString.length);
      return {
        value: value2,
        rest
      };
    };
  }
  function findKey(object, predicate) {
    for (var key in object) {
      if (object.hasOwnProperty(key) && predicate(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate) {
    for (var key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return void 0;
  }
  function buildMatchPatternFn(args) {
    return function(string) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var matchResult = string.match(args.matchPattern);
      if (!matchResult)
        return null;
      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);
      if (!parseResult)
        return null;
      var value2 = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value2 = options.valueCallback ? options.valueCallback(value2) : value2;
      var rest = string.slice(matchedString.length);
      return {
        value: value2,
        rest
      };
    };
  }
  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function(value2) {
        return parseInt(value2, 10);
      }
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: function(index2) {
        return index2 + 1;
      }
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  var match$1 = match;
  var locale = {
    code: "en-US",
    formatDistance: formatDistance$1,
    formatLong: formatLong$1,
    formatRelative: formatRelative$1,
    localize: localize$1,
    match: match$1,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  var defaultLocale = locale;
  function toInteger(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }
    var number = Number(dirtyNumber);
    if (isNaN(number)) {
      return number;
    }
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  }
  function requiredArgs(required, args) {
    if (args.length < required) {
      throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
    }
  }
  function toDate(argument) {
    requiredArgs(1, arguments);
    var argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
      return new Date(argument.getTime());
    } else if (typeof argument === "number" || argStr === "[object Number]") {
      return new Date(argument);
    } else {
      if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
        console.warn(new Error().stack);
      }
      return new Date(NaN);
    }
  }
  function addMilliseconds(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var timestamp = toDate(dirtyDate).getTime();
    var amount = toInteger(dirtyAmount);
    return new Date(timestamp + amount);
  }
  function subMilliseconds(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var amount = toInteger(dirtyAmount);
    return addMilliseconds(dirtyDate, -amount);
  }
  function assign(target, dirtyObject) {
    if (target == null) {
      throw new TypeError("assign requires that input parameter not be null or undefined");
    }
    dirtyObject = dirtyObject || {};
    for (var property in dirtyObject) {
      if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
        target[property] = dirtyObject[property];
      }
    }
    return target;
  }
  function dateLongFormatter(pattern, formatLong2) {
    switch (pattern) {
      case "P":
        return formatLong2.date({
          width: "short"
        });
      case "PP":
        return formatLong2.date({
          width: "medium"
        });
      case "PPP":
        return formatLong2.date({
          width: "long"
        });
      case "PPPP":
      default:
        return formatLong2.date({
          width: "full"
        });
    }
  }
  function timeLongFormatter(pattern, formatLong2) {
    switch (pattern) {
      case "p":
        return formatLong2.time({
          width: "short"
        });
      case "pp":
        return formatLong2.time({
          width: "medium"
        });
      case "ppp":
        return formatLong2.time({
          width: "long"
        });
      case "pppp":
      default:
        return formatLong2.time({
          width: "full"
        });
    }
  }
  function dateTimeLongFormatter(pattern, formatLong2) {
    var matchResult = pattern.match(/(P+)(p+)?/) || [];
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong2);
    }
    var dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({
          width: "short"
        });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({
          width: "full"
        });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
  }
  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  var longFormatters$1 = longFormatters;
  function getTimezoneOffsetInMilliseconds(date) {
    var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    utcDate.setUTCFullYear(date.getFullYear());
    return date.getTime() - utcDate.getTime();
  }
  var protectedDayOfYearTokens = ["D", "DD"];
  var protectedWeekYearTokens = ["YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return protectedDayOfYearTokens.indexOf(token) !== -1;
  }
  function isProtectedWeekYearToken(token) {
    return protectedWeekYearTokens.indexOf(token) !== -1;
  }
  function throwProtectedError(token, format, input) {
    if (token === "YYYY") {
      throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
    } else if (token === "YY") {
      throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
    } else if (token === "D") {
      throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
    } else if (token === "DD") {
      throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
    }
  }
  function startOfUTCWeek(dirtyDate, dirtyOptions) {
    requiredArgs(1, arguments);
    var options = dirtyOptions || {};
    var locale2 = options.locale;
    var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
  function getUTCWeekYear(dirtyDate, dirtyOptions) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    var year = date.getUTCFullYear();
    var options = dirtyOptions || {};
    var locale2 = options.locale;
    var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
    requiredArgs(2, arguments);
    var options = dirtyOptions || {};
    var locale2 = options.locale;
    var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date = toDate(dirtyDate);
    var day = toInteger(dirtyDay);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }
  function setUTCISODay(dirtyDate, dirtyDay) {
    requiredArgs(2, arguments);
    var day = toInteger(dirtyDay);
    if (day % 7 === 0) {
      day = day - 7;
    }
    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }
  function startOfUTCISOWeek(dirtyDate) {
    requiredArgs(1, arguments);
    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
  function getUTCISOWeekYear(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    var year = date.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  function startOfUTCISOWeekYear(dirtyDate) {
    requiredArgs(1, arguments);
    var year = getUTCISOWeekYear(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCISOWeek(fourthOfJanuary);
    return date;
  }
  var MILLISECONDS_IN_WEEK$1 = 6048e5;
  function getUTCISOWeek(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
  }
  function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    requiredArgs(2, arguments);
    var date = toDate(dirtyDate);
    var isoWeek = toInteger(dirtyISOWeek);
    var diff = getUTCISOWeek(date) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  }
  function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
    requiredArgs(1, arguments);
    var options = dirtyOptions || {};
    var locale2 = options.locale;
    var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
    var year = getUTCWeekYear(dirtyDate, dirtyOptions);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCWeek(firstWeek, dirtyOptions);
    return date;
  }
  var MILLISECONDS_IN_WEEK = 6048e5;
  function getUTCWeek(dirtyDate, options) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }
  function setUTCWeek(dirtyDate, dirtyWeek, options) {
    requiredArgs(2, arguments);
    var date = toDate(dirtyDate);
    var week = toInteger(dirtyWeek);
    var diff = getUTCWeek(date, options) - week;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  }
  var MILLISECONDS_IN_HOUR = 36e5;
  var MILLISECONDS_IN_MINUTE = 6e4;
  var MILLISECONDS_IN_SECOND = 1e3;
  var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
  };
  var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };
  function parseNumericPattern(pattern, string, valueCallback) {
    var matchResult = string.match(pattern);
    if (!matchResult) {
      return null;
    }
    var value2 = parseInt(matchResult[0], 10);
    return {
      value: valueCallback ? valueCallback(value2) : value2,
      rest: string.slice(matchResult[0].length)
    };
  }
  function parseTimezonePattern(pattern, string) {
    var matchResult = string.match(pattern);
    if (!matchResult) {
      return null;
    }
    if (matchResult[0] === "Z") {
      return {
        value: 0,
        rest: string.slice(1)
      };
    }
    var sign = matchResult[1] === "+" ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * MILLISECONDS_IN_SECOND),
      rest: string.slice(matchResult[0].length)
    };
  }
  function parseAnyDigitsSigned(string, valueCallback) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
  }
  function parseNDigits(n, string, valueCallback) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);
      default:
        return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), string, valueCallback);
    }
  }
  function parseNDigitsSigned(n, string, valueCallback) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);
      default:
        return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), string, valueCallback);
    }
  }
  function dayPeriodEnumToHours(enumValue) {
    switch (enumValue) {
      case "morning":
        return 4;
      case "evening":
        return 17;
      case "pm":
      case "noon":
      case "afternoon":
        return 12;
      case "am":
      case "midnight":
      case "night":
      default:
        return 0;
    }
  }
  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0;
    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;
    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      var rangeEnd = absCurrentYear + 50;
      var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
      var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
  }
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  var parsers = {
    G: {
      priority: 140,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return match2.era(string, {
              width: "abbreviated"
            }) || match2.era(string, {
              width: "narrow"
            });
          case "GGGGG":
            return match2.era(string, {
              width: "narrow"
            });
          case "GGGG":
          default:
            return match2.era(string, {
              width: "wide"
            }) || match2.era(string, {
              width: "abbreviated"
            }) || match2.era(string, {
              width: "narrow"
            });
        }
      },
      set: function(date, flags, value2, _options) {
        flags.era = value2;
        date.setUTCFullYear(value2, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["R", "u", "t", "T"]
    },
    y: {
      priority: 130,
      parse: function(string, token, match2, _options) {
        var valueCallback = function(year) {
          return {
            year,
            isTwoDigitYear: token === "yy"
          };
        };
        switch (token) {
          case "y":
            return parseNDigits(4, string, valueCallback);
          case "yo":
            return match2.ordinalNumber(string, {
              unit: "year",
              valueCallback
            });
          default:
            return parseNDigits(token.length, string, valueCallback);
        }
      },
      validate: function(_date, value2, _options) {
        return value2.isTwoDigitYear || value2.year > 0;
      },
      set: function(date, flags, value2, _options) {
        var currentYear = date.getUTCFullYear();
        if (value2.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value2.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
        var year = !("era" in flags) || flags.era === 1 ? value2.year : 1 - value2.year;
        date.setUTCFullYear(year, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]
    },
    Y: {
      priority: 130,
      parse: function(string, token, match2, _options) {
        var valueCallback = function(year) {
          return {
            year,
            isTwoDigitYear: token === "YY"
          };
        };
        switch (token) {
          case "Y":
            return parseNDigits(4, string, valueCallback);
          case "Yo":
            return match2.ordinalNumber(string, {
              unit: "year",
              valueCallback
            });
          default:
            return parseNDigits(token.length, string, valueCallback);
        }
      },
      validate: function(_date, value2, _options) {
        return value2.isTwoDigitYear || value2.year > 0;
      },
      set: function(date, flags, value2, options) {
        var currentYear = getUTCWeekYear(date, options);
        if (value2.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value2.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date, options);
        }
        var year = !("era" in flags) || flags.era === 1 ? value2.year : 1 - value2.year;
        date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      },
      incompatibleTokens: ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]
    },
    R: {
      priority: 130,
      parse: function(string, token, _match, _options) {
        if (token === "R") {
          return parseNDigitsSigned(4, string);
        }
        return parseNDigitsSigned(token.length, string);
      },
      set: function(_date, _flags, value2, _options) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value2, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return startOfUTCISOWeek(firstWeekOfYear);
      },
      incompatibleTokens: ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
    },
    u: {
      priority: 130,
      parse: function(string, token, _match, _options) {
        if (token === "u") {
          return parseNDigitsSigned(4, string);
        }
        return parseNDigitsSigned(token.length, string);
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCFullYear(value2, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]
    },
    Q: {
      priority: 120,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "Q":
          case "QQ":
            return parseNDigits(token.length, string);
          case "Qo":
            return match2.ordinalNumber(string, {
              unit: "quarter"
            });
          case "QQQ":
            return match2.quarter(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.quarter(string, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQQ":
            return match2.quarter(string, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return match2.quarter(string, {
              width: "wide",
              context: "formatting"
            }) || match2.quarter(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.quarter(string, {
              width: "narrow",
              context: "formatting"
            });
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 1 && value2 <= 4;
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCMonth((value2 - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
    },
    q: {
      priority: 120,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "q":
          case "qq":
            return parseNDigits(token.length, string);
          case "qo":
            return match2.ordinalNumber(string, {
              unit: "quarter"
            });
          case "qqq":
            return match2.quarter(string, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.quarter(string, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqqq":
            return match2.quarter(string, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return match2.quarter(string, {
              width: "wide",
              context: "standalone"
            }) || match2.quarter(string, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.quarter(string, {
              width: "narrow",
              context: "standalone"
            });
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 1 && value2 <= 4;
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCMonth((value2 - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
    },
    M: {
      priority: 110,
      parse: function(string, token, match2, _options) {
        var valueCallback = function(value2) {
          return value2 - 1;
        };
        switch (token) {
          case "M":
            return parseNumericPattern(numericPatterns.month, string, valueCallback);
          case "MM":
            return parseNDigits(2, string, valueCallback);
          case "Mo":
            return match2.ordinalNumber(string, {
              unit: "month",
              valueCallback
            });
          case "MMM":
            return match2.month(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.month(string, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMMM":
            return match2.month(string, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return match2.month(string, {
              width: "wide",
              context: "formatting"
            }) || match2.month(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.month(string, {
              width: "narrow",
              context: "formatting"
            });
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 0 && value2 <= 11;
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCMonth(value2, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]
    },
    L: {
      priority: 110,
      parse: function(string, token, match2, _options) {
        var valueCallback = function(value2) {
          return value2 - 1;
        };
        switch (token) {
          case "L":
            return parseNumericPattern(numericPatterns.month, string, valueCallback);
          case "LL":
            return parseNDigits(2, string, valueCallback);
          case "Lo":
            return match2.ordinalNumber(string, {
              unit: "month",
              valueCallback
            });
          case "LLL":
            return match2.month(string, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.month(string, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLLL":
            return match2.month(string, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return match2.month(string, {
              width: "wide",
              context: "standalone"
            }) || match2.month(string, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.month(string, {
              width: "narrow",
              context: "standalone"
            });
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 0 && value2 <= 11;
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCMonth(value2, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]
    },
    w: {
      priority: 100,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "w":
            return parseNumericPattern(numericPatterns.week, string);
          case "wo":
            return match2.ordinalNumber(string, {
              unit: "week"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 1 && value2 <= 53;
      },
      set: function(date, _flags, value2, options) {
        return startOfUTCWeek(setUTCWeek(date, value2, options), options);
      },
      incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]
    },
    I: {
      priority: 100,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "I":
            return parseNumericPattern(numericPatterns.week, string);
          case "Io":
            return match2.ordinalNumber(string, {
              unit: "week"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 1 && value2 <= 53;
      },
      set: function(date, _flags, value2, options) {
        return startOfUTCISOWeek(setUTCISOWeek(date, value2, options), options);
      },
      incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
    },
    d: {
      priority: 90,
      subPriority: 1,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "d":
            return parseNumericPattern(numericPatterns.date, string);
          case "do":
            return match2.ordinalNumber(string, {
              unit: "date"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(date, value2, _options) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);
        var month = date.getUTCMonth();
        if (isLeapYear) {
          return value2 >= 1 && value2 <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value2 >= 1 && value2 <= DAYS_IN_MONTH[month];
        }
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCDate(value2);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]
    },
    D: {
      priority: 90,
      subPriority: 1,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "D":
          case "DD":
            return parseNumericPattern(numericPatterns.dayOfYear, string);
          case "Do":
            return match2.ordinalNumber(string, {
              unit: "date"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(date, value2, _options) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);
        if (isLeapYear) {
          return value2 >= 1 && value2 <= 366;
        } else {
          return value2 >= 1 && value2 <= 365;
        }
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCMonth(0, value2);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]
    },
    E: {
      priority: 90,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return match2.day(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(string, {
              width: "short",
              context: "formatting"
            }) || match2.day(string, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEE":
            return match2.day(string, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return match2.day(string, {
              width: "short",
              context: "formatting"
            }) || match2.day(string, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEE":
          default:
            return match2.day(string, {
              width: "wide",
              context: "formatting"
            }) || match2.day(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(string, {
              width: "short",
              context: "formatting"
            }) || match2.day(string, {
              width: "narrow",
              context: "formatting"
            });
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 0 && value2 <= 6;
      },
      set: function(date, _flags, value2, options) {
        date = setUTCDay(date, value2, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["D", "i", "e", "c", "t", "T"]
    },
    e: {
      priority: 90,
      parse: function(string, token, match2, options) {
        var valueCallback = function(value2) {
          var wholeWeekDays = Math.floor((value2 - 1) / 7) * 7;
          return (value2 + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "e":
          case "ee":
            return parseNDigits(token.length, string, valueCallback);
          case "eo":
            return match2.ordinalNumber(string, {
              unit: "day",
              valueCallback
            });
          case "eee":
            return match2.day(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(string, {
              width: "short",
              context: "formatting"
            }) || match2.day(string, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeee":
            return match2.day(string, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return match2.day(string, {
              width: "short",
              context: "formatting"
            }) || match2.day(string, {
              width: "narrow",
              context: "formatting"
            });
          case "eeee":
          default:
            return match2.day(string, {
              width: "wide",
              context: "formatting"
            }) || match2.day(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(string, {
              width: "short",
              context: "formatting"
            }) || match2.day(string, {
              width: "narrow",
              context: "formatting"
            });
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 0 && value2 <= 6;
      },
      set: function(date, _flags, value2, options) {
        date = setUTCDay(date, value2, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]
    },
    c: {
      priority: 90,
      parse: function(string, token, match2, options) {
        var valueCallback = function(value2) {
          var wholeWeekDays = Math.floor((value2 - 1) / 7) * 7;
          return (value2 + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "c":
          case "cc":
            return parseNDigits(token.length, string, valueCallback);
          case "co":
            return match2.ordinalNumber(string, {
              unit: "day",
              valueCallback
            });
          case "ccc":
            return match2.day(string, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.day(string, {
              width: "short",
              context: "standalone"
            }) || match2.day(string, {
              width: "narrow",
              context: "standalone"
            });
          case "ccccc":
            return match2.day(string, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return match2.day(string, {
              width: "short",
              context: "standalone"
            }) || match2.day(string, {
              width: "narrow",
              context: "standalone"
            });
          case "cccc":
          default:
            return match2.day(string, {
              width: "wide",
              context: "standalone"
            }) || match2.day(string, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.day(string, {
              width: "short",
              context: "standalone"
            }) || match2.day(string, {
              width: "narrow",
              context: "standalone"
            });
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 0 && value2 <= 6;
      },
      set: function(date, _flags, value2, options) {
        date = setUTCDay(date, value2, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]
    },
    i: {
      priority: 90,
      parse: function(string, token, match2, _options) {
        var valueCallback = function(value2) {
          if (value2 === 0) {
            return 7;
          }
          return value2;
        };
        switch (token) {
          case "i":
          case "ii":
            return parseNDigits(token.length, string);
          case "io":
            return match2.ordinalNumber(string, {
              unit: "day"
            });
          case "iii":
            return match2.day(string, {
              width: "abbreviated",
              context: "formatting",
              valueCallback
            }) || match2.day(string, {
              width: "short",
              context: "formatting",
              valueCallback
            }) || match2.day(string, {
              width: "narrow",
              context: "formatting",
              valueCallback
            });
          case "iiiii":
            return match2.day(string, {
              width: "narrow",
              context: "formatting",
              valueCallback
            });
          case "iiiiii":
            return match2.day(string, {
              width: "short",
              context: "formatting",
              valueCallback
            }) || match2.day(string, {
              width: "narrow",
              context: "formatting",
              valueCallback
            });
          case "iiii":
          default:
            return match2.day(string, {
              width: "wide",
              context: "formatting",
              valueCallback
            }) || match2.day(string, {
              width: "abbreviated",
              context: "formatting",
              valueCallback
            }) || match2.day(string, {
              width: "short",
              context: "formatting",
              valueCallback
            }) || match2.day(string, {
              width: "narrow",
              context: "formatting",
              valueCallback
            });
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 1 && value2 <= 7;
      },
      set: function(date, _flags, value2, options) {
        date = setUTCISODay(date, value2, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]
    },
    a: {
      priority: 80,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "a":
          case "aa":
          case "aaa":
            return match2.dayPeriod(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(string, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaaa":
            return match2.dayPeriod(string, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return match2.dayPeriod(string, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(string, {
              width: "narrow",
              context: "formatting"
            });
        }
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value2), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["b", "B", "H", "k", "t", "T"]
    },
    b: {
      priority: 80,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "b":
          case "bb":
          case "bbb":
            return match2.dayPeriod(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(string, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbbb":
            return match2.dayPeriod(string, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return match2.dayPeriod(string, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(string, {
              width: "narrow",
              context: "formatting"
            });
        }
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value2), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["a", "B", "H", "k", "t", "T"]
    },
    B: {
      priority: 80,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return match2.dayPeriod(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(string, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBBB":
            return match2.dayPeriod(string, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return match2.dayPeriod(string, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(string, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(string, {
              width: "narrow",
              context: "formatting"
            });
        }
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCHours(dayPeriodEnumToHours(value2), 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["a", "b", "t", "T"]
    },
    h: {
      priority: 70,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "h":
            return parseNumericPattern(numericPatterns.hour12h, string);
          case "ho":
            return match2.ordinalNumber(string, {
              unit: "hour"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 1 && value2 <= 12;
      },
      set: function(date, _flags, value2, _options) {
        var isPM = date.getUTCHours() >= 12;
        if (isPM && value2 < 12) {
          date.setUTCHours(value2 + 12, 0, 0, 0);
        } else if (!isPM && value2 === 12) {
          date.setUTCHours(0, 0, 0, 0);
        } else {
          date.setUTCHours(value2, 0, 0, 0);
        }
        return date;
      },
      incompatibleTokens: ["H", "K", "k", "t", "T"]
    },
    H: {
      priority: 70,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "H":
            return parseNumericPattern(numericPatterns.hour23h, string);
          case "Ho":
            return match2.ordinalNumber(string, {
              unit: "hour"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 0 && value2 <= 23;
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCHours(value2, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["a", "b", "h", "K", "k", "t", "T"]
    },
    K: {
      priority: 70,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "K":
            return parseNumericPattern(numericPatterns.hour11h, string);
          case "Ko":
            return match2.ordinalNumber(string, {
              unit: "hour"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 0 && value2 <= 11;
      },
      set: function(date, _flags, value2, _options) {
        var isPM = date.getUTCHours() >= 12;
        if (isPM && value2 < 12) {
          date.setUTCHours(value2 + 12, 0, 0, 0);
        } else {
          date.setUTCHours(value2, 0, 0, 0);
        }
        return date;
      },
      incompatibleTokens: ["h", "H", "k", "t", "T"]
    },
    k: {
      priority: 70,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "k":
            return parseNumericPattern(numericPatterns.hour24h, string);
          case "ko":
            return match2.ordinalNumber(string, {
              unit: "hour"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 1 && value2 <= 24;
      },
      set: function(date, _flags, value2, _options) {
        var hours = value2 <= 24 ? value2 % 24 : value2;
        date.setUTCHours(hours, 0, 0, 0);
        return date;
      },
      incompatibleTokens: ["a", "b", "h", "H", "K", "t", "T"]
    },
    m: {
      priority: 60,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "m":
            return parseNumericPattern(numericPatterns.minute, string);
          case "mo":
            return match2.ordinalNumber(string, {
              unit: "minute"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 0 && value2 <= 59;
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCMinutes(value2, 0, 0);
        return date;
      },
      incompatibleTokens: ["t", "T"]
    },
    s: {
      priority: 50,
      parse: function(string, token, match2, _options) {
        switch (token) {
          case "s":
            return parseNumericPattern(numericPatterns.second, string);
          case "so":
            return match2.ordinalNumber(string, {
              unit: "second"
            });
          default:
            return parseNDigits(token.length, string);
        }
      },
      validate: function(_date, value2, _options) {
        return value2 >= 0 && value2 <= 59;
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCSeconds(value2, 0);
        return date;
      },
      incompatibleTokens: ["t", "T"]
    },
    S: {
      priority: 30,
      parse: function(string, token, _match, _options) {
        var valueCallback = function(value2) {
          return Math.floor(value2 * Math.pow(10, -token.length + 3));
        };
        return parseNDigits(token.length, string, valueCallback);
      },
      set: function(date, _flags, value2, _options) {
        date.setUTCMilliseconds(value2);
        return date;
      },
      incompatibleTokens: ["t", "T"]
    },
    X: {
      priority: 10,
      parse: function(string, token, _match, _options) {
        switch (token) {
          case "X":
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
          case "XX":
            return parseTimezonePattern(timezonePatterns.basic, string);
          case "XXXX":
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
          case "XXXXX":
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
          case "XXX":
          default:
            return parseTimezonePattern(timezonePatterns.extended, string);
        }
      },
      set: function(date, flags, value2, _options) {
        if (flags.timestampIsSet) {
          return date;
        }
        return new Date(date.getTime() - value2);
      },
      incompatibleTokens: ["t", "T", "x"]
    },
    x: {
      priority: 10,
      parse: function(string, token, _match, _options) {
        switch (token) {
          case "x":
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
          case "xx":
            return parseTimezonePattern(timezonePatterns.basic, string);
          case "xxxx":
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
          case "xxxxx":
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
          case "xxx":
          default:
            return parseTimezonePattern(timezonePatterns.extended, string);
        }
      },
      set: function(date, flags, value2, _options) {
        if (flags.timestampIsSet) {
          return date;
        }
        return new Date(date.getTime() - value2);
      },
      incompatibleTokens: ["t", "T", "X"]
    },
    t: {
      priority: 40,
      parse: function(string, _token, _match, _options) {
        return parseAnyDigitsSigned(string);
      },
      set: function(_date, _flags, value2, _options) {
        return [new Date(value2 * 1e3), {
          timestampIsSet: true
        }];
      },
      incompatibleTokens: "*"
    },
    T: {
      priority: 20,
      parse: function(string, _token, _match, _options) {
        return parseAnyDigitsSigned(string);
      },
      set: function(_date, _flags, value2, _options) {
        return [new Date(value2), {
          timestampIsSet: true
        }];
      },
      incompatibleTokens: "*"
    }
  };
  var parsers$1 = parsers;
  var TIMEZONE_UNIT_PRIORITY = 10;
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var notWhitespaceRegExp = /\S/;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
    requiredArgs(3, arguments);
    var dateString = String(dirtyDateString);
    var formatString = String(dirtyFormatString);
    var options = dirtyOptions || {};
    var locale2 = options.locale || defaultLocale;
    if (!locale2.match) {
      throw new RangeError("locale must contain match property");
    }
    var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
    var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
    var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
    var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
    var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    if (formatString === "") {
      if (dateString === "") {
        return toDate(dirtyReferenceDate);
      } else {
        return new Date(NaN);
      }
    }
    var subFnOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale: locale2
    };
    var setters = [{
      priority: TIMEZONE_UNIT_PRIORITY,
      subPriority: -1,
      set: dateToSystemTimezone,
      index: 0
    }];
    var i;
    var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
      var firstCharacter2 = substring[0];
      if (firstCharacter2 === "p" || firstCharacter2 === "P") {
        var longFormatter = longFormatters$1[firstCharacter2];
        return longFormatter(substring, locale2.formatLong, subFnOptions);
      }
      return substring;
    }).join("").match(formattingTokensRegExp);
    var usedTokens = [];
    for (i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers$1[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = void 0;
          for (var _i = 0; _i < usedTokens.length; _i++) {
            var usedToken = usedTokens[_i].token;
            if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
              incompatibleToken = usedTokens[_i];
              break;
            }
          }
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.parse(dateString, token, locale2.match, subFnOptions);
        if (!parseResult) {
          return new Date(NaN);
        }
        setters.push({
          priority: parser.priority,
          subPriority: parser.subPriority || 0,
          set: parser.set,
          validate: parser.validate,
          value: parseResult.value,
          index: setters.length
        });
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return new Date(NaN);
        }
      }
    }
    if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
      return new Date(NaN);
    }
    var uniquePrioritySetters = setters.map(function(setter2) {
      return setter2.priority;
    }).sort(function(a, b) {
      return b - a;
    }).filter(function(priority, index2, array) {
      return array.indexOf(priority) === index2;
    }).map(function(priority) {
      return setters.filter(function(setter2) {
        return setter2.priority === priority;
      }).sort(function(a, b) {
        return b.subPriority - a.subPriority;
      });
    }).map(function(setterArray) {
      return setterArray[0];
    });
    var date = toDate(dirtyReferenceDate);
    if (isNaN(date)) {
      return new Date(NaN);
    }
    var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
    var flags = {};
    for (i = 0; i < uniquePrioritySetters.length; i++) {
      var setter = uniquePrioritySetters[i];
      if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
        return new Date(NaN);
      }
      var result = setter.set(utcDate, flags, setter.value, subFnOptions);
      if (result[0]) {
        utcDate = result[0];
        assign(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
    return utcDate;
  }
  function dateToSystemTimezone(date, flags) {
    if (flags.timestampIsSet) {
      return date;
    }
    var convertedDate = new Date(0);
    convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
    return convertedDate;
  }
  function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
  }
  function isDate(value2) {
    requiredArgs(1, arguments);
    return value2 instanceof Date || typeof value2 === "object" && Object.prototype.toString.call(value2) === "[object Date]";
  }
  function isValid(dirtyDate) {
    requiredArgs(1, arguments);
    if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
      return false;
    }
    var date = toDate(dirtyDate);
    return !isNaN(Number(date));
  }
  function isMatch(dateString, formatString, options) {
    requiredArgs(2, arguments);
    return isValid(parse(dateString, formatString, new Date(), options));
  }
  function isAfter(dirtyDate, dirtyDateToCompare) {
    requiredArgs(2, arguments);
    var date = toDate(dirtyDate);
    var dateToCompare = toDate(dirtyDateToCompare);
    return date.getTime() > dateToCompare.getTime();
  }
  function isEqual(dirtyLeftDate, dirtyRightDate) {
    requiredArgs(2, arguments);
    var dateLeft = toDate(dirtyLeftDate);
    var dateRight = toDate(dirtyRightDate);
    return dateLeft.getTime() === dateRight.getTime();
  }
  var getParsedDate = (value2, format) => {
    return format ? parse(value2, format, new Date()) : new Date(value2);
  };
  var getComparedDate = (sourceDate, configValue, format) => {
    let comparedDate;
    if (isDate(configValue)) {
      comparedDate = configValue;
    } else if (typeof configValue === "string") {
      comparedDate = getParsedDate(configValue, format);
    }
    if (!isValid(comparedDate)) {
      return null;
    }
    if (!isValid(sourceDate)) {
      return null;
    }
    return comparedDate;
  };
  var checkIsEqual = (configValue, sourceDate, format) => {
    const comparedDate = getComparedDate(sourceDate, configValue, format);
    if (comparedDate === null) {
      return false;
    }
    return isEqual(comparedDate, sourceDate);
  };
  var checkIsBefore = (configValue, sourceDate, format) => {
    const comparedDate = getComparedDate(sourceDate, configValue, format);
    if (comparedDate === null) {
      return false;
    }
    return isAfter(comparedDate, sourceDate);
  };
  var checkIsBeforeOrEqual = (configValue, sourceDate, format) => {
    const comparedDate = getComparedDate(sourceDate, configValue, format);
    if (comparedDate === null) {
      return false;
    }
    return isEqual(comparedDate, sourceDate) || isAfter(comparedDate, sourceDate);
  };
  var checkIsAfter = (configValue, sourceDate, format) => {
    const comparedDate = getComparedDate(sourceDate, configValue, format);
    if (comparedDate === null) {
      return false;
    }
    return isAfter(sourceDate, comparedDate);
  };
  var checkIsAfterOrEqual = (configValue, sourceDate, format) => {
    const comparedDate = getComparedDate(sourceDate, configValue, format);
    if (comparedDate === null) {
      return false;
    }
    return isEqual(comparedDate, sourceDate) || isAfter(sourceDate, comparedDate);
  };
  var pluginDate = (func) => (value2, fields) => {
    const config = func(fields);
    const valid = {
      format: true,
      isAfter: true,
      isBefore: true,
      required: true,
      isBeforeOrEqual: true,
      isAfterOrEqual: true,
      isEqual: true
    };
    if (typeof value2 !== "string") {
      console.error("Value should be a string! The result will be always invalid");
      return false;
    }
    if (!config.required && value2 === "") {
      return true;
    }
    if (config.format !== void 0) {
      if (typeof config.format !== "string") {
        console.error("Format field should be a string! The result will be always invalid");
        valid.format = false;
      } else {
        valid.format = isMatch(value2, config.format);
      }
    }
    const sourceDate = getParsedDate(value2, config.format);
    if (config.isBefore !== void 0) {
      valid.isBefore = checkIsBefore(config.isBefore, sourceDate, config.format);
    }
    if (config.isBeforeOrEqual !== void 0) {
      valid.isBeforeOrEqual = checkIsBeforeOrEqual(config.isBeforeOrEqual, sourceDate, config.format);
    }
    if (config.isAfter !== void 0) {
      valid.isAfter = checkIsAfter(config.isAfter, sourceDate, config.format);
    }
    if (config.isAfterOrEqual !== void 0) {
      valid.isAfter = checkIsAfterOrEqual(config.isAfterOrEqual, sourceDate, config.format);
    }
    if (config.isEqual !== void 0) {
      valid.isEqual = checkIsEqual(config.isEqual, sourceDate, config.format);
    }
    return Object.values(valid).every((item) => item);
  };

  // src/components/validation/validation.js
  var import_inputmask2 = __toModule(require_inputmask());
  var import_intl_tel_input = __toModule(require_intl_tel_input());
  var import_axios5 = __toModule(require_axios2());
  var import_debounce3 = __toModule(require_debounce());
  var forms = document.querySelectorAll(".js-form");
  var noRegUserForm = document.querySelector(".profile-no-reg__form");
  var validateForms = [];
  forms.length && forms.forEach((el) => {
    let validateForm2 = new JustValidate(el, {
      focusInvalidField: !noRegUserForm
    });
    const requiredInputs = el.querySelectorAll(".required-input");
    !!el.querySelector("#name") && validateForm2.addField("#name", [
      {
        rule: "minLength",
        value: 2,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 2 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      {
        rule: "customRegexp",
        value: "^(([ ]*)?(([\u0410-\u042F\u0401])[\u0430-\u044F\u0451]*)([ ]|[-]*)?(([\u0410-\u042F\u0401])[\u0430-\u044F\u0451]*)?([ ]*)?)$",
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E\u0435 \u0438\u043C\u044F"
      },
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430 \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      }
    ]);
    !!el.querySelector("#surname") && validateForm2.addField("#surname", [
      {
        rule: "minLength",
        value: 2,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 2 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      {
        rule: "customRegexp",
        value: "^(([ ]*)?(([\u0410-\u042F\u0401])[\u0430-\u044F\u0451]*)([-]*)?(([\u0410-\u042F\u0401])[\u0430-\u044F\u0451]*)?([ ]*)?)$",
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0443\u044E \u0444\u0430\u043C\u0438\u043B\u0438\u044E"
      },
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430 \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      }
    ]);
    !!el.querySelector("#patronymic") && validateForm2.addField("#patronymic", [
      {
        rule: "customRegexp",
        value: "^(([ ]*)?(([\u0410-\u042F\u0401])[\u0430-\u044F\u0451]*)([ ]|[-]*)?(([\u0410-\u042F\u0401])[\u0430-\u044F\u0451]*)?([ ]*)?)$",
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E\u0435 \u043E\u0442\u0447\u0435\u0441\u0442\u0432\u043E"
      }
    ]);
    !!el.querySelector("#fio") && validateForm2.addField("#fio", [
      {
        rule: "minLength",
        value: 2,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 2 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      {
        rule: "customRegexp",
        value: /^([-]+-?[-]+)( [-]+-?[-]+)+(([-]+-?[-]+)?){1,2}\s*$/i,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E\u0435 \u0424\u0418\u041E"
      },
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      }
    ]);
    requiredInputs.length && requiredInputs.forEach((inputField) => {
      const inputFieldDataRequired = inputField.getAttribute("data-required");
      validateForm2.addField(`[data-required="${inputFieldDataRequired}"]`, [
        {
          rule: "required",
          errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
        }
      ]);
    });
    !!el.querySelector("#series") && validateForm2.addField("#series", [
      {
        rule: "customRegexp",
        value: /^\d{4}$/,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043D\u043E\u043C\u0435\u0440"
      },
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      }
    ]);
    !!el.querySelector("#paspnum") && validateForm2.addField("#paspnum", [
      {
        rule: "customRegexp",
        value: /^\d{6}$/,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043D\u043E\u043C\u0435\u0440"
      },
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      }
    ]);
    !!el.querySelector("#division") && validateForm2.addField("#division", [
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      }
    ]);
    !!el.querySelector("#country") && validateForm2.addField("#country", [
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      }
    ]);
    !!el.querySelector("#check") && validateForm2.addField("#check", [
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      }
    ]);
    !!el.querySelector("#email") && validateForm2.addField("#email", [
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      },
      {
        rule: "customRegexp",
        value: /^[a-z0-9@._-]+$/i,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 email"
      },
      {
        rule: "email",
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 email"
      }
    ]);
    !!el.querySelector("#phone") && validateForm2.addField("#phone", [
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      },
      {
        validator: (value2, fields) => {
          return fields["#phone"].elem.inputmask.unmaskedvalue().length === 10;
        },
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043D\u043E\u043C\u0435\u0440 \u0442\u0435\u043B\u0435\u0444\u043E\u043D\u0430"
      }
    ]);
    !!el.querySelector(".js-address-area-no-reg") && validateForm2.addField(".js-address-area-no-reg", [
      {
        validator: (value2, fields) => {
          let validArea = fields[".js-address-area-no-reg"].elem.getAttribute("data-valid");
          return validArea === "valid";
        },
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u0430\u0434\u0440\u0435\u0441"
      }
    ]);
    !!el.querySelector("#date") && validateForm2.addField("#date", [
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      },
      {
        plugin: pluginDate(() => ({
          format: "dd.MM.yyyy",
          isBefore: getTodayDate(),
          isAfter: "01.01.1970"
        })),
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0443\u044E \u0434\u0430\u0442\u0443"
      }
    ]);
    !!el.querySelector("#codePasp") && validateForm2.addField("#codePasp", [
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      },
      {
        rule: "customRegexp",
        value: /^\d{3}-\d{3}$/,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435"
      }
    ]);
    !!el.querySelector("#radio_group") && validateForm2.addRequiredGroup("#radio_group", "\u041F\u043E\u043B\u0435 \u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u043E");
    !!el.querySelector("#special-product-details") && validateForm2.addField("#special-product-details", [
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      },
      {
        rule: "customRegexp",
        value: /^[a-zA-Z--0-9, ]+$/,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435"
      },
      {
        rule: "maxLength",
        value: 255,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435"
      }
    ]);
    !!el.querySelector("#special-product-price") && validateForm2.addField("#special-product-price", [
      {
        rule: "required",
        errorMessage: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043F\u043E\u043B\u0435"
      },
      {
        rule: "customRegexp",
        value: /\d/,
        errorMessage: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435"
      },
      {
        rule: "minNumber",
        value: 1,
        errorMessage: "\u0426\u0435\u043D\u0430 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\u0448\u0435 1"
      }
    ]);
    const btnSubmit2 = el.querySelector(".js-btn-submit");
    function changeNoEditFieldsOnSubmitForm(fieldNoEdit, formField) {
      const noEditFormElement = el.querySelector(fieldNoEdit);
      const formElement = el.querySelector(formField);
      noEditFormElement.textContent = formElement.value;
    }
    !!btnSubmit2 && btnSubmit2.addEventListener("click", () => {
      const url2 = el.getAttribute("action");
      el.querySelectorAll("input").forEach((item) => item.value = item.value.trim());
      const data = new FormData(el);
      const popupSuccess2 = document.querySelector("#success-popup");
      const popupSuccessText = !!popupSuccess2 && popupSuccess2.querySelector(".success-popup__title");
      const submitBtnOrder2 = document.querySelector(".js-purchase-submit-btn");
      const fileInput = el.querySelector(".js-edit-avatar");
      const btnEsitProfile2 = el.querySelector(".edit");
      const profileAvatarText = el.querySelector(".profile-section__avatar-text");
      const profileFio = el.querySelector("#fio");
      const profileFioLetters = !!profileFio && profileFio.value.split(" ").map((el2) => el2[0]).join("");
      const fileInputAvatar = !!fileInput && fileInput.files;
      const noRegUserForm2 = document.querySelector(".profile-no-reg__form");
      const skipValidation = btnSubmit2.getAttribute("data-skip-validation");
      if (skipValidation === "true") {
        e.preventDefault();
        e.stopPropagation();
      }
      Array.from(fileInputAvatar).forEach((file, i) => {
        data.append("avatar", file);
      });
      if (validateForm2.isValid || skipValidation === "true") {
        if (!!noRegUserForm2) {
          let areaAddressNoRegForm = document.querySelector(".js-address-area-no-reg");
          !!areaAddressNoRegForm && areaAddressNoRegForm.hasAttribute("data-index") && data.append("index", areaAddressNoRegForm.getAttribute("data-index"));
          data.append("no-reg", true);
        }
        import_axios5.default.post(url2, data, {
          headers: {
            "Content-Type": "multipart/form-data"
          }
        }).then((response) => {
          if (!!submitBtnOrder2) {
            if (skipValidation !== "true") {
              changeNoEditFieldsOnSubmitForm(".profile-section__form-head-noEdit-name", "input#name");
              changeNoEditFieldsOnSubmitForm(".profile-section__form-head-noEdit-name", "input#surname");
              changeNoEditFieldsOnSubmitForm(".profile-section__form-head-noEdit-name", "input#patronymic");
              changeNoEditFieldsOnSubmitForm(".profile-section__form-head-noEdit-tel", "input#phone");
              changeNoEditFieldsOnSubmitForm(".profile-section__form-head-noEdit-mail", "input#email");
              if (!!profileAvatarText) {
                profileAvatarText.textContent = profileFioLetters;
              }
            }
            submitBtnOrder2.removeAttribute("disabled");
            const formBodyInner = el.querySelector(".profile-section__form-body-inner");
            el.classList.add("noEdit");
            !!btnEsitProfile2 && btnEsitProfile2.classList.remove("isHide");
            formBodyInner.classList.add("isHiden");
          }
          popupSuccessText.textContent = "\u0414\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B";
          showPopup(popupSuccess2, null, null, null, !!noRegUserForm2 && "/");
        }).catch(function(error) {
          popupSuccessText.textContent = "\u041E\u0448\u0438\u0431\u043A\u0430! \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.";
          showPopup(popupSuccess2);
        }).finally(function() {
          setTimeout(() => {
            !!popupSuccess2 && popupSuccess2.click();
          }, 3e3);
        });
      }
    });
    const submitBtnOrder = document.querySelector(".js-purchase-submit-btn");
    const formurl = el.getAttribute("action");
    const successPopup = document.querySelector("#success-popup");
    const successPopupText = !!successPopup && successPopup.querySelector(".success-popup__title");
    const successPopupIcon = !!successPopup && successPopup.querySelector(".success-icon");
    const submitButton = el.querySelector(".js-button-submit");
    const popupForm = el.closest(".js-popup");
    el.addEventListener("change", (e2) => {
      if (!validateForm2.isValid) {
        !!submitBtnOrder && submitBtnOrder.setAttribute("disabled", true);
      }
      const requiresFields = el.querySelectorAll("[required]");
      const fullFields = [...requiresFields].filter((el2) => el2.type === "checkbox" ? !el2.checked : !el2.value.trim());
      !document.querySelector(".profile-payment__form") && !btnSubmit2 && !fullFields.length && !!submitButton && submitButton.removeAttribute("disabled");
    });
    !document.querySelector(".profile-payment__form") && !!submitButton && validateForm2.onSuccess((event2) => {
      const formData = new FormData(el);
      import_axios5.default.post(formurl, formData).then((response) => {
        if (!!successPopupText) {
          successPopupText.textContent = "\u041E\u0442\u0432\u0435\u0442 \u043D\u0430 \u0432\u0430\u0448\u0435 \u043E\u0431\u0440\u0430\u0449\u0435\u043D\u0438\u0435 \u043C\u044B \u043F\u0440\u0438\u0448\u043B\u0435\u043C \u043D\u0430 \u0443\u043A\u0430\u0437\u0430\u043D\u043D\u0443\u044E \u043F\u043E\u0447\u0442\u0443";
          !!successPopupIcon && successPopupIcon.classList.remove("hide");
        }
        !!popupForm && popupForm.click();
        !!successPopup && showPopup(successPopup);
      }).catch(function(error) {
        if (!!successPopupText) {
          successPopupText.textContent = "\u041E\u0448\u0438\u0431\u043A\u0430! \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.";
          !!successPopupIcon && successPopupIcon.classList.add("hide");
        }
        !!popupForm && popupForm.click();
        !!successPopup && showPopup(successPopup);
      }).finally(function() {
        setTimeout(() => {
          !!successPopup && successPopup.click();
        }, 3e3);
      });
    });
    validateForms.push(validateForm2);
  });
  var phoneInputs2 = document.querySelectorAll(".js-input-phone");
  var numberInput = document.querySelectorAll(".js-number");
  var textInput = document.querySelectorAll(".js-text");
  var dateInputs = document.querySelectorAll(".js-dateInputs");
  var codeInputs = document.querySelectorAll(".js-codeInputs");
  var inputTel = document.querySelectorAll(".js-iti-phone");
  var areaFields = document.querySelectorAll(".js-area-field");
  areaFields.length && areaFields.forEach((field) => {
    const fieldTextClass = field.getAttribute("data-symb");
    const textField = document.querySelector(`.${fieldTextClass}`);
    let areaSymbText = textField.textContent;
    field.addEventListener("input", (e2) => {
      if (!field.value.trim()) {
        textField.textContent = areaSymbText;
      } else {
        textField.textContent = areaSymbText - field.value.length;
      }
    });
  });
  inputTel.forEach((tel, i) => {
    let intInputTel = (0, import_intl_tel_input.default)(tel, {
      initialCountry: "ru",
      utilsScript: "https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.13/js/utils.min.js"
    });
    tel.addEventListener("focus", function(e2) {
      let inputTelSubscriptionPl = tel.getAttribute("placeholder");
      let inputTelSubscriptionPlMask = inputTelSubscriptionPl.replace(/[()]/gi, "").replace(/[^-\s]/gi, "9");
      const phoneCode = document.querySelector(".iti__selected-flag .iti__flag.iti__ru");
      if (!!phoneCode) {
        let inputTelSubscriptionPlMaskRu = inputTelSubscriptionPlMask.replace(inputTelSubscriptionPlMask.charAt(0), "+7");
        (0, import_inputmask2.default)({
          "mask": `${inputTelSubscriptionPlMaskRu}`,
          showMaskOnHover: false
        }).mask(tel);
      } else {
        (0, import_inputmask2.default)({
          "mask": `${inputTelSubscriptionPlMask}`,
          showMaskOnHover: false
        }).mask(tel);
      }
    });
  });
  for (const input of phoneInputs2) {
    (0, import_inputmask2.default)({
      "mask": "+7 999 999-99-99",
      showMaskOnHover: false
    }).mask(input);
  }
  for (const input of dateInputs) {
    (0, import_inputmask2.default)({
      alias: "datetime",
      inputFormat: "dd.mm.yyyy",
      placeholder: "X",
      showMaskOnHover: false
    }).mask(input);
  }
  for (const input of codeInputs) {
    (0, import_inputmask2.default)({
      "mask": "999-999",
      placeholder: "X",
      showMaskOnHover: false
    }).mask(input);
  }
  numberInput.length && numberInput.forEach((input) => {
    input.addEventListener("input", () => {
      let value2 = input.value;
      value2 = value2.replace(/[^0-9]/gi, "");
      input.value = value2;
    });
  });
  textInput.length && textInput.forEach((input) => {
    input.addEventListener("input", () => {
      let value2 = input.value;
      input.getAttribute("id") !== "name" || input.getAttribute("id") !== "patronymic" && input.getAttribute("id") !== "surname" && (value2 = value2.replace(".", ""));
      input.value = value2;
    });
  });
  !!noRegUserForm && noRegUserForm.querySelectorAll("input").forEach((item) => {
    item.addEventListener("input", (itemInput) => {
      if (validateForms[0]) {
        validateForms[0].validate(true);
      }
    });
  });

  // src/components/popup/callback/callback.js
  (function() {
    const callbackPopupBtns = document.querySelectorAll(".js-callback-popup-btn");
    const callbackPopup = document.querySelector(".js-popup#callback");
    const callbackPopupOrder = !!callbackPopup && callbackPopup.querySelectorAll(".js-callback-id");
    !!callbackPopupBtns.length && callbackPopupBtns.forEach((button) => {
      const orderId = button.getAttribute("data-order");
      button.addEventListener("click", (event2) => {
        validateForms[0].refresh();
        document.querySelector(".js-button-submit").setAttribute("disabled", "");
        if (callbackPopupOrder.length > 0) {
          callbackPopupOrder.forEach((element) => {
            element.tagName.toLowerCase() === "input" ? element.value = orderId : element.innerText = orderId;
          });
        }
      });
    });
  })();

  // src/components/cookie/cookie.js
  document.addEventListener("DOMContentLoaded", function(event2) {
    const cookieItem = document.querySelector(".js-cookie");
    const cookieBtn = document.querySelector(".js-cookie-button");
    const cookieClose = document.querySelector(".js-cookie-close");
    if (!getCookie("hideCookie")) {
      !!cookieItem && cookieItem.classList.add("is-show");
    }
    const hideCookieItem = () => {
      !!cookieItem && cookieItem.classList.remove("is-show");
      setCookie("hideCookie", "true");
    };
    !!cookieBtn && cookieBtn.addEventListener("click", hideCookieItem);
    !!cookieClose && cookieClose.addEventListener("click", hideCookieItem);
  });

  // src/components/promo-block/promo-block.js
  var import_axios6 = __toModule(require_axios2());
  var promoBlock = document.querySelector(".promo-block");
  var promoBtn = promoBlock && promoBlock.querySelector(".promo-block__btn-submit");
  var promoForm = promoBlock && promoBlock.querySelector(".promo-block__form");
  var promoInput = promoBlock && promoBlock.querySelector(".promo-block__input");
  var promoCheckBox = promoBlock && promoBlock.querySelector(".promo-block__checkbox");
  var promoInputWrap = promoBlock && promoBlock.querySelector(".promo-block__input-wrap");
  var popupSuccess = document.querySelector("#success-popup-with-icon");
  var popupError = document.querySelector("#error-popup-with-icon");
  promoCheckBox && promoCheckBox.addEventListener("change", () => {
    promoBtn.disabled = !promoCheckBox.checked;
  });
  promoBlock ? promoForm.addEventListener("submit", (evt) => {
    evt.preventDefault();
    const form3 = new FormData(promoForm);
    if (!emailReg.test(promoInput.value)) {
      promoInputWrap.classList.add("invalid");
    } else {
      const recaptchaElement = document.querySelector(".recaptcha-token");
      const recaptchaElementKey = !!recaptchaElement && recaptchaElement.value;
      grecaptcha.execute(recaptchaElementKey, { action: "submit" }).then(function(token) {
        if (token) {
          form3.append("email", promoInput.value.trim());
          form3.append("recaptcha", token);
          promoInputWrap.classList.remove("invalid");
          promoBtn.disabled = true;
          const popupTitle = !!popupSuccess && popupSuccess.querySelector(".success-popup__title");
          const popupTitleErr = !!popupError && popupError.querySelector(".success-popup__title");
          import_axios6.default.post(`/local/ajax/mailing.php`, form3).then(function(response) {
            popupTitle.textContent = "\u0424\u043E\u0440\u043C\u0430 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0430";
            showPopup(popupSuccess);
            promoBtn.removeAttribute("disabled");
          }).catch(function(error) {
            const errReason = error.response.data.success.reason;
            if (errReason === "subscribed") {
              popupTitleErr.textContent = "\u0412\u044B \u0443\u0436\u0435 \u043F\u043E\u0434\u043F\u0438\u0441\u0430\u043D\u044B \u043D\u0430 \u0440\u0430\u0441\u0441\u044B\u043B\u043A\u0443";
            } else {
              popupTitleErr.textContent = "\u041E\u0448\u0438\u0431\u043A\u0430 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0438";
            }
            showPopup(popupError);
            promoBtn.removeAttribute("disabled");
          });
        }
      });
    }
  }) : null;

  // src/components/catalog-popup-mobile/catalog-popup-mobile.js
  var catalogPopupLinks = document.querySelectorAll(".catalog-popup-mobile__menu-link");
  var detailMenuLink = document.querySelectorAll(".js-detail-menu-link");
  var detailMenuLinkContainer = document.querySelectorAll(".js-detail-menu-link-container");
  var detailPopupMenuBody = document.querySelector(".js-mobile-detail-body");
  var detailPopupMenuTitle = document.querySelector(".js-popup-menu-title");
  function toggleVisibleCategory(event2) {
    const childList = event2.target.closest(".catalog-popup__menu-item").querySelector(".catalog-popup-mobile__menu-item-childs");
    !!childList && childList.classList.toggle("active");
    event2.target.closest(".catalog-popup__menu-item").querySelector(".catalog-popup-mobile__menu-link-right").classList.toggle("active");
  }
  !!catalogPopupLinks.length && catalogPopupLinks.forEach((element) => element.addEventListener("click", toggleVisibleCategory));
  !!detailMenuLink && detailMenuLink.forEach((el, i) => {
    el.addEventListener("click", (e2) => {
      const linkTitle = el.previousElementSibling.textContent;
      const dataId = el.getAttribute("data-id");
      detailPopupMenuTitle.innerText = linkTitle;
      detailPopupMenuBody.innerHTML = `<div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`;
      fetch(`/local/ajax/get_category_list.php?id=${dataId}&mobile=true`).then((response) => response.text()).then((data) => {
        detailPopupMenuBody.innerHTML = data;
      }).catch((error) => {
        detailPopupMenuBody.innerHTML = "<p>\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0435 \u043C\u0435\u043D\u044E</p>";
      });
    });
  });
  !!detailMenuLinkContainer && detailMenuLinkContainer.forEach((el) => {
    el.addEventListener("click", ({ target: container }) => {
      const link = container.querySelector(".js-detail-menu-link");
      !!link && link.click();
    });
  });

  // src/components/cart/cart-index/cart-index.js
  var import_axios7 = __toModule(require_axios2());
  function cartPageCount() {
    const cartPrice = document.querySelector(".js-cart-price");
    const cartPriceAll = document.querySelector(".js-cart-price-all");
    const cartStock = document.querySelector(".js-cart-stock");
    const cartBtnCheckAll = document.querySelector(".js-cart-check-all");
    const cartBtnDeletCheckedAll = document.querySelector(".js-card-del-checked");
    const cartBtnDeletAll = document.querySelector(".js-cart-delet-all");
    const cartBtnsDelItem = document.querySelectorAll(".js-delet-cart-item");
    const cartItemCheckInputs = document.querySelectorAll(".js-product-check");
    const catBtnSubmit = document.querySelector(".js-cart-btn-submit");
    const cartCounterBtnDecr = document.querySelectorAll(".js-btn-decr");
    const cartCounterBtnIncr = document.querySelectorAll(".js-btn-incr");
    const cartBlock = document.querySelector(".cart-block");
    const cartBlockInner = document.querySelector(".cart-block__main-cards");
    const cartHeaderCounters = document.querySelectorAll(".js-header-cart-count ");
    const cartBlockStock = document.querySelector(".js-cart-page-stock");
    const cartTitleCount = document.querySelector(".section-head__title-count");
    const popupProductLimit3 = document.querySelector("#product-limit");
    const popupBasketLimit3 = document.querySelector("#basket-limit");
    const cartEmptyMessage = '<p class="cart-empty">\u0412\u0430\u0448\u0430 \u043A\u043E\u0440\u0437\u0438\u043D\u0430 \u043F\u0443\u0441\u0442\u0430.</p>';
    const cartLoader = `<div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`;
    const formCartLoader = document.querySelector(".js-cart-form .lds-ring-mob-wrap");
    function updateCartSumm() {
      const checkedInput = document.querySelectorAll(".js-product-check:checked");
      const cartTitleCounter2 = document.querySelector(".cart-page .section-head__title-count");
      const cartHeaderCounter = document.querySelectorAll(".js-header-cart-count ");
      const priceArr = [...checkedInput].map((input) => {
        const inputWrap = input.closest(".js-cart-item");
        const inputCount = inputWrap.querySelector(".js-cart-counter");
        const valueCounter = inputCount.value;
        const inputPrice = input.getAttribute("data-price");
        return valueCounter * inputPrice;
      });
      const stockArr = [...checkedInput].map((input) => {
        const inputWrap = input.closest(".js-cart-item");
        const inputCount = inputWrap.querySelector(".js-cart-counter");
        const valueCounter = inputCount.value;
        const inputStock = input.getAttribute("data-stock");
        return valueCounter * inputStock;
      });
      const reducePrice = (priceArr2) => {
        return priceArr2.length > 0 && priceArr2.reduce(function(a, b) {
          return a + b;
        });
      };
      const prices = reducePrice(priceArr);
      const stocks = reducePrice(stockArr);
      const priceAll = prices - stocks;
      if (!!cartStock) {
        const cartStockBlock = document.querySelector(".js-cart-page-stock");
        if (!stocks) {
          cartStockBlock.classList.add("is-hidden");
        } else {
          cartStock.textContent = `-${valueToLocalString(stocks)}`;
          cartStockBlock.classList.remove("is-hidden");
        }
      }
      cartPrice.textContent = prices ? valueToLocalString(prices) : 0;
      cartPriceAll.textContent = valueToLocalString(priceAll);
      const productsCartCountEl = document.querySelectorAll(".js-cart-counter");
      const productsCartCount = productsCartCountEl.length > 0 ? [...productsCartCountEl].map((el) => Number(el.value)).reduce(function(a, b) {
        return a + b;
      }) : 0;
      cartTitleCounter2.textContent = productsCartCount;
      cartHeaderCounter.forEach((count) => count.textContent = productsCartCount);
    }
    function clearCart() {
      const productCardBtns = document.querySelectorAll(".js-product-cart-btn");
      productCardBtns.length && productCardBtns.forEach((btn) => btn.classList.remove("is-active"));
      cartBlock.classList.add("is-empty");
      cartBtnCheckAll.querySelector("input").checked = false;
      cartBlockInner.innerHTML = "";
      cartPrice.textContent = "0";
      cartPriceAll.textContent = "0";
      cartStock.textContent = "0";
      cartTitleCount.textContent = "0";
      cartBlockStock.classList.add("is-hidden");
      cartBtnDeletCheckedAll.setAttribute("disabled", true);
      cartBlock.insertAdjacentHTML("beforeend", cartEmptyMessage);
      cartHeaderCounters.length && cartHeaderCounters.forEach((count) => count.textContent = "0");
    }
    !!cartBtnCheckAll && cartBtnCheckAll.addEventListener("click", () => {
      const checkAllInput = cartBtnCheckAll.querySelector("input");
      if (checkAllInput.checked) {
        cartItemCheckInputs.forEach((input) => input.checked = true);
        cartBtnDeletCheckedAll.removeAttribute("disabled");
        !!catBtnSubmit && catBtnSubmit.removeAttribute("disabled");
      } else {
        cartItemCheckInputs.forEach((input) => input.checked = false);
        cartBtnDeletCheckedAll.setAttribute("disabled", true);
        !!catBtnSubmit && catBtnSubmit.setAttribute("disabled", true);
      }
      updateCartSumm();
    });
    document.addEventListener("DOMContentLoaded", () => {
      !!cartBtnCheckAll && cartBtnCheckAll.click();
      !!formCartLoader && formCartLoader.remove();
    });
    function checkedInputs(inputsArr, param) {
      return [...inputsArr].map((el) => el.checked).filter((el) => el === param);
    }
    cartItemCheckInputs.forEach((itemInput) => {
      itemInput.addEventListener("change", () => {
        const cartItemCheckInputsNew = document.querySelectorAll(".js-product-check");
        const checkedInputsFalse = checkedInputs(cartItemCheckInputsNew, false);
        const checkedInputsTrue = checkedInputs(cartItemCheckInputsNew, true);
        itemInput.checked ? itemInput.setAttribute("checked", true) : itemInput.removeAttribute("checked");
        cartBtnCheckAll.querySelector("input").checked = checkedInputsFalse.length <= 0;
        if (checkedInputsTrue.length <= 0) {
          cartBtnDeletCheckedAll.setAttribute("disabled", true);
          !!catBtnSubmit && catBtnSubmit.setAttribute("disabled", true);
        } else {
          cartBtnDeletCheckedAll.removeAttribute("disabled");
          !!catBtnSubmit && catBtnSubmit.removeAttribute("disabled");
        }
        updateCartSumm();
      });
    });
    cartCounterBtnDecr.forEach((btn) => {
      btn.addEventListener("click", (e2) => {
        e2.preventDefault();
        const inputCounter = btn.closest(".cart-block__item-inner-count").querySelector(".js-cart-counter");
        const btnIncr = btn.closest(".cart-block__item-inner-count").querySelector(".js-btn-incr");
        const id = btn.parentElement.getAttribute("data-id");
        const data = { productId: id };
        let form_data = new FormData();
        for (let key in data) {
          form_data.append(key, data[key]);
        }
        import_axios7.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=deleteItemFromBasket`, form_data).then(function(response) {
          if (inputCounter.value > 1) {
            inputCounter.value = Number(inputCounter.value) - 1;
            inputCounter.setAttribute("value", inputCounter.value);
            btnIncr.removeAttribute("disabled");
          }
          if (inputCounter.value <= 1) {
            btn.setAttribute("disabled", true);
          }
          updateCartSumm();
        }).catch(function(error) {
        });
      });
    });
    cartCounterBtnIncr.forEach((btn) => {
      btn.addEventListener("click", (e2) => {
        e2.preventDefault();
        const inputCounter = btn.closest(".cart-block__item-inner-count").querySelector(".js-cart-counter");
        const btnDecr = btn.closest(".cart-block__item-inner-count").querySelector(".js-btn-decr");
        const id = btn.parentElement.getAttribute("data-id");
        const data = { productId: id };
        let form_data = new FormData();
        for (let key in data) {
          form_data.append(key, data[key]);
        }
        import_axios7.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=addItemToBasket`, form_data).then(function(response) {
          const { data: data2 } = response;
          if (data2.data && data2.data === "basket_limit") {
            showPopup(popupBasketLimit3);
          } else if (data2.data && data2.data === "products_limit") {
            showPopup(popupProductLimit3);
          } else {
            if (inputCounter.value < 3) {
              btnDecr.removeAttribute("disabled");
              inputCounter.value = Number(inputCounter.value) + 1;
              inputCounter.setAttribute("value", inputCounter.value);
            }
            if (inputCounter.value >= 3) {
              btn.setAttribute("disabled", true);
            }
            updateCartSumm();
            handleCartPopup("addItemToBasket");
          }
        }).catch(function(error) {
        });
      });
    });
    !!cartBtnDeletCheckedAll && cartBtnDeletCheckedAll.addEventListener("click", (e2) => {
      e2.preventDefault();
      const checkedInputsFalse = [...cartItemCheckInputs].map((el) => el.checked).filter((el) => !el);
      if (checkedInputsFalse.length <= 0) {
        import_axios7.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=clearBasket`).then(function(response) {
          clearCart();
        }).catch(function(error) {
        });
      } else {
        const checkedInput = document.querySelectorAll(".js-product-check:checked");
        const product_id_list = [...checkedInput].map((el) => el.getAttribute("data-id"));
        let form_data = new FormData();
        product_id_list.forEach((item) => {
          form_data.append("product_id_list[]", item);
        });
        import_axios7.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=clearProducts`, form_data).then(function(response) {
          checkedInput.forEach((el) => {
            const cartItem = el.closest(".js-cart-item");
            cartItem.remove();
          });
          product_id_list.forEach((id) => {
            const buttons = document.querySelectorAll(`.js-product-cart-btn[data-id="${id}"]`);
            buttons.forEach((el) => el.classList.remove("is-active"));
          });
          !!catBtnSubmit && catBtnSubmit.setAttribute("disabled", true);
          updateCartSumm();
          cartBtnDeletCheckedAll.setAttribute("disabled", true);
        }).catch(function(error) {
        });
      }
      updateCartSumm();
    });
    cartBtnsDelItem.length && cartBtnsDelItem.forEach((item) => {
      item.addEventListener("click", (e2) => {
        e2.preventDefault();
        const id = item.parentElement.getAttribute("data-id");
        const data = { productId: id };
        let form_data = new FormData();
        for (let key in data) {
          form_data.append(key, data[key]);
        }
        import_axios7.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=deleteItemFromBasket&quantity=all`, form_data).then(function(response) {
          const cartItem = item.closest(".js-cart-item");
          const productCardButtons = document.querySelectorAll(`.js-product-cart-btn.is-active[data-id="${id}"]`);
          productCardButtons.length && productCardButtons.forEach((btn) => btn.classList.remove("is-active"));
          cartItem.remove();
          updateCartSumm();
          const cartTtems = document.querySelectorAll(".js-cart-item");
          if (!cartTtems.length) {
            clearCart();
          }
          const checkedInput = document.querySelectorAll(".js-product-check:checked");
          if (checkedInput.length <= 0) {
            !!catBtnSubmit && catBtnSubmit.setAttribute("disabled", true);
          }
        }).catch(function(error) {
        });
        const cartItems = document.querySelectorAll(".js-cart-item");
        if (!cartItems.length) {
          import_axios7.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=clearBasket`).then(function(response) {
            clearCart();
          }).catch(function(error) {
          });
        }
      });
    });
    !!cartBtnDeletAll && cartBtnDeletAll.addEventListener("click", (e2) => {
      e2.preventDefault();
      import_axios7.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=clearBasket`).then(function(response) {
        clearCart();
      }).catch(function(error) {
      });
    });
    !!catBtnSubmit && catBtnSubmit.addEventListener("click", (e2) => {
      e2.preventDefault();
      catBtnSubmit.setAttribute("disabled", true);
      const checkedInput = document.querySelectorAll(".js-product-check:checked");
      const cartForm = document.querySelector(".js-cart-form");
      const product_id_list = [...checkedInput].map((el) => el.getAttribute("data-id"));
      let form_data = new FormData();
      product_id_list.forEach((item) => {
        form_data.append("product_id_list[]", item);
      });
      cartForm.insertAdjacentHTML("beforeend", cartLoader);
      import_axios7.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=setBasketOrder`, form_data).then(function(response) {
        const loader2 = document.querySelector(".js-cart-form .lds-ring-mob-wrap");
        !!loader2 && loader2.remove();
        window.location.href = "/order";
      }).catch(function(error) {
        const loader2 = document.querySelector(".js-cart-form .lds-ring-mob-wrap");
        !!loader2 && loader2.remove();
        catBtnSubmit.removeAttribute("disabled");
      });
    });
  }
  cartPageCount();

  // src/components/narratives/narratives-fullscreen/narratives-fullscreen.js
  var imgList = document.querySelectorAll(".narrative-item-slider");
  var prevBtns = document.querySelector(".narratives-fullscreen__pagination-btn--prev");
  var nextBtns = document.querySelector(".narratives-fullscreen__pagination-btn--next");
  var slider2 = new core_default(".narratives-fullscreen__wrapper", {
    modules: [Navigation],
    wrapperClass: "narratives-fullscreen__slider-content",
    spaceBetween: 0,
    slidesPerView: "auto",
    centeredSlides: true,
    roundLengths: true,
    loopAdditionalSlides: 30,
    allowTouchMove: false,
    autoplay: false,
    watchSlidesProgress: true,
    slideClass: "narrative-item-slider",
    slideActiveClass: "narratives-fullscreen__active-slide",
    slideNextClass: "narratives-fullscreen__next-slide",
    slidePrevClass: "narratives-fullscreen__prev-slide"
  });
  nextBtns && nextBtns.addEventListener("click", () => {
    slider2.slideNext();
  });
  prevBtns && prevBtns.addEventListener("click", () => {
    slider2.slidePrev();
  });
  document.addEventListener("DOMContentLoaded", () => {
    const sliderSmallWrap = document.querySelectorAll(".narrative-item-slider .daily-stories");
    const stor = document.querySelectorAll(".narrative-item-slider .daily-stories");
    const htmlArr = [...stor].map((el) => el.innerHTML);
    sliderSmallWrap.forEach((elem) => {
      const container = elem.querySelector(".daily-stories__outer");
      const imgs_wrapper = elem.querySelector(".daily-stories__container");
      const imgs = elem.querySelectorAll(".daily-stories .slide");
      const total_imgs = imgs.length;
      function init() {
        container_width = container.clientWidth;
        imgs_wrapper.style.width = `${container_width * total_imgs}px`;
      }
      ;
      init();
    });
    const closeIcon2 = document.querySelector(".narratives-fullscreen__close");
    const storiesFullscreen2 = document.querySelector(".narratives-fullscreen__overlay");
    closeIcon2 && storiesFullscreen2 && closeIcon2.addEventListener("click", () => {
      const storiesSlides = document.querySelectorAll(".daily-stories");
      slider2.slideTo(0);
      stor.forEach((el, i) => {
        el.innerHTML = htmlArr[i];
      });
      storiesSlides.forEach((el) => el.classList.remove("is-seen"));
      let id = window.setTimeout(function() {
      }, 0);
      while (id--) {
        window.clearTimeout(id);
      }
      storiesFullscreen2.classList.add("hidden");
      enableBodyScroll(storiesFullscreen2);
    });
  });

  // src/components/narratives/narattives.js
  var closeIcon = document.querySelector(".narratives-fullscreen__close");
  function sliderSroriesInit(container, imgs_wrapper, imgs, bars, prevBtn, nextBtn, centralArea, slides, idx) {
    const total_imgs = imgs.length;
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    let container_width2 = container.clientWidth;
    let current_index = 0;
    let move_distance = 0;
    let timerPauseMs = 200;
    let timersSet = [];
    let dataSet = [];
    let timer2;
    let timerPause;
    let endAfter;
    let interval;
    function init() {
      container_width2 = container.clientWidth;
      imgs_wrapper.style.width = `${container_width2 * total_imgs}px`;
    }
    function collections() {
      for (var i = 0; i < total_imgs; ++i) {
        timersSet.push(imgs[i].getAttribute("data-timeout"));
        if (imgs[i].classList.contains("video")) {
          dataSet.push(imgs[i].querySelector("video").getAttribute("src"));
        } else {
          dataSet.push(imgs[i].querySelector("img").getAttribute("src"));
        }
      }
    }
    const stopAnimation = () => {
      bars.forEach((item) => {
        if (item.classList.contains("animate")) {
          item.querySelector("span").style.animationPlayState = "paused";
        }
      });
    };
    const playAnimation = () => {
      bars.forEach((item) => {
        if (item.classList.contains("animate")) {
          item.querySelector("span").style.removeProperty("animation-play-state");
        }
      });
    };
    function slidesAutoPlay(time) {
      clearTimeout(timer2);
      clearInterval(interval);
      let duration = time || timersSet[current_index];
      let step = 10;
      endAfter = duration;
      timer2 = setTimeout(() => {
        if (current_index < total_imgs - 1) {
          nextSlide();
        } else {
          slider2.slideNext();
          slider2.isEnd && !!closeIcon && closeIcon.click();
        }
      }, duration);
      interval = setInterval(() => {
        endAfter -= step;
        if (endAfter <= 0)
          clearInterval(interval);
      }, step);
    }
    function setSlideActive(i) {
      const currentSlide = imgs[i];
      imgs.forEach((el) => el.classList.remove("active"));
      currentSlide.classList.add("active");
      playVideo();
    }
    function setBarActive(i) {
      bars.forEach((el, index2) => {
        if (index2 >= i) {
          el.classList.remove("animate");
        }
        if (index2 < i) {
          el.classList.add("seen");
          el.classList.remove("animate");
        } else {
          el.classList.remove("seen");
        }
      });
      bars[i].classList.add("animate");
    }
    function setActive() {
      if (current_index < total_imgs - 1) {
        setBarActive(parseInt(current_index, 10) + 1);
      } else {
        setBarActive(0);
      }
      setTimeout(() => {
        setBarActive(current_index);
        setSlideActive(current_index);
      }, 1);
    }
    function nextSlide() {
      if (current_index < total_imgs - 1) {
        if (document.body.classList.contains("menu-open"))
          return;
        document.body.classList.remove("paused");
        stopVideo();
        current_index++;
        move_distance = -(current_index * container_width2);
        switchImages(move_distance);
        setActive();
        slidesAutoPlay();
      }
    }
    function prevSlide() {
      if (current_index >= 0) {
        if (document.body.classList.contains("menu-open"))
          return;
        document.body.classList.remove("paused");
        stopVideo();
        if (current_index > 0) {
          current_index--;
        }
        move_distance = -(current_index * container_width2);
        switchImages(move_distance);
        setActive();
        slidesAutoPlay();
      }
    }
    function slideTo2(i) {
      if (document.body.classList.contains("menu-open"))
        return;
      document.body.classList.remove("paused");
      stopVideo();
      current_index = i;
      move_distance = -(current_index * container_width2);
      switchImages(move_distance);
      setActive();
      slidesAutoPlay();
    }
    const pauseVideo = () => {
      if (isVideo()) {
        const v = imgs[current_index].querySelector("video");
        v.muted = true;
        v.pause();
      }
    };
    const playVideo = () => {
      if (isVideo()) {
        const v = imgs[current_index].querySelector("video");
        v.muted = false;
        v.play();
      }
    };
    const stopVideo = () => {
      if (isVideo()) {
        const v = imgs[current_index].querySelector("video");
        v.pause();
        v.muted = true;
        v.currentTime = 0;
      }
    };
    function cancelAnimation() {
      clearTimeout(timer2);
    }
    function switchImages(scrolled_number) {
      const distance = scrolled_number || move_distance;
      imgs_wrapper.style.transform = `translate3d(${distance}px, 0px, 0px)`;
    }
    function toggleSliderAutoplay(e2) {
      const state = e2.target.getAttribute("data-state");
      if (state === "paused") {
        centralArea.setAttribute("data-state", "playing");
        document.body.classList.remove("paused");
        setActive();
        slidesAutoPlay();
        stopVideo();
        playVideo();
      } else {
        centralArea.setAttribute("data-state", "paused");
        document.body.classList.add("paused");
        cancelAnimation();
        pauseVideo();
      }
    }
    function isVideo() {
      return imgs[current_index].classList.contains("video");
    }
    collections();
    setSlideActive(0);
    setBarActive(0);
    slidesAutoPlay();
    const pauseHistory = () => {
      clearTimeout(timerPause);
      timerPause = setTimeout(() => {
        pauseVideo();
        stopAnimation();
        document.body.classList.add("paused");
        clearTimeout(timerPause);
        clearInterval(interval);
        clearTimeout(timer2);
        timerPause = null;
      }, timerPauseMs);
    };
    const clearPauseHistory = () => {
      clearTimeout(timerPause);
      document.body.classList.remove("paused");
      playVideo();
      playAnimation();
      slidesAutoPlay(endAfter);
    };
    const prevHistoryChange = () => {
      if (timerPause) {
        clearTimeout(timerPause);
        timerPause = null;
        if (!bars[0].classList.contains("seen")) {
          centralArea.click();
          slider2.slidePrev();
        } else {
          prevSlide();
        }
      }
    };
    const nextHistoryChange = () => {
      if (timerPause) {
        clearTimeout(timerPause);
        timerPause = null;
        if (bars[bars.length - 2].classList.contains("seen")) {
          centralArea.click();
          slider2.slideNext();
        } else {
          nextSlide();
        }
      }
    };
    prevBtn.addEventListener("mousedown", (e2) => {
      e2.preventDefault();
      pauseHistory(e2);
    });
    nextBtn.addEventListener("mousedown", (e2) => {
      e2.preventDefault();
      pauseHistory(e2);
    });
    prevBtn.addEventListener("touchstart", (e2) => {
      e2.preventDefault();
      pauseHistory(e2);
    });
    nextBtn.addEventListener("touchstart", (e2) => {
      e2.preventDefault();
      pauseHistory(e2);
    });
    prevBtn.addEventListener("mouseup", (e2) => {
      e2.preventDefault();
      clearPauseHistory();
      prevHistoryChange();
    });
    nextBtn.addEventListener("mouseup", (e2) => {
      e2.preventDefault();
      clearPauseHistory();
      nextHistoryChange();
    });
    prevBtn.addEventListener("touchend", (e2) => {
      e2.preventDefault();
      clearPauseHistory();
      prevHistoryChange();
    });
    nextBtn.addEventListener("touchend", (e2) => {
      e2.preventDefault();
      clearPauseHistory();
      nextHistoryChange();
    });
    centralArea.addEventListener("click", (e2) => {
      e2.preventDefault();
      toggleSliderAutoplay(e2);
    });
    bars.forEach((bar) => {
      bar.addEventListener("click", () => {
        slideTo2(bar.getAttribute("data-index"));
      });
    });
  }
  var narattives = document.querySelectorAll(".narrative-item");
  var storiesFullscreen = document.querySelector(".narratives-fullscreen__overlay");
  function changeSlide(sliderSmallWrap, i) {
    const elem = sliderSmallWrap[i];
    const container = elem.querySelector(".daily-stories__outer");
    const imgs_wrapper = elem.querySelector(".daily-stories__container");
    const imgs = elem.querySelectorAll(".daily-stories .slide");
    const bars = elem.querySelectorAll(".progress-bars .bar");
    const prevBtn = elem.querySelector("#prev-slide");
    const nextBtn = elem.querySelector("#next-slide");
    const centralArea = elem.querySelector(".central-area");
    sliderSroriesInit(container, imgs_wrapper, imgs, bars, prevBtn, nextBtn, centralArea, sliderSmallWrap, i);
  }
  narattives.forEach((el, i) => el.addEventListener("click", () => {
    const sliderSmallWrap = document.querySelectorAll(".narrative-item-slider .daily-stories");
    sliderSmallWrap.forEach((elem) => {
      const container = elem.querySelector(".daily-stories__outer");
      const imgs_wrapper = elem.querySelector(".daily-stories__container");
      const imgs = elem.querySelectorAll(".daily-stories .slide");
      const total_imgs = imgs.length;
      function init() {
        setTimeout(() => {
          container_width = container.clientWidth;
          imgs_wrapper.style.width = `${container_width * total_imgs}px`;
        }, 50);
      }
      ;
      init();
    });
    if (i === 0 && slider2.activeIndex === 0) {
      changeSlide(sliderSmallWrap, slider2.activeIndex);
      slider2.slides[0].querySelector(".daily-stories").classList.add("is-seen");
    }
    slider2.slideTo(i);
    storiesFullscreen.classList.remove("hidden");
    disableBodyScroll(storiesFullscreen);
  }));
  var narrativesSlides = document.querySelectorAll(".narrative-item-slider");
  !!storiesFullscreen && storiesFullscreen.addEventListener("click", (e2) => {
    if (e2.target.classList.contains("narrative-item-slider") && !e2.target.classList.contains("narratives-fullscreen__active-slide")) {
      const currentIndex = [...narrativesSlides].indexOf(e2.target);
      slider2.slideTo(currentIndex);
    }
  });
  !!slider2 && slider2.on("slideChange", function() {
    const sliderSmallWrap = document.querySelectorAll(".narrative-item-slider .daily-stories");
    if (!sliderSmallWrap[slider2.activeIndex].classList.contains("is-seen")) {
      setTimeout(() => {
        changeSlide(sliderSmallWrap, slider2.activeIndex);
      }, 50);
    } else {
      const areBtn = sliderSmallWrap[slider2.activeIndex].querySelector(".central-area");
      areBtn.setAttribute("data-state", "paused");
      areBtn.click();
    }
    sliderSmallWrap.forEach((el, ind) => {
      if (ind !== slider2.activeIndex) {
        const areBtn = el.querySelector(".central-area");
        areBtn.setAttribute("data-state", "playing");
        areBtn.click();
      }
    });
    sliderSmallWrap[slider2.activeIndex].classList.add("is-seen");
  });

  // src/components/filters/catalog-navigation/catalog-navigation.js
  var import_accordion_js = __toModule(require_accordion_min());
  var catalogLinks = document.querySelectorAll(".accordion-container");
  var catalogLinkHead = document.querySelectorAll(".catalog-navigation-item");
  var catalogNoveltySection = document.querySelectorAll(".js-catalog-navigation");
  function toggleVisibleCategory2(event2) {
    const target = event2.currentTarget;
    if (event2.target.closest(".catalog-navigation-item") && !event2.target.closest(".catalog-navigation-item__body") && !catalogNoveltySection.length) {
      const isActive = target.classList.contains("show-category");
      catalogLinkHead.forEach((el) => {
        if (el.classList.contains("show-category")) {
          el.classList.remove("show-category");
        }
      });
      if (!isActive)
        target.classList.add("show-category");
    }
  }
  !!catalogLinkHead.length && !catalogNoveltySection.length && catalogLinkHead.forEach((element) => {
    element.addEventListener("click", toggleVisibleCategory2);
  });
  catalogNoveltySection.length && catalogNoveltySection.forEach((el) => {
    const btn = el.querySelector(".catalog-navigation-item__arrow-icon");
    const head = el.querySelector(".catalog-navigation-item");
    !!btn && btn.addEventListener("click", (e2) => {
      head.classList.toggle("show-category");
    });
  });
  !!catalogLinks.length && (0, import_accordion_js.default)(Array.from(catalogLinks));
  document.addEventListener("click", (event2) => {
    const closestItem = event2.target.closest(".js-catalog-link");
    if (event2.target.tagName !== "A" && closestItem) {
      closestItem.querySelector("a").click();
    }
  });

  // src/components/filters/filter-products/brands-filter/brands-filter.js
  var searchInputs = document.querySelectorAll(".catalog-navigation-item .brands-filter__input");
  var brandsSearchCatalogList = document.querySelectorAll(".catalog-navigation-item .brands-filter__list-container");
  searchInputs.length && searchInputs.forEach((searchInput3) => {
    searchInput3.addEventListener("input", function(e2) {
      e2.preventDefault();
      const val = this.value.toString().toLowerCase();
      const searchFields = document.querySelectorAll(".brands-filter__item-label");
      searchFields.forEach((elem) => {
        const serchFieldText = elem.querySelector(".brands-filter__item-name").innerText;
        if (val.trim() && !serchFieldText.toLowerCase().includes(val)) {
          elem.style = "display:none;";
        } else {
          elem.style = "";
        }
        ;
      });
    });
  });
  brandsSearchCatalogList.length && brandsSearchCatalogList.forEach((el) => {
    new perfect_scrollbar_esm_default(el, {
      wheelSpeed: 2,
      wheelPropagation: window.innerWidth >= 1023 ? false : true,
      minScrollbarLength: 20
    });
  });

  // src/components/filters/filter-products/price-filter/price-filter.js
  var import_nouislider = __toModule(require_nouislider());
  var sidebar = document.querySelector("aside, .sidebar");
  if (sidebar) {
    const catalog = sidebar.querySelector(".catalog-navigation");
    const catalogFilterPopup = document.querySelector("#filters-popup");
    catalog && window.innerWidth < 1023 && catalog.remove();
    catalogFilterPopup && window.innerWidth > 1022 && catalogFilterPopup.remove();
  }
  var sliders2 = document.querySelectorAll(".js-range-filter");
  var valuesNodes = document.querySelectorAll(".price-filter__range-counts-label");
  var inputPriceMin = document.querySelector(".price-filter__range-counts .min-price");
  var inputPriceMax = document.querySelector(".price-filter__range-counts .max-price");
  var inputs = [inputPriceMin, inputPriceMax];
  var labelPriceMinVal = !!valuesNodes[0] && valuesNodes[0].getAttribute("data-from");
  var labelPriceMaxVal = !!valuesNodes[1] && valuesNodes[1].getAttribute("data-to");
  !!sliders2 && sliders2.forEach((sliderItem) => {
    import_nouislider.default.create(sliderItem, {
      start: [Number(labelPriceMinVal), Number(labelPriceMaxVal)],
      connect: true,
      range: {
        min: Number(valuesNodes[0].textContent),
        max: Number(valuesNodes[1].textContent)
      }
    });
    var nodes = [
      valuesNodes[0],
      valuesNodes[1]
    ];
    sliderItem.noUiSlider.on("update", function(values, handle) {
      inputs[handle].value = Math.round(values[handle]);
      nodes[handle].innerHTML = Math.round(values[handle]);
    });
    sliderItem.noUiSlider.on("end", function(values, handle) {
      let event2 = new Event("change");
      if (handle === 0) {
        inputPriceMin.dispatchEvent(event2);
      }
      if (handle === 1) {
        inputPriceMax.dispatchEvent(event2);
      }
    });
  });

  // src/js/utils/toggleElementByScroll.js
  var lastScroll = 0;
  var toggleElementByScroll = (selector) => {
    const element = document.querySelector(selector);
    const searchDropMenu = document.querySelectorAll(".js-search-drop");
    const searchInput3 = document.querySelectorAll(".js-search-input");
    const currentScroll = window.pageYOffset;
    const scrollUp = "scroll-up";
    const scrollDown = "scroll-down";
    function checkScroll() {
      if (currentScroll <= 0) {
        element.classList.remove(scrollUp);
        return;
      }
      if (!!element.closest(".header") && Math.abs(lastScroll - currentScroll) * 0.5 < element.offsetHeight && currentScroll > lastScroll) {
        return;
      }
      if (currentScroll > lastScroll && !element.classList.contains(scrollDown)) {
        element.classList.remove(scrollUp);
        element.classList.add(scrollDown);
        searchDropMenu.length > 0 && searchDropMenu.forEach((serchDrop) => serchDrop.classList.remove("is-active"));
        searchInput3.length > 0 && searchInput3.forEach((search) => search.blur());
      } else if (currentScroll < lastScroll && element.classList.contains(scrollDown)) {
        element.classList.remove(scrollDown);
        element.classList.add(scrollUp);
      }
      lastScroll = currentScroll;
    }
    checkScroll();
  };

  // src/components/filters/filters-mobile/filters-mobile.js
  document.querySelector(".filters-mobile") && viewWidth < 1024 ? document.addEventListener("scroll", () => {
    window.pageYOffset >= 250 && toggleElementByScroll(".filters-mobile");
  }) : null;

  // src/components/filters/filter-mobile-popup/filter-mobile-popup.js
  window.enableBodyScrollPopup = function(popupBodyClass) {
    const popupBody = document.querySelector(`${popupBodyClass}`);
    enableBodyScroll(popupBody);
  };
  document.addEventListener("click", (evt) => {
    const target = evt.target.closest(".js-filter-popup");
    if (target) {
      const dataAtr = target.getAttribute("data-popup");
      const currentPopup = document.getElementById(dataAtr);
      toggleFilterPopup(currentPopup);
    }
  });
  function toggleFilterPopup(popup) {
    popup.classList.toggle("is-show");
    const body = document.body;
    const popupBody = popup.querySelector(".filter-mobile-popup__body");
    disableBodyScroll(popupBody);
    document.addEventListener("click", (e2) => {
      const overlay = e2.target.closest(".filter-mobile-popup");
      const popupContainer = e2.target.closest(".filter-mobile-popup__container");
      const closeButton = e2.target.closest(".filter-mobile-popup__close-icon");
      if (!popupContainer && overlay || closeButton) {
        popup.classList.remove("is-show");
        enableBodyScroll(popupBody);
      }
    });
  }
  document.addEventListener("click", (evt) => {
    const target = evt.target.closest(".js-filter-mobile-item");
    if (target) {
      const currentPopup = evt.target.closest(".js-filter-mobile-popup");
      const clone = currentPopup.cloneNode(true);
      const title = currentPopup.querySelector(".filter-mobile-popup__title");
      const newTitle = evt.target.querySelector(".filter-products-mobile__title");
      title.innerText = newTitle.innerText;
      const currentCategoriesContainer = currentPopup.querySelector(".filter-mobile-popup__body");
      const categoryTemplate = currentPopup.querySelector(".js-filter-mobile-item").cloneNode(true);
      categoryTemplate.classList.remove("js-filter-mobile-item");
      categoryTemplate.removeAttribute("data-categories");
      const currentLink = evt.target.closest(".js-filter-mobile-item");
      const currentCategories = currentPopup.querySelectorAll(".js-filter-mobile-item");
      currentCategories.forEach((category) => {
        category.remove();
      });
      const newCategoriesData = JSON.parse(currentLink.dataset.categories);
      newCategoriesData.forEach((category) => {
        const newChild = currentCategoriesContainer.appendChild(categoryTemplate.cloneNode(true));
        newChild.querySelector(".filter-products-mobile__title").innerText = category.title;
        newChild.href = category.href;
      });
      const backLink = currentPopup.querySelector(".js-mobile-popup-prev");
      backLink.addEventListener("click", getPreviousNode(clone));
    }
  });
  var getPreviousNode = (node) => {
    return (evt) => {
      const popup = evt.target.closest(".js-filter-mobile-popup");
      popup.parentNode.appendChild(node);
      popup.parentNode.removeChild(popup);
      evt.target.removeEventListener("click", getPreviousNode(node));
    };
  };
  document.addEventListener("click", (event2) => {
    const closePopupButton = event2.target.closest(".filter-mobile-popup__close");
    if (closePopupButton) {
      closePopupButton.closest(".js-filter-mobile-popup").classList.remove("is-show");
    }
  });

  // src/components/filters/novelty-filter/novelty-filter-mobile/active/filters-mobile-active.js
  var activeFilters = document.querySelectorAll(".js-filter-active");
  !!activeFilters.length && activeFilters.forEach((filter2) => {
    const removeButton = filter2.querySelector(".js-remove-filter");
    removeButton.addEventListener("click", () => {
      filter2.remove();
    });
  });

  // src/components/filters/novelty-filter/novelty-filter-mobile/novelty-filter-mobile.js
  var toggleFilters = document.querySelectorAll(".js-filter-add");
  var activeFiltersContainer = document.querySelector(".js-filters-active");
  !!toggleFilters.length && toggleFilters.forEach((filter2) => {
    filter2.addEventListener("change", (event2) => {
      const isChecked = event2.target.checked;
      if (!isChecked) {
        removeFilter(event2.target.dataset.filterid);
      }
    });
  });
  function removeFilter(id) {
    const activeFilters2 = document.querySelectorAll(".js-filter-active");
    if (!!activeFilters2.length) {
      activeFilters2.forEach((currentFilter) => {
        if (currentFilter.dataset.filterid === id) {
          currentFilter.remove();
        }
      });
    }
  }

  // src/components/product-detail/main/main.js
  var import_axios8 = __toModule(require_axios2());

  // src/js/utils/tabs.js
  var tabs = (tabsSelector, tabsContentSelector, tabsParentSelrctor, activeClass, indx = 0) => {
    const tabsContent = document.querySelectorAll(tabsContentSelector), tabsParent = document.querySelector(tabsParentSelrctor), tabs2 = document.querySelectorAll(tabsSelector);
    function hideTabContent() {
      tabsContent.forEach((item) => {
        item.classList.add("hide");
        item.classList.remove("show", "fade");
      });
      tabs2.forEach((item) => {
        item.classList.remove(activeClass);
      });
    }
    function showTabsContent(indx2) {
      tabsContent[indx2].classList.add("show", "fade");
      tabsContent[indx2].classList.remove("hide");
      tabs2[indx2].classList.add(activeClass);
    }
    hideTabContent();
    showTabsContent(indx);
    tabsParent.addEventListener("click", (event2) => {
      const target = event2.target;
      if (target && target.classList.contains(tabsSelector.slice(1))) {
        tabs2.forEach((item, i) => {
          if (target == item) {
            hideTabContent();
            showTabsContent(i);
          }
        });
      }
    });
  };

  // src/js/utils/accordion.js
  function addAccordion(accordionHeads, accordionItem, accordionContent) {
    const faqHeads = document.querySelectorAll(accordionHeads), faqContent = document.querySelectorAll(accordionContent), faqItem = document.querySelectorAll(accordionItem);
    !!faqHeads.length && faqHeads.forEach((accordionHead, i) => {
      accordionHead.addEventListener("click", () => {
        if (faqItem[i].classList.contains("is-open")) {
          faqItem[i].classList.remove("is-open");
          faqContent[i].style.maxHeight = "0px";
        } else {
          faqItem[i].classList.add("is-open");
          faqContent[i].style.maxHeight = faqContent[i].scrollHeight + "px";
        }
      });
    });
  }

  // src/js/utils/events.js
  var Event2 = function() {
    "use strict";
    this.attach = function(evtName, element, listener, capture) {
      var evt = "", useCapture = capture === void 0 ? true : capture, handler = null;
      if (window.addEventListener === void 0) {
        evt = "on" + evtName;
        handler = function(evt2, listener2) {
          element.attachEvent(evt2, listener2);
          return listener2;
        };
      } else {
        evt = evtName;
        handler = function(evt2, listener2, useCapture2) {
          element.addEventListener(evt2, listener2, useCapture2);
          return listener2;
        };
      }
      return handler.apply(element, [evt, function(ev) {
        var e2 = ev || event, src = e2.srcElement || e2.target;
        listener(e2, src);
      }, useCapture]);
    };
    this.detach = function(evtName, element, listener, capture) {
      var evt = "", useCapture = capture === void 0 ? true : capture;
      if (window.removeEventListener === void 0) {
        evt = "on" + evtName;
        element.detachEvent(evt, listener);
      } else {
        evt = evtName;
        element.removeEventListener(evt, listener, useCapture);
      }
    };
    this.stop = function(evt) {
      evt.cancelBubble = true;
      if (evt.stopPropagation) {
        evt.stopPropagation();
      }
    };
    this.prevent = function(evt) {
      if (evt.preventDefault) {
        evt.preventDefault();
      } else {
        evt.returnValue = false;
      }
    };
  };
  var events_default2 = Event2;

  // src/js/utils/magnifier.js
  var Magnifier = function(evt, options) {
    "use strict";
    var gOptions = options || {}, curThumb = null, curData = {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      lensW: 0,
      lensH: 0,
      lensBgX: 0,
      lensBgY: 0,
      largeW: 0,
      largeH: 0,
      largeL: 0,
      largeT: 0,
      zoom: 2,
      zoomMin: 1.1,
      zoomMax: 5,
      mode: "outside",
      largeWrapperId: gOptions.largeWrapper !== void 0 ? gOptions.largeWrapper.id || null : null,
      status: 0,
      zoomAttached: false,
      zoomable: gOptions.zoomable !== void 0 ? gOptions.zoomable : false,
      onthumbenter: gOptions.onthumbenter !== void 0 ? gOptions.onthumbenter : null,
      onthumbmove: gOptions.onthumbmove !== void 0 ? gOptions.onthumbmove : null,
      onthumbleave: gOptions.onthumbleave !== void 0 ? gOptions.onthumbleave : null,
      onzoom: gOptions.onzoom !== void 0 ? gOptions.onzoom : null
    }, pos = {
      t: 0,
      l: 0,
      x: 0,
      y: 0
    }, gId = 0, status = 0, curIdx = "", curLens = null, curLarge = null, gZoom = gOptions.zoom !== void 0 ? gOptions.zoom : curData.zoom, gZoomMin = gOptions.zoomMin !== void 0 ? gOptions.zoomMin : curData.zoomMin, gZoomMax = gOptions.zoomMax !== void 0 ? gOptions.zoomMax : curData.zoomMax, gMode = gOptions.mode || curData.mode, data = {}, inBounds = false, isOverThumb = 0, getElementsByClass = function(className) {
      var list = [], elements = null, len = 0, pattern = "", i = 0, j = 0;
      if (document.getElementsByClassName) {
        list = document.getElementsByClassName(className);
      } else {
        elements = document.getElementsByTagName("*");
        len = elements.length;
        pattern = new RegExp("(^|\\s)" + className + "(\\s|$)");
        for (i, j; i < len; i += 1) {
          if (pattern.test(elements[i].className)) {
            list[j] = elements[i];
            j += 1;
          }
        }
      }
      return list;
    }, $2 = function(selector) {
      var idx = "", type = selector.charAt(0), result = null;
      if (type === "#" || type === ".") {
        idx = selector.substr(1, selector.length);
      }
      if (idx !== "") {
        switch (type) {
          case "#":
            result = document.getElementById(idx);
            break;
          case ".":
            result = getElementsByClass(idx);
            break;
        }
      }
      return result;
    }, createLens = function(thumb, idx) {
      var lens = document.createElement("div");
      lens.id = idx + "-lens";
      lens.className = "magnifier-loader";
      thumb.parentNode.appendChild(lens);
    }, updateLensOnZoom = function() {
      curLens.style.left = pos.l + "px";
      curLens.style.top = pos.t + "px";
      curLens.style.width = curData.lensW + "px";
      curLens.style.height = curData.lensH + "px";
      curLens.style.backgroundPosition = "-" + curData.lensBgX + "px -" + curData.lensBgY + "px";
      curLarge.style.left = "-" + curData.largeL + "px";
      curLarge.style.top = "-" + curData.largeT + "px";
      curLarge.style.width = curData.largeW + "px";
      curLarge.style.height = curData.largeH + "px";
    }, updateLensOnLoad = function(idx, thumb, large, largeWrapper) {
      var lens = $2("#" + idx + "-lens"), textWrapper = null;
      if (data[idx].status === 1) {
        textWrapper = document.createElement("div");
        textWrapper.className = "magnifier-loader-text";
        lens.className = "magnifier-loader hidden";
        textWrapper.appendChild(document.createTextNode("Loading..."));
        lens.appendChild(textWrapper);
      } else if (data[idx].status === 2) {
        lens.className = "magnifier-lens hidden";
        lens.removeChild(lens.childNodes[0]);
        lens.style.background = "url(" + thumb.src + ") no-repeat 0 0 scroll";
        large.id = idx + "-large";
        large.style.width = data[idx].largeW + "px";
        large.style.height = data[idx].largeH + "px";
        large.className = "magnifier-large hidden";
        if (data[idx].mode === "inside") {
          lens.appendChild(large);
        } else {
          largeWrapper.appendChild(large);
        }
      }
      lens.style.width = data[idx].lensW + "px";
      lens.style.height = data[idx].lensH + "px";
    }, getMousePos = function() {
      var xPos = pos.x - curData.x, yPos = pos.y - curData.y, t = 0, l = 0;
      inBounds = xPos < 0 || yPos < 0 || xPos > curData.w || yPos > curData.h ? false : true;
      l = xPos - curData.lensW / 2;
      t = yPos - curData.lensH / 2;
      if (curData.mode !== "inside") {
        if (xPos < curData.lensW / 2) {
          l = 0;
        }
        if (yPos < curData.lensH / 2) {
          t = 0;
        }
        if (xPos - curData.w + curData.lensW / 2 > 0) {
          l = curData.w - (curData.lensW + 2);
        }
        if (yPos - curData.h + curData.lensH / 2 > 0) {
          t = curData.h - (curData.lensH + 2);
        }
      }
      pos.l = Math.round(l);
      pos.t = Math.round(t);
      curData.lensBgX = pos.l + 1;
      curData.lensBgY = pos.t + 1;
      if (curData.mode === "inside") {
        curData.largeL = Math.round(xPos * (curData.zoom - curData.lensW / curData.w));
        curData.largeT = Math.round(yPos * (curData.zoom - curData.lensH / curData.h));
      } else {
        curData.largeL = Math.round(curData.lensBgX * curData.zoom * (curData.largeWrapperW / curData.w));
        curData.largeT = Math.round(curData.lensBgY * curData.zoom * (curData.largeWrapperH / curData.h));
      }
    }, zoomInOut = function(e2) {
      var delta = e2.wheelDelta > 0 || e2.detail < 0 ? 0.1 : -0.1, handler = curData.onzoom, multiplier = 1, w = 0, h = 0;
      if (e2.preventDefault) {
        e2.preventDefault();
      }
      e2.returnValue = false;
      curData.zoom = Math.round((curData.zoom + delta) * 10) / 10;
      if (curData.zoom >= curData.zoomMax) {
        curData.zoom = curData.zoomMax;
      } else if (curData.zoom >= curData.zoomMin) {
        curData.lensW = Math.round(curData.w / curData.zoom);
        curData.lensH = Math.round(curData.h / curData.zoom);
        if (curData.mode === "inside") {
          w = curData.w;
          h = curData.h;
        } else {
          w = curData.largeWrapperW;
          h = curData.largeWrapperH;
          multiplier = curData.largeWrapperW / curData.w;
        }
        curData.largeW = Math.round(curData.zoom * w);
        curData.largeH = Math.round(curData.zoom * h);
        getMousePos();
        updateLensOnZoom();
        if (handler !== null) {
          handler({
            thumb: curThumb,
            lens: curLens,
            large: curLarge,
            x: pos.x,
            y: pos.y,
            zoom: Math.round(curData.zoom * multiplier * 10) / 10,
            w: curData.lensW,
            h: curData.lensH
          });
        }
      } else {
        curData.zoom = curData.zoomMin;
      }
    }, onThumbEnter = function() {
      curData = data[curIdx];
      curLens = $2("#" + curIdx + "-lens");
      if (curData.status === 2) {
        curLens.className = "magnifier-lens";
        if (curData.zoomAttached === false) {
          if (curData.zoomable !== void 0 && curData.zoomable === true) {
            evt.attach("mousewheel", curLens, zoomInOut);
            if (window.addEventListener) {
              curLens.addEventListener("DOMMouseScroll", function(e2) {
                zoomInOut(e2);
              });
            }
          }
          curData.zoomAttached = true;
        }
        curLarge = $2("#" + curIdx + "-large");
        curLarge.className = "magnifier-large";
      } else if (curData.status === 1) {
        curLens.className = "magnifier-loader";
      }
    }, onThumbLeave = function() {
      if (curData.status > 0) {
        var handler = curData.onthumbleave;
        if (handler !== null) {
          handler({
            thumb: curThumb,
            lens: curLens,
            large: curLarge,
            x: pos.x,
            y: pos.y
          });
        }
        if (curLens.className.indexOf("hidden") === -1) {
          curLens.className += " hidden";
          curThumb.className = curData.thumbCssClass;
          if (curLarge !== null) {
            curLarge.className += " hidden";
          }
        }
      }
    }, move = function() {
      if (status !== curData.status) {
        onThumbEnter();
      }
      if (curData.status > 0) {
        curThumb.className = curData.thumbCssClass + " opaque";
        if (curData.status === 1) {
          curLens.className = "magnifier-loader";
        } else if (curData.status === 2) {
          curLens.className = "magnifier-lens";
          curLarge.className = "magnifier-large";
          curLarge.style.left = "-" + curData.largeL + "px";
          curLarge.style.top = "-" + curData.largeT + "px";
        }
        curLens.style.left = pos.l + "px";
        curLens.style.top = pos.t + "px";
        curLens.style.backgroundPosition = "-" + curData.lensBgX + "px -" + curData.lensBgY + "px";
        var handler = curData.onthumbmove;
        if (handler !== null) {
          handler({
            thumb: curThumb,
            lens: curLens,
            large: curLarge,
            x: pos.x,
            y: pos.y
          });
        }
      }
      status = curData.status;
    }, setThumbData = function(thumb, thumbData) {
      var thumbBounds = thumb.getBoundingClientRect(), w = 0, h = 0;
      thumbData.x = thumbBounds.left;
      thumbData.y = thumbBounds.top;
      thumbData.w = Math.round(thumbBounds.right - thumbData.x);
      thumbData.h = Math.round(thumbBounds.bottom - thumbData.y);
      thumbData.lensW = Math.round(thumbData.w / thumbData.zoom);
      thumbData.lensH = Math.round(thumbData.h / thumbData.zoom);
      if (thumbData.mode === "inside") {
        w = thumbData.w;
        h = thumbData.h;
      } else {
        w = thumbData.largeWrapperW;
        h = thumbData.largeWrapperH;
      }
      thumbData.largeW = Math.round(thumbData.zoom * w);
      thumbData.largeH = Math.round(thumbData.zoom * h);
    };
    this.attach = function(options2) {
      if (options2.thumb === void 0) {
        throw {
          name: "Magnifier error",
          message: "Please set thumbnail",
          toString: function() {
            return this.name + ": " + this.message;
          }
        };
      }
      var thumb = $2(options2.thumb), i = 0;
      if (thumb.length !== void 0) {
        for (i; i < thumb.length; i += 1) {
          options2.thumb = thumb[i];
          this.set(options2);
        }
      } else {
        options2.thumb = thumb;
        this.set(options2);
      }
    };
    this.setThumb = function(thumb) {
      curThumb = thumb;
    };
    this.set = function(options2) {
      if (data[options2.thumb.id] !== void 0) {
        curThumb = options2.thumb;
        return false;
      }
      var thumbObj = new Image(), largeObj = new Image(), thumb = options2.thumb, idx = thumb.id, zoomable = null, largeUrl = null, largeWrapper = $2("#" + options2.largeWrapper) || $2("#" + thumb.getAttribute("data-large-img-wrapper")) || $2("#" + curData.largeWrapperId), zoom = options2.zoom || thumb.getAttribute("data-zoom") || gZoom, zoomMin = options2.zoomMin || thumb.getAttribute("data-zoom-min") || gZoomMin, zoomMax = options2.zoomMax || thumb.getAttribute("data-zoom-max") || gZoomMax, mode = options2.mode || thumb.getAttribute("data-mode") || gMode, onthumbenter = options2.onthumbenter !== void 0 ? options2.onthumbenter : curData.onthumbenter, onthumbleave = options2.onthumbleave !== void 0 ? options2.onthumbleave : curData.onthumbleave, onthumbmove = options2.onthumbmove !== void 0 ? options2.onthumbmove : curData.onthumbmove, onzoom = options2.onzoom !== void 0 ? options2.onzoom : curData.onzoom;
      if (options2.large === void 0) {
        largeUrl = options2.thumb.getAttribute("data-large-img-url") !== null ? options2.thumb.getAttribute("data-large-img-url") : options2.thumb.src;
      } else {
        largeUrl = options2.large;
      }
      if (largeWrapper === null && mode !== "inside") {
        throw {
          name: "Magnifier error",
          message: "Please specify large image wrapper DOM element",
          toString: function() {
            return this.name + ": " + this.message;
          }
        };
      }
      if (options2.zoomable !== void 0) {
        zoomable = options2.zoomable;
      } else if (thumb.getAttribute("data-zoomable") !== null) {
        zoomable = thumb.getAttribute("data-zoomable") === "true";
      } else if (curData.zoomable !== void 0) {
        zoomable = curData.zoomable;
      }
      if (thumb.id === "") {
        idx = thumb.id = "magnifier-item-" + gId;
        gId += 1;
      }
      createLens(thumb, idx);
      data[idx] = {
        zoom,
        zoomMin,
        zoomMax,
        mode,
        zoomable,
        thumbCssClass: thumb.className,
        zoomAttached: false,
        status: 0,
        largeUrl,
        largeWrapperId: mode === "outside" ? largeWrapper.id : null,
        largeWrapperW: mode === "outside" ? largeWrapper.offsetWidth : null,
        largeWrapperH: mode === "outside" ? largeWrapper.offsetHeight : null,
        onzoom,
        onthumbenter,
        onthumbleave,
        onthumbmove
      };
      evt.attach("mouseover", thumb, function(e2, src) {
        if (curData.status !== 0) {
          onThumbLeave();
        }
        curIdx = src.id;
        curThumb = src;
        onThumbEnter(src);
        setThumbData(curThumb, curData);
        pos.x = e2.clientX;
        pos.y = e2.clientY;
        getMousePos();
        move();
        var handler = curData.onthumbenter;
        if (handler !== null) {
          handler({
            thumb: curThumb,
            lens: curLens,
            large: curLarge,
            x: pos.x,
            y: pos.y
          });
        }
      }, false);
      evt.attach("mousemove", thumb, function(e2, src) {
        isOverThumb = 1;
      });
      evt.attach("load", thumbObj, function() {
        data[idx].status = 1;
        setThumbData(thumb, data[idx]);
        updateLensOnLoad(idx);
        evt.attach("load", largeObj, function() {
          data[idx].status = 2;
          updateLensOnLoad(idx, thumb, largeObj, largeWrapper);
        });
        largeObj.src = data[idx].largeUrl;
      });
      thumbObj.src = thumb.src;
    };
    evt.attach("mousemove", document, function(e2) {
      pos.x = e2.clientX;
      pos.y = e2.clientY;
      getMousePos();
      if (inBounds === true) {
        move();
      } else {
        if (isOverThumb !== 0) {
          onThumbLeave();
        }
        isOverThumb = 0;
      }
    }, false);
    evt.attach("scroll", window, function() {
      if (curThumb !== null) {
        setThumbData(curThumb, curData);
      }
    });
  };
  var magnifier_default = Magnifier;

  // src/components/product-detail/main/main.js
  var import_fslightbox = __toModule(require_fslightbox());
  var productDetailForm = document.querySelector(".js-product-detail-delivery-form");
  var productDetailDelivery = document.querySelector(".js-product-detail-delivery");
  var productDetailDeliveryDay = document.querySelector(".js-product-detail-delivery-day");
  !!productDetailForm && window.addEventListener("load", (e2) => {
    const id = productDetailForm.getAttribute("data-id");
    const loader2 = `<p class="product-detail-main__delivery-load">\u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044B\u0432\u0430\u0435\u043C \u0441\u0442\u043E\u0438\u043C\u043E\u0441\u0442\u044C \u0434\u043E\u0441\u0442\u0430\u0432\u043A\u0438, \u044D\u0442\u043E \u0437\u0430\u0439\u043C\u0451\u0442 \u043F\u0430\u0440\u0443 \u0441\u0435\u043A\u0443\u043D\u0434</p>`;
    productDetailForm.insertAdjacentHTML("beforeend", loader2);
    import_axios8.default.get(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=getDeliveryPriceProduct&id=${id}`).then(function(response) {
      const { data } = response;
      if (!!productDetailDelivery && !!productDetailDeliveryDay && data.data) {
        productDetailDelivery.textContent = data.data.price;
        productDetailDeliveryDay.textContent = data.data.day;
      }
      if (!data.data) {
        productDetailForm.style = "display: none";
      }
      const loaderDelivery = !!productDetailForm && productDetailForm.querySelector(".product-detail-main__delivery-load");
      !!loaderDelivery && loaderDelivery.remove();
    }).catch(function(error) {
      const loaderDelivery = !!productDetailForm && productDetailForm.querySelector(".product-detail-main__delivery-load");
      !!loaderDelivery && loaderDelivery.remove();
      productDetailForm.style = "display: none";
    });
  });
  function initZoomImgs() {
    let event2 = new events_default2(), magnifier = new magnifier_default(event2);
    const images = document.querySelectorAll(".zoom-img > img");
    !!images.length && images.forEach((image, index2) => {
      const imageSrc = image.getAttribute("src");
      magnifier.attach({
        thumb: `#js-magnifier-${index2}`,
        large: imageSrc,
        largeWrapper: `js-magnifier-preview-${index2}`,
        zoom: 3,
        zoomable: true
      });
    });
  }
  initZoomImgs();
  function copyLinkDetail() {
    const copyLinkButton = document.querySelector(".product-detail-main__share-btn");
    !!copyLinkButton && copyLinkButton.addEventListener("click", (evt) => {
      const notification = document.querySelector(".js-share-notification");
      if (!notification.classList.contains("active")) {
        const currentUrl = copyLinkButton.getAttribute("data-url");
        navigator.clipboard.writeText(currentUrl).then(() => {
          notification.classList.add("active");
          document.addEventListener("click", removeNotification);
          setTimeout(() => {
            notification.classList.remove("active");
            document.removeEventListener("click", removeNotification);
          }, 3e3);
        });
      }
    });
    const removeNotification = (e2) => {
      const target = e2.target.closest(".js-share-notification");
      if (target) {
        target.classList.remove("active");
      }
    };
  }
  copyLinkDetail();
  function initSliderDetailProduct() {
    const swiperThumbBottom = new core_default(".js-thumb-slider-bottom", {
      spaceBetween: 10,
      slidesPerView: 9,
      freeMode: false,
      watchSlidesProgress: false,
      navigation: {
        nextEl: ".product-detail-main__thumb-slider-bottom-button-next",
        prevEl: ".product-detail-main__thumb-slider-bottom-button-prev"
      }
    });
    new core_default(".js-thumb-slider-top", {
      spaceBetween: 10,
      thumbs: {
        swiper: swiperThumbBottom
      }
    });
  }
  initSliderDetailProduct();
  function initRating() {
    const rateStaticItem = document.querySelectorAll(".js-stars-static");
    const rater = require_rater_js();
    if (rateStaticItem.length > 0) {
      rateStaticItem.forEach((el) => {
        const rateStaticHeight = el.getAttribute("data-height");
        const rateStaticRating = el.getAttribute("data-ratenum");
        const myRaterStatic = rater({
          element: el,
          max: 5,
          starSize: +rateStaticHeight,
          readOnly: true,
          rating: +rateStaticRating
        });
        el.style.width = `120px`;
        el.style.height = "20px";
        const value2 = el.querySelector(".star-value");
        const percent = +rateStaticRating / 5;
        const margins = (Math.ceil(+rateStaticRating) - 1) * 5;
        value2.style.width = `${100 * percent + margins}px`;
        value2.style.height = `20px`;
      });
    }
  }
  initRating();
  function initLightBox() {
    let lightbox = new FsLightbox();
    const imagesLightBox = document.querySelectorAll(".js-product-detail-lightbox-img");
    const imgCoontainer = document.querySelectorAll(".product-detail-main__images-slide .zoom-img");
    function lightboxImg() {
      let arrImgs = [];
      imagesLightBox.forEach(function(element) {
        arrImgs.push(element.getAttribute("src"));
      });
      return arrImgs;
    }
    lightbox.props.sources = lightboxImg();
    imgCoontainer.forEach((img) => {
      img.addEventListener("click", (e2) => {
        const productThumbSlider = document.querySelector(".js-thumb-slider-top").swiper;
        const activeIndex = !!productThumbSlider && productThumbSlider.activeIndex;
        lightbox.open(activeIndex);
      });
    });
  }
  initLightBox();
  var detailProductInfoWrap = document.querySelector(".js-product-detail-wrap");
  !!detailProductInfoWrap && document.addEventListener("click", function(event2) {
    const detailProductMemoryBtn = event2.target.closest(".js-detail-product-btns");
    if (detailProductMemoryBtn) {
      event2.preventDefault();
      const url2 = detailProductMemoryBtn.getAttribute("href");
      const inputsChecked = detailProductMemoryBtn.querySelector("input");
      const typeBtn = inputsChecked.getAttribute("name");
      const keyBtn = inputsChecked.getAttribute("data-type");
      detailProductInfoWrap.insertAdjacentHTML("beforeend", `<div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`);
      detailProductInfoWrap.classList.add("pointer-none");
      document.body.style.overflow = "hidden";
      fetch(`${url2}?ajax=Y&${typeBtn}=${keyBtn}`).then((response) => response.text()).then((data) => {
        detailProductInfoWrap.innerHTML = data;
        initSliderDetailProduct();
        tabs(".js-tab", ".js-tabs-content", ".js-tabs-container", "active-tab");
        addAccordion(".js-faq-head", ".js-faq-item", ".js-faq-content");
        initRating();
        initZoomImgs();
        initLightBox();
        copyLinkDetail();
        const slider3 = detailProductInfoWrap.querySelector(".js-slider");
        initSwiper(slider3);
      }).catch((error) => {
      }).finally(function() {
        const loader2 = detailProductInfoWrap.querySelector(".lds-ring-mob-wrap");
        setTimeout(() => {
          !!loader2 && loader2.remove();
          detailProductInfoWrap.classList.remove("pointer-none");
          document.body.removeAttribute("style");
        }, 100);
      });
    }
  });

  // src/components/product-detail/tabs/tabs.js
  var tabsItems = document.querySelectorAll(".js-tab");
  var orderAdress = document.querySelectorAll(".js-order-field-delivery");
  var orderAdressItems = orderAdress.length && [...orderAdress].filter((adress) => !adress.classList.contains("js-new-address-order"));
  tabsItems.length > 0 && tabs(".js-tab", ".js-tabs-content", ".js-tabs-container", "active-tab");
  if (tabsItems.length > 0 && orderAdress.length && !orderAdressItems.length) {
    tabs(".js-tab", ".js-tabs-content", ".js-tabs-container", "active-tab", 1);
  }

  // src/components/product-detail/reviews-block/reviews-block.js
  var scrollContent = document.querySelector(".reviews-block__reviews-gallery");
  var popupReviewsDetail = document.querySelector(".js-popup#reviews-gallery");
  var popupReviewsDetailSlider = !!popupReviewsDetail && popupReviewsDetail.querySelector(".js-slider");
  !!scrollContent && new perfect_scrollbar_esm_default(scrollContent, {
    wheelSpeed: 2,
    wheelPropagation: true,
    minScrollbarLength: 20,
    useBothWheelAxes: true
  });
  function requesChangeReviewsList(btn, param) {
    const url2 = btn.getAttribute("href");
    const list = document.querySelector(".reviews-block__reviews-list");
    const loader2 = `<div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`;
    list.insertAdjacentHTML("beforeend", loader2);
    btn.setAttribute("disabled", true);
    fetch(url2).then((response) => response.text()).then((data) => {
      if (param === "toListEnd") {
        list.insertAdjacentHTML("beforeend", data);
        btn.remove();
      }
      if (param === "toListInner") {
        list.innerHTML = data;
      }
      refreshFsLightbox();
    }).catch((error) => {
      list.insertAdjacentHTML("beforeend", '<p class="review__error">\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u043F\u0440\u043E\u0441\u0430</p>');
    }).finally(function() {
      setTimeout(() => {
        const reviewError2 = document.querySelector(".review__error");
        const loader3 = document.querySelector(".reviews-block__reviews .lds-ring-mob-wrap");
        !!reviewError2 && reviewError2.remove();
        !!loader3 && loader3.remove();
        !!btn && btn.removeAttribute("disabled", true);
      }, 500);
    });
  }
  document.addEventListener("click", (e2) => {
    const reviewsShoworeBtn = e2.target.closest(".js-reviews-more-btn");
    const reviewBlock = document.querySelector(".js-product-detail-wrap");
    const reviewsBlockSideLinks = e2.target.closest(".js-reviews-block-side-rating");
    if (reviewsShoworeBtn) {
      e2.preventDefault();
      requesChangeReviewsList(reviewsShoworeBtn, "toListEnd");
    }
    if (reviewsBlockSideLinks) {
      e2.preventDefault();
      requesChangeReviewsList(reviewsBlockSideLinks, "toListInner");
    }
  });

  // src/components/faq/faq.js
  addAccordion(".js-faq-head", ".js-faq-item", ".js-faq-content");

  // src/components/profile/profile-orders-all/profile-orders-all.js
  var import_axios9 = __toModule(require_axios2());
  var repeatBtn = document.querySelector(".js-repeat-order");
  !!repeatBtn && document.addEventListener("click", (event2) => {
    const repeatBtnClicked = event2.target.closest(".js-repeat-order");
    if (repeatBtnClicked) {
      let formData = new FormData();
      let orderDataId = repeatBtnClicked.getAttribute("data-order-id");
      !!orderDataId && formData.append("order-id", orderDataId);
      import_axios9.default.post("/local/ajax/reorder.php", formData).then((response) => {
        window.location.replace("/order");
      }).catch(() => {
        const errPopup = document.querySelector("#error-popup");
        showPopup(errPopup);
      });
    }
  });

  // src/js/utils/resizeTextArea.js
  function textAreaResize() {
    let txArea = document.querySelectorAll(".js-textarea");
    function OnInput() {
      this.style.height = "auto";
      this.style.height = this.scrollHeight + "px";
    }
    ;
    txArea.length > 0 && txArea.forEach((area, i) => {
      area.setAttribute("style", "height:" + area.scrollHeight + "px;overflow-y:hidden;");
      area.addEventListener("input", OnInput, false);
    });
  }

  // src/components/profile/profile-data/profile-data.js
  var import_axios10 = __toModule(require_axios2());
  var btnSelect = document.querySelector(".js-btn-select");
  var itemsSelect = document.querySelectorAll(".js-btn-select-drop-item");
  var selectText = document.querySelector(".js-selected-item-text");
  var fileAvatarInput = document.querySelector(".js-edit-avatar");
  var avatarSection = document.querySelector(".profile-section__avatar");
  var selectDrop = document.querySelector(".js-btn-select-drop");
  var setInputsRequired = (isRequired) => {
    if (formProfileInputs) {
      formProfileInputs.forEach((inputElement) => {
        isRequired ? inputElement.setAttribute("required", "") : inputElement.removeAttribute("required");
      });
    }
  };
  var formProfile = document.querySelector(".profile-section__form.js-form ");
  var formProfileInputs = !!formProfile && formProfile.querySelectorAll("input");
  var noRegFormProfile = document.querySelector(".profile-no-reg__form");
  !!formProfile && document.addEventListener("click", (e2) => {
    const targetProfileForm = e2.target.closest(".profile-section__form.js-form ");
    if (!noRegFormProfile && !targetProfileForm) {
      !!formProfileInputs && formProfileInputs.forEach((item) => item.disabled = true);
      !!formProfile && formProfile.querySelector(".js-edit-profile-btn") && formProfile.querySelector(".js-edit-profile-btn").removeAttribute("style");
      !!formProfile && formProfile.querySelector(".profile-section__valid-message-err") && formProfile.querySelector(".profile-section__valid-message-err").classList.remove("hide");
      !!formProfile && formProfile.querySelector(".profile-section__valid-message-success") && formProfile.querySelector(".profile-section__valid-message-success").classList.remove("hide");
      !!formProfile && formProfile.querySelector(".js-btn-submit") && formProfile.querySelector(".js-btn-submit").remove();
    }
  });
  var isCachedValid = true;
  !!formProfile && formProfile.addEventListener("change", function(e2) {
    const btn = formProfile.querySelector(".profile-section__form-btn");
    if (e2.target.id === "edit-avatar") {
      if (isCachedValid) {
        setInputsRequired(false);
        btn.removeAttribute("disabled");
        btn.setAttribute("data-skip-validation", "true");
      }
      return;
    }
    const inputs2 = [...formProfileInputs].map((el) => !el.value.trim()).filter((el) => el);
    setInputsRequired(true);
    btn.setAttribute("data-skip-validation", "false");
    validateForms[0].revalidate().then((isValid2) => {
      isCachedValid = isValid2;
      if (isValid2) {
        btn.removeAttribute("disabled");
      } else {
        btn.setAttribute("disabled", "");
      }
    });
  });
  !!fileAvatarInput && fileAvatarInput.addEventListener("change", function(e2) {
    const fileAvatar = e2.target.files;
    const imgAvatar = document.querySelector(".profile-section__avatar-img");
    const data = new FormData();
    const files2 = fileAvatarInput.files;
    const file = fileAvatarInput.files[0];
    const maxSizeFile = Number(fileAvatarInput.getAttribute("size"));
    const form3 = fileAvatarInput.closest(".js-form");
    const url2 = !!form3 && form3.getAttribute("action");
    const filesAvatar = Array.from(fileAvatar);
    Array.from(files2).forEach((file2, i) => {
      data.append("avatar", file2);
    });
    if (file && file.size < maxSizeFile && (file.type === "image/png" || file.type === "image/jpeg")) {
      import_axios10.default.post(url2, data, {
        headers: {
          "Content-Type": "multipart/form-data"
        }
      }).then((response) => {
        filesAvatar.forEach((file2) => {
          if (!file2.type.match("image")) {
            return;
          }
          const reader = new FileReader();
          reader.onload = (e3) => {
            const src = e3.target.result;
            imgAvatar.setAttribute("src", src);
          };
          reader.readAsDataURL(file2);
        });
      });
    } else {
      !!avatarSection && avatarSection.insertAdjacentHTML("beforeend", '<p class="avatar-error">\u0412\u044B\u0431\u0435\u0440\u0435\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0443\u044E \u043A\u0430\u0440\u0438\u043D\u043A\u0443</p>');
      const avatarError = !!avatarSection && avatarSection.querySelector(".avatar-error");
      setTimeout(() => {
        !!avatarError && avatarError.remove();
      }, 2e3);
    }
  });
  textAreaResize();
  var customsText = document.querySelector(".js-customs-title");
  var customsHint = document.querySelector(".js-customs-hint");
  !!customsText && customsText.addEventListener("mouseenter", () => {
    customsHint && customsHint.classList.add("is-active");
  });
  !!customsText && customsText.addEventListener("mouseout", () => {
    customsHint && customsHint.classList.remove("is-active");
  });
  var btnSubmit = document.createElement("button");
  btnSubmit.innerHTML = "<span><span>\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C</span></span>";
  btnSubmit.classList.add("btn", "profile-section__form-btn", "js-btn-for-edit-form", "js-btn-submit");
  document.addEventListener("click", (event2) => {
    const editButton = event2.target.closest(".js-edit-profile-btn");
    const successValidDeliveryData = document.querySelector(".profile-section__valid-message-success");
    const errorValidData = document.querySelector(".profile-section__valid-message-err");
    const formInnerProfile = document.querySelector(".profile-section__form-inner");
    if (!!editButton) {
      editButton.style.display = "none";
      !!successValidDeliveryData && successValidDeliveryData.classList.add("hide");
      !!errorValidData && errorValidData.classList.add("hide");
      !!formInnerProfile && formInnerProfile.querySelectorAll("input").forEach((input) => input.removeAttribute("disabled"));
      !!formInnerProfile && formInnerProfile.append(btnSubmit);
    }
  });
  !!btnSubmit && btnSubmit.addEventListener("click", async (e2) => {
    const url2 = formProfile.getAttribute("action");
    formProfile.querySelector("#name").value = formProfile.querySelector("#name").value.trim();
    formProfile.querySelector("#patronymic").value = formProfile.querySelector("#patronymic").value.trim();
    formProfile.querySelector("#surname").value = formProfile.querySelector("#surname").value.trim();
    const data = new FormData(formProfile);
    const popupSuccess2 = document.querySelector("#success-popup");
    const popupSuccessText = !!popupSuccess2 && popupSuccess2.querySelector(".success-popup__title");
    const submitBtnOrder = document.querySelector(".js-purchase-submit-btn");
    const fileInput = formProfile.querySelector(".js-edit-avatar");
    const fileInputAvatar = !!fileInput && fileInput.files;
    function changeNoEditFieldsOnSubmitForm(fieldNoEdit, formField) {
      const noEditFormElement = formProfile.querySelector(fieldNoEdit);
      const formElement = formProfile.querySelector(formField);
      noEditFormElement.textContent = formElement.value;
    }
    const skipValidation = btnSubmit.getAttribute("data-skip-validation");
    if (skipValidation === "true") {
      e2.preventDefault();
      e2.stopPropagation();
    }
    Array.from(fileInputAvatar).forEach((file, i) => {
      data.append("avatar", file);
    });
    validateForms[0].revalidate().then(() => {
      if (validateForms[0].isValid || skipValidation === "true") {
        import_axios10.default.post(url2, data, {
          headers: {
            "Content-Type": "multipart/form-data"
          }
        }).then((response) => {
          if (!!submitBtnOrder) {
            submitBtnOrder.removeAttribute("disabled");
            const formBodyInner = formProfile.querySelector(".profile-section__form-body-inner");
            !!formBodyInner && formBodyInner.classList.add("isHiden");
          }
          popupSuccessText.textContent = "\u0414\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B";
          showPopup(popupSuccess2, null, null, true);
          document.body.style.overflow = "hidden";
        }).catch(function(error) {
          popupSuccessText.textContent = "\u041E\u0448\u0438\u0431\u043A\u0430! \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437.";
          showPopup(popupSuccess2);
        });
      }
    });
  });

  // src/components/profile/profile-address/profile-address.js
  var import_axios11 = __toModule(require_axios2());
  var import_debounce4 = __toModule(require_debounce());
  var btnAddAddress = document.querySelector(".js-add-address-btn");
  var addressWrap = document.querySelector(".js-address-wrap");
  var addressCount = document.querySelector(".js-addrress-count");
  var popupDelete = document.querySelector("#delete-address");
  var formAdressEdit = document.querySelector(".js-address-form");
  var adressItemForm;
  var noRegAreaForm = document.querySelector(".profile-no-reg__form");
  var popupDeleteBtn = !!popupDelete && popupDelete.querySelector(".js-popup-delete-address-btn");
  var popupCancelBtn = !!popupDelete && popupDelete.querySelector(".js-popup-cancel-address-btn");
  var popupDataIndexText = !!popupDelete && popupDelete.querySelector(".js-popup_delete-data-index");
  var popupDataAddressText = !!popupDelete && popupDelete.querySelector(".js-popup_delete-data-address");
  var addresItemHtml = `<div class="profile-address__list-item js-addrress-item">
                        <form  class="profile-address__form js-address-form save">
                            <div class="profile-address__form-inner">
                                <label class='profile-address__form-label profile-address__form-label-input'>
                                  <input  type='number'  placeholder='\u0418\u043D\u0434\u0435\u043A\u0441'  class='profile-address__form-input js-number' id='index' name='index'/>
                                 </label>
                                 <span class='profile-address__text-error js-no-data-message'>\u0414\u0430\u043D\u043D\u044B\u0435 \u043D\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B</span>
                                <label class="profile-address__form-label">
                                    <textarea placeholder='\u0410\u0434\u0440\u0435\u0441 \u0434\u043E\u0441\u0442\u0430\u0432\u043A\u0438' class="profile-address__form-area js-textarea" id="address" name="address"></textarea>
                                </label>
                                <div class="profile-address__form-dropp"></div>
                            </div>
                            <div class="profile-address__form-btns">
                                <div class="profile-address__form-btns-edits">
                                    <div class="profile-address__form-btns-edits-del js-addrress-btn-del">
                                        <svg class="icon delete" width="20px" height="20px">
                                            <use xlink:href="/local/templates/DoBuy/assets/images/sprite.svg#delete"></use>
                                        </svg>
                                    </div>
                                    <div class="profile-address__form-btns-edits-edit js-addrress-btn-edit">
                                        <svg class="icon edit" width="20px" height="20px">
                                            <use xlink:href="/local/templates/DoBuy/assets/images/sprite.svg#edit"></use>
                                        </svg>
                                    </div>
                                </div>
                            </div>
                                <div class="profile-address__form-btns-saves">
                                    <button class="profile-address__form-btns-saves-save js-addrress-btn-save"
                                        type="submit" disabled="true">\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C</button>
                                </div>
                        </form>
                        </div>`;
  function addAddressItem(btn, wrapper) {
    btn.addEventListener("click", function(e2) {
      wrapper.childElementCount > 1 && btn.classList.add("hide");
      setTimeout(() => {
        wrapper.insertAdjacentHTML("beforeend", addresItemHtml);
      }, 0);
      let lastItem = wrapper.querySelectorAll(".js-addrress-item")[wrapper.querySelectorAll(".js-addrress-item").length - 1];
      !!lastItem && lastItem.querySelector(".js-addrress-btn-save").setAttribute("disabled", true);
      !!lastItem && editAddressItem(lastItem);
      textAreaResize();
    });
  }
  function editAddressItem(item) {
    const form3 = item.querySelector(".js-address-form");
    form3.classList.add("save");
    validateForm(item);
  }
  function delAddressItem(item, count) {
    const form3 = item.querySelector(".js-address-form");
    const id = form3.getAttribute("id");
    const url2 = addressWrap.getAttribute("data-url");
    const data = { id };
    let form_data = new FormData();
    for (let key in data) {
      form_data.append(key, data[key]);
    }
    if (!id) {
      item.remove();
      btnAddAddress.classList.remove("hide");
    }
    !!id && import_axios11.default.post(url2, form_data).then(() => {
      item.remove();
      const countVal = Number(count.textContent);
      count.textContent = countVal - 1;
      btnAddAddress.classList.remove("hide");
    }).catch((err) => {
      item.insertAdjacentHTML("beforeend", '<p class="address-error">\u041E\u0448\u0438\u0431\u043A\u0430! \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437</p>');
    }).finally(() => {
      setTimeout(() => {
        const errItem = item.querySelector(".address-error");
        !!errItem && errItem.remove();
      }, 1500);
    });
  }
  function saveAddressItem(btn, item, count) {
    const form3 = item.querySelector(".js-address-form");
    const textarVal = form3.querySelector("textarea").value.trim();
    const inputVal = form3.querySelector("input").value;
    const id = form3.getAttribute("id");
    const data = new FormData(form3);
    const url2 = !!addressWrap ? addressWrap.getAttribute("data-url") : "/local/ajax/address.php";
    !btn.classList.contains("js-order-save-address") ? data.append("id", id) : data.append("id", null);
    if (textarVal) {
      btn.innerHTML = `\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C <div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`;
      btn.setAttribute("disabled", true);
      import_axios11.default.post(url2, data).then((response) => {
        const { data: data2 } = response;
        const formId = data2.id;
        formId && form3.setAttribute("id", formId);
        item.insertAdjacentHTML("beforeend", '<p class="address-success">\u0410\u0434\u0440\u0435\u0441 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D!</p>');
        if (!btn.classList.contains("js-order-save-address")) {
          const countVal = Number(count.textContent);
          !!countVal && countVal + 1 <= 3 && (count.textContent = countVal + 1);
          form3.classList.remove("save");
          const errMessage = form3.querySelector(".js-no-data-message");
          !!errMessage && errMessage.removeAttribute("style");
        } else {
          const allFields = document.querySelectorAll(".js-new-address-order");
          const fieldOrderAddress = allFields[allFields.length - 1];
          const fieldOrderAddressCopy = !!fieldOrderAddress && fieldOrderAddress.cloneNode(true);
          const fieldOrderAddressText = !!fieldOrderAddress && fieldOrderAddress.querySelector(".order-block__address-field-text");
          const fieldOrderAddressInput = !!fieldOrderAddress && fieldOrderAddress.querySelector(".order-block__address-input");
          const btnNewAddress = document.querySelector(".js-newaddress-btn");
          if (!!fieldOrderAddress) {
            fieldOrderAddress.classList.remove("hid");
            fieldOrderAddressText.textContent = inputVal ? `${inputVal}, ${textarVal}` : textarVal;
            if (!!fieldOrderAddressInput) {
              fieldOrderAddressInput.checked = true;
            }
            fieldOrderAddress.parentNode.appendChild(fieldOrderAddressCopy);
            form3.querySelector("textarea") && (form3.querySelector("textarea").value = "");
            form3.querySelector("input") && (form3.querySelector("input").value = "");
            tabs(".js-tab", ".js-tabs-content", ".js-tabs-container", "active-tab");
            !!btnNewAddress && document.querySelectorAll(".js-order-field-delivery").length >= 3 && btnNewAddress.classList.add("unactive");
          }
          const submitBtn2 = document.querySelector(".js-purchase-submit-btn");
          const orderCheckInput = document.querySelector(".js-order-checked:checked");
          const orderCheckInputItem = document.querySelector(".js-order-checked");
          import_axios11.default.get(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=getDeliveryPrice`).then(function(response2) {
            const { data: data3 } = response2;
            const deliveriPrice = document.querySelector(".js-delivery-price");
            const dateField = document.querySelector(".js-delivery-date");
            const priceAllField = document.querySelector(".js-pay-summ-product-price span");
            const priceAllFieldSumm = document.querySelector(".order-block__purchase-summ-price span");
            const deliveriPriceSumm = document.querySelector(".js-pay-summ-delivery-price span");
            if (!!deliveriPrice) {
              deliveriPrice.textContent = data3.data.price;
              deliveriPriceSumm.textContent = data3.data.price;
            }
            if (!!dateField) {
              dateField.textContent = data3.data.time;
            }
            if (!!priceAllField) {
              const summ = Number(priceAllField.textContent.replace(/\s/g, "")) + Number(data3.data.price.replace(/\s/g, ""));
              priceAllFieldSumm.textContent = valueToLocalString(summ);
            }
            form3.querySelector(".js-no-data-message").removeAttribute("style");
            !!submitBtn2 && !!orderCheckInput && submitBtn2.removeAttribute("disabled");
            !!orderCheckInputItem && orderCheckInputItem.removeAttribute("disabled");
          }).catch(function(error) {
            const deliveriPrice = document.querySelector(".order-block__delivery-content-item-info");
            if (!!deliveriPrice) {
              deliveriPrice.insertAdjacentHTML("beforeend", '<p class="delivery-error">\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0434\u0430\u043D\u043D\u044B\u0435. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u0441\u0442\u0430\u043D\u0438\u0446\u0443</p>');
            }
          });
        }
      }).catch(function(error) {
        item.insertAdjacentHTML("beforeend", '<p class="address-error">\u041E\u0448\u0438\u0431\u043A\u0430! \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437</p>');
      }).finally(function() {
        setTimeout(() => {
          const errMessage = item.querySelector(".address-error");
          const successMessage = item.querySelector(".address-success");
          !!errMessage && errMessage.remove();
          !!successMessage && successMessage.remove();
          btn.removeAttribute("disabled", true);
          btn.innerHTML = `\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C`;
        }, 2e3);
      });
    }
  }
  function addressAutoCoomplitOnInput(event2) {
    const value2 = event2.target.value;
    const areaParent = event2.target.closest(".profile-address__form-inner");
    const indexInput = areaParent.querySelector(".profile-address__form-input");
    const areaInput = areaParent.querySelector(".profile-address__form-area");
    !!noRegAreaForm && document.querySelector(".js-address-area-no-reg").removeAttribute("data-valid");
    const areaDropp = !!areaParent && areaParent.querySelector(".profile-address__form-dropp");
    if (value2.trim()) {
      import_axios11.default.get(`/local/ajax/adressAutocomplete.php`, {
        params: {
          address: `${!!indexInput && indexInput.value ? indexInput.value : ""} ${!!areaInput && areaInput.value ? areaInput.value : ""}`
        }
      }).then(function(response) {
        const { data } = response;
        const addressValues = data.length && data.map((el) => el);
        if (!!addressValues && !!areaDropp) {
          const blockNotFound = areaParent.querySelector(".profile-address__form-dropp-notfound");
          !!blockNotFound && blockNotFound.remove();
          areaDropp.innerHTML = data.map((el) => `<p class="profile-address__form-dropp-address" ${el.valid && 'data-valid="valid"'} ${el.valid && el.data.postal_code && `data-index="${el.data.postal_code}"`}>${el.value}</p>`).join("");
        } else {
          const blockNotFound = areaParent.querySelector(".profile-address__form-dropp-notfound");
          !!blockNotFound && blockNotFound.remove();
          areaDropp.innerHTML = `<p class="profile-address__form-dropp-notfound">\u041D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E</p>`;
        }
      }).catch(function(error) {
        const blockNotFound = areaParent.querySelector(".profile-address__form-dropp-notfound");
        !!blockNotFound && blockNotFound.remove();
        !!areaDropp && (areaDropp.innerHTML = `<p class="profile-address__form-dropp-notfound">\u041D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E</p>`);
      });
      !!areaDropp && areaDropp.classList.add("is-show");
    } else {
      !!areaDropp && areaDropp.classList.remove("is-show");
    }
  }
  (!!btnAddAddress || !!formAdressEdit) && document.addEventListener("click", function(e2) {
    const btnEdit = e2.target.closest(".js-addrress-btn-edit");
    const btnDel = e2.target.closest(".js-addrress-btn-del");
    const btnSave = e2.target.closest(".js-addrress-btn-save");
    const item = e2.target.closest(".js-addrress-item");
    const addressForms = document.querySelectorAll(".js-address-form");
    const popUPdel = e2.target.closest("#delete-address");
    adressItemForm = item;
    !!item && !!btnEdit && editAddressItem(item);
    if (!!item && !!btnDel) {
      !!item.querySelector("#index").value || !!item.querySelector("#address").value ? showPopupDelete(item) : delAddressItem(item, addressCount);
    }
    if (!!item && !!btnSave) {
      e2.preventDefault();
      saveAddressItem(btnSave, item, addressCount);
    }
    if (!item && !popUPdel && !document.querySelector(".order-block")) {
      addressForms.length > 0 && addressForms.forEach((form3) => {
        const area = form3.querySelector(".js-textarea");
        const input = form3.querySelector("#index");
        const errMessage = form3.querySelector(".js-no-data-message");
        if (!!area && form3.classList.contains("save")) {
          if (!form3.getAttribute("id")) {
            area.value = "";
            area.removeAttribute("data-valid");
            input.value = "";
          }
          !!errMessage && errMessage.removeAttribute("style");
          form3.classList.remove("save");
        }
      });
    }
  });
  var debounceAddressAutoCoomplitOnInput = (0, import_debounce4.debounce)(addressAutoCoomplitOnInput, 250);
  document.addEventListener("input", function(event2) {
    const formArea = event2.target.closest(".profile-address__form-area");
    const formInputIndex = event2.target.closest(".profile-address__form-input");
    if (formInputIndex) {
      formInputIndex.oninput = function() {
        if (this.value.length >= 6) {
          this.value = this.value.slice(0, 6);
        }
      };
      debounceAddressAutoCoomplitOnInput(event2);
      validateForm(event2.target.closest(".js-address-form"));
    }
    if (formArea) {
      const addressForm = !!formArea && formArea.closest(".js-address-form");
      const btnSubmit2 = !!addressForm && addressForm.querySelector(".js-addrress-btn-save");
      const inputAddr = !!addressForm && addressForm.querySelector(".profile-address__form-input");
      !!inputAddr && (inputAddr.value = "");
      debounceAddressAutoCoomplitOnInput(event2);
      !!btnSubmit2 && btnSubmit2.setAttribute("disabled", true);
    }
  });
  document.addEventListener("click", function(event2) {
    const droppAddress = event2.target.closest(".profile-address__form-dropp-address");
    if (!event2.target.closest(".profile-address__form-dropp") && !event2.target.closest(".profile-address__form-area")) {
      const addressDropp = document.querySelectorAll(".profile-address__form-dropp");
      !!addressDropp.length && addressDropp.forEach((dropp) => dropp.classList.remove("is-show"));
    }
    if (droppAddress) {
      const fieldParent = droppAddress.closest(".profile-address__form-inner");
      const textareaField = !!fieldParent && fieldParent.querySelector(".profile-address__form-area");
      const indexField = !!fieldParent && fieldParent.querySelector(".profile-address__form-input");
      const formAddress = !!fieldParent && fieldParent.closest(".js-address-form");
      const formAddressBtn = !!formAddress && formAddress.querySelector(".js-addrress-btn-save");
      textareaField.value = droppAddress.textContent;
      !noRegAreaForm && textareaField.focus();
      !!noRegAreaForm && droppAddress.hasAttribute("data-index") && textareaField.setAttribute("data-index", droppAddress.getAttribute("data-index"));
      droppAddress.hasAttribute("data-valid") && textareaField.setAttribute("data-valid", "valid");
      droppAddress.hasAttribute("data-index") && !!indexField && (indexField.value = droppAddress.getAttribute("data-index"));
      const addressDropp = document.querySelectorAll(".profile-address__form-dropp");
      !!addressDropp.length && addressDropp.forEach((dropp) => dropp.classList.remove("is-show"));
      droppAddress.hasAttribute("data-valid") && !!formAddressBtn && validateForm(formAddress);
      !!noRegAreaForm && validateForms[0].revalidate();
    }
  });
  !!btnAddAddress && addAddressItem(btnAddAddress, addressWrap);
  function validateForm(form3) {
    let textArea = form3.querySelector("#address");
    let btnSub = form3.querySelector(".js-addrress-btn-save");
    if (!!textArea && textArea.getAttribute("data-valid") === "valid") {
      btnSub.removeAttribute("disabled");
      return;
    }
    btnSub.setAttribute("disabled", true);
  }
  document.addEventListener("change", (event2) => {
    const indexInputAdr = event2.target.closest("#index"), addressInputAdr = event2.target.closest("#address");
    if (!!indexInputAdr) {
      const textArea = indexInputAdr.closest(".js-address-form").querySelector(".profile-address__form-area");
      !!textArea && textArea.removeAttribute("data-valid");
      const addressInputMessage = indexInputAdr.closest(".js-address-form").querySelector(".js-no-data-message");
      !!addressInputMessage && (addressInputMessage.style.display = "block");
    }
    if (!!addressInputAdr) {
      const textArea = addressInputAdr.closest(".js-address-form").querySelector(".profile-address__form-area");
      const inputAdr = addressInputAdr.closest(".js-address-form").querySelector(".profile-address__form-input");
      !!textArea && textArea.removeAttribute("data-valid");
      !!inputAdr && (inputAdr.value = "");
      const addressInputMessage = addressInputAdr.closest(".js-address-form").querySelector(".js-no-data-message");
      !!addressInputMessage && (addressInputMessage.style.display = "block");
    }
  });
  var removePopupDelete = () => {
    !!popupDelete && popupDelete.classList.remove("is-show");
    document.body.classList.remove("overflow");
  };
  var showPopupDelete = (item) => {
    const form3 = item.querySelector(".js-address-form");
    const addressForms = document.querySelectorAll(".js-address-form");
    popupDataIndexText.innerHTML = form3.querySelector("#index") && form3.querySelector("#index").value;
    popupDataAddressText.innerHTML = form3.querySelector("#index") && form3.querySelector("#address").value;
    showPopup(popupDelete);
  };
  popupDeleteBtn.addEventListener("click", (e2) => {
    e2.preventDefault();
    !!adressItemForm && delAddressItem(adressItemForm, addressCount);
    removePopupDelete();
  });
  popupCancelBtn.addEventListener("click", () => {
    removePopupDelete();
  });

  // src/components/profile/profile-orders-pay/profile-orders-pay.js
  var btnShow = document.querySelectorAll(".js-cars-pay-btn-show");
  var profileBreadCrumb = document.querySelector(".profile-page .breadcrumbs.backLink .breadcrumbs__link-mobile");
  var profileSectionOrderDetail = document.querySelector(".profile-section__content--orders");
  if (!profileSectionOrderDetail && !!profileBreadCrumb) {
    const prevUrl = document.referrer;
    profileBreadCrumb.setAttribute("href", prevUrl);
  }
  btnShow.length > 0 && btnShow.forEach(function(btn) {
    btn.addEventListener("click", function() {
      const buttomToShow = this;
      const btnwrap = btn.closest(".profile-orders__pay-cards-card");
      const scrollSection = !!btnwrap && btnwrap.querySelector(".js-order-cards-scroll");
      const cardItemsToShow = !!btnwrap && btnwrap.querySelectorAll(".profile-orders__pay-cards-card-body-inner-item.hidden");
      const cardItemsToHide = !!btnwrap && btnwrap.querySelectorAll(".profile-orders__pay-cards-card-body-inner-item.show");
      let ps = new perfect_scrollbar_esm_default(scrollSection, {
        wheelSpeed: 2,
        minScrollbarLength: 2
      });
      ;
      cardItemsToShow.length > 0 && cardItemsToShow.forEach((card) => {
        card.classList.remove("hidden");
        card.classList.add("show");
        ps.update();
        buttomToShow.textContent = "\u0421\u0432\u0435\u0440\u043D\u0443\u0442\u044C";
      });
      cardItemsToHide.length > 0 && cardItemsToHide.forEach((card) => {
        card.classList.remove("show");
        card.classList.add("hidden");
        ps.destroy();
        buttomToShow.textContent = "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0432\u0441\u0435";
      });
    });
  });
  var copyLinkBtnAll = document.querySelectorAll(".track-num");
  copyLinkBtnAll.forEach((link) => {
    link.addEventListener("click", function(event2) {
      event2.preventDefault();
      const range = document.createRange();
      const linkUrl = link.getAttribute("href");
      range.selectNode(link);
      window.getSelection().addRange(range);
      try {
        const successful = document.execCommand("copy");
        window.open(`${linkUrl}`, "_blank");
      } catch (err) {
        console.error("Oops, unable to copy");
      }
      window.getSelection().removeAllRanges();
    });
  });

  // src/components/profile/profile-reviews/profile-reviews.js
  var reviewsBlocks = document.querySelectorAll(".js-reviews-profile-block");
  var emptyBlockToShow = document.querySelector(".profile-section__reviews-none");
  var emptyReviewsBlock = !!reviewsBlocks.length && [...reviewsBlocks].filter((el) => !el.getAttribute("data-empty"));
  if (!!reviewsBlocks.length && !!emptyBlockToShow && !emptyReviewsBlock.length) {
    reviewsBlocks.forEach((block) => block.classList.add("hide"));
    emptyBlockToShow.classList.remove("hide");
  }

  // src/components/profile/profile-payment/profile-payment.js
  var import_axios12 = __toModule(require_axios2());
  var form2 = document.querySelector(".profile-payment__form");
  !!form2 && form2.addEventListener("change", () => {
    validateForms[0].revalidate().then(() => {
      const btn = document.querySelector(".order-block__purchase-submit-btn");
      const orderFieldDelivery2 = document.querySelector(".js-order-field-delivery input:checked");
      const checkForm = document.querySelector(".order-block__purchase-submit-checkbox:checked");
      btn.setAttribute("disabled", "");
      !!checkForm && !!orderFieldDelivery2 && validateForms[0].isValid && btn.removeAttribute("disabled");
      !checkForm && btn.setAttribute("disabled", "");
      !validateForms[0].isValid && btn.setAttribute("disabled", "");
      !orderFieldDelivery2 && btn.setAttribute("disabled", "");
    });
  });
  !!form2 && document.addEventListener("click", (event2) => {
    const btn = event2.target.closest(".order-block__purchase-submit-btn");
    const addressSelected = document.querySelector(".js-order-field-delivery input:checked");
    const addressText = !!addressSelected && addressSelected.nextElementSibling.textContent;
    if (!!btn) {
      let data = new FormData(form2);
      let url2 = form2.getAttribute("action");
      if (validateForms[0].isValid && !!addressSelected) {
        data.delete("address");
        data.append("address", addressText);
        import_axios12.default.post(url2, data, {
          headers: {
            "Content-Type": "multipart/form-data"
          }
        }).then((response) => {
          const { data: data2 } = response;
          !!data2 && !!data2.data.paymentUrl && window.location.replace(data2.data.paymentUrl);
        }).catch(() => {
          const errPopUp = document.querySelector("#error-popup");
          showPopup(errPopUp);
        });
      }
    }
  });

  // src/components/order/order.js
  var import_axios13 = __toModule(require_axios2());
  var btnEsitProfile = document.querySelector(".order-block__section-inner .js-form .edit");
  var orderProfileForm = document.querySelector(".order-block__section-inner .js-form");
  var orderProfoleInnerBlock = document.querySelector(".order-block__section-inner .js-form .profile-section__form-body-inner");
  var orderFieldDelivery = document.querySelectorAll(".js-order-field-delivery");
  var promoInput2 = document.querySelector(".js-promo-input");
  var promoBtn2 = document.querySelector(".js-promo-btn");
  var promoBtnChancel = document.querySelector(".js-promo-btn-cancel");
  var purchaseSubmitBtn = document.querySelector(".js-purchase-submit-btn");
  var orderPromoForm = document.querySelector(".js-promo-form");
  var orderCheckedInput = document.querySelector(".js-order-checked");
  !!btnEsitProfile && btnEsitProfile.addEventListener("click", (e2) => {
    !!btnEsitProfile && btnEsitProfile.classList.add("isHide");
    !!orderProfoleInnerBlock && orderProfoleInnerBlock.classList.remove("isHiden");
    !!orderProfileForm && orderProfileForm.classList.remove("noEdit");
  });
  !!orderProfileForm && document.addEventListener("click", (e2) => {
    if (!e2.target.closest(".order-block__section-inner .js-form")) {
      const iconEdit = orderProfileForm.querySelector(".edit");
      !!orderProfoleInnerBlock && orderProfoleInnerBlock.classList.add("isHiden");
      !!iconEdit && iconEdit.classList.remove("isHide");
    }
  });
  !!promoInput2 && promoInput2.addEventListener("input", (e2) => {
    const promoError = document.querySelector(".order-block__promo .promo-error");
    !!promoError && promoError.remove();
    e2.target.value.trim() ? promoBtn2.removeAttribute("disabled") : promoBtn2.setAttribute("disabled", true);
    e2.target.value.trim() ? promoBtnChancel.removeAttribute("disabled") : promoBtnChancel.setAttribute("disabled", true);
  });
  !!purchaseSubmitBtn && purchaseSubmitBtn.addEventListener("click", (e2) => {
    e2.preventDefault();
    const loader2 = `<div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`;
    purchaseSubmitBtn.insertAdjacentHTML("beforeend", loader2);
    purchaseSubmitBtn.setAttribute("disabled", true);
    const addressSelected = document.querySelector(".js-order-field-delivery input:checked");
    const addressText = !!addressSelected && addressSelected.nextElementSibling.textContent;
    import_axios13.default.get(`/local/ajax/order.php`, {
      params: {
        address: addressText
      }
    }).then(function(response) {
      const { data } = response;
      const urlToRedirect = data.paymentUrl;
      purchaseSubmitBtn.removeAttribute("disabled");
      let loader3 = purchaseSubmitBtn.querySelector(".lds-ring-mob-wrap");
      !!loader3 && loader3.remove();
      urlToRedirect && window.location.replace(urlToRedirect);
    }).catch(function(error) {
      purchaseSubmitBtn.removeAttribute("disabled");
      let loader3 = purchaseSubmitBtn.querySelector(".lds-ring-mob-wrap");
      !!loader3 && loader3.remove();
    });
  });
  !!purchaseSubmitBtn && window.addEventListener("load", (e2) => {
    const submitBtn2 = document.querySelector(".js-purchase-submit-btn");
    const inputPromo = document.querySelector(".js-promo-input");
    const profileForm = document.querySelector(".js-form");
    const deliveryPriceBlocks = document.querySelectorAll(".js-delivery-hide-block");
    const formValid = !!profileForm && profileForm.getAttribute("data-valid");
    !!submitBtn2 && submitBtn2.setAttribute("disabled", true);
    !!inputPromo && inputPromo.setAttribute("readonly", true);
    !!orderCheckedInput && orderCheckedInput.addEventListener("change", () => {
      const checked = orderCheckedInput.checked;
      const orderFieldDelivery2 = document.querySelector(".js-order-field-delivery input:checked");
      const checkFormValid = document.querySelector(".profile-section__form.js-form").getAttribute("data-valid") === "Y";
      checked && !!orderFieldDelivery2 && checkFormValid ? purchaseSubmitBtn.removeAttribute("disabled") : purchaseSubmitBtn.setAttribute("disabled", true);
    });
    import_axios13.default.get(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=getDeliveryPrice`).then(function(response) {
      const { data } = response;
      const deliveriPrice = document.querySelector(".js-delivery-price");
      const dateField = document.querySelector(".js-delivery-date");
      const priceAllField = document.querySelector(".js-pay-summ-product-price span");
      const priceAllFieldSumm = document.querySelector(".order-block__purchase-summ-price span");
      const deliveriPriceSumm = document.querySelector(".js-pay-summ-delivery-price span");
      const deliveriPriceBlock = document.querySelector(".order-block__delivery-content-item-info");
      const deliveriPriceAll = document.querySelector(".order-block__purchase-summ");
      const errorMessage = data.data && data.data.msg;
      const errorStatus = data.data && data.data.status;
      if (!!deliveriPriceBlock && !!deliveriPriceAll && errorStatus === "error" && errorMessage) {
        deliveriPriceBlock.insertAdjacentHTML("beforeend", `<p class="delivery-error">${errorMessage}</p>`);
        deliveriPriceAll.insertAdjacentHTML("beforeend", `<p class="delivery-error">${errorMessage}</p>`);
        !!deliveryPriceBlocks.length && deliveryPriceBlocks.forEach((block) => block.classList.add("hidden"));
      }
      if (!!deliveriPrice && !!data.data && !!data.data.price) {
        deliveriPrice.textContent = new Intl.NumberFormat().format(data.data.price);
        deliveriPriceSumm.textContent = new Intl.NumberFormat().format(data.data.price);
      }
      if (!!dateField) {
        dateField.textContent = data.data && data.data.time;
      }
      if (!!priceAllField && !!data.data && !!data.data.price) {
        const summ = new Intl.NumberFormat().format(Number(priceAllField.textContent.replace(/\s/g, "")) + Number(data.data.price));
        priceAllFieldSumm.textContent = summ;
      }
      data.data.price && orderCheckedInput.removeAttribute("disabled");
      !!inputPromo && inputPromo.removeAttribute("readOnly");
      !!promoBtnChancel && promoBtnChancel.removeAttribute("disabled");
    });
  });
  function setNewBasket(newBasket, promoBtn3) {
    for (let key in newBasket) {
      const productsOrderCard = document.querySelectorAll(`.order-block__side-inner-item[data-id="${key}"]`);
      productsOrderCard.length && productsOrderCard.forEach((card) => {
        const cardPrice = card.querySelector(".order-block__side-inner-item-content-price span");
        const stockPrice = card.querySelector(".order-block__side-inner-item-content-stock-price");
        const cardPercent = card.querySelector(".order-block__side-inner-item-content-stock-discount");
        if (key === card.getAttribute("data-id")) {
          if (!!cardPrice) {
            cardPrice.textContent = valueToLocalString(newBasket[key].PRICE);
          }
          if (!!stockPrice && !!cardPercent && newBasket[key].PERCENT) {
            stockPrice.textContent = valueToLocalString(newBasket[key].BASE_PRICE);
            cardPercent.textContent = `-${valueToLocalString(newBasket[key].PERCENT)}%`;
          }
          if (!promoBtn3) {
            const cardBlockStock = card.querySelector(".order-block__side-inner-item-content-stock");
            !!cardBlockStock && cardBlockStock.remove();
          }
          if (!stockPrice && newBasket[key].PERCENT) {
            if (promoBtn3) {
              const cardContent = card.querySelector(".order-block__side-inner-item-content");
              const priceBlockHtml = `<div class="order-block__side-inner-item-content-stock">
                    <p class="order-block__side-inner-item-content-stock-price">${valueToLocalString(newBasket[key].BASE_PRICE)} \u20BD </p>
                    <p class="order-block__side-inner-item-content-stock-discount">-${valueToLocalString(newBasket[key].PERCENT)}%</p>
                    </div>`;
              !!cardContent && cardContent.insertAdjacentHTML("beforeend", priceBlockHtml);
            }
          }
        }
      });
    }
  }
  var promoBtns = !!orderPromoForm && orderPromoForm.querySelectorAll("button");
  var promoBlock2 = document.querySelector(".order-block__promo");
  var promoSubmitBtn = !!orderPromoForm && orderPromoForm.querySelector(".js-promo-btn");
  var loader = `<div class="lds-ring-mob-wrap"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div>`;
  !!orderPromoForm && orderPromoForm.addEventListener("submit", (event2) => {
    event2.preventDefault();
    promoBtns.length > 0 && promoBtns.forEach((btn) => {
      btn.insertAdjacentHTML("beforeend", loader);
      btn.setAttribute("disabled", true);
    });
    let form_data = new FormData(orderPromoForm);
    const targetSubmit = event2.submitter;
    const urlParam = targetSubmit === promoSubmitBtn ? "setPromocode" : "deletePromocode";
    const submitterPromoBtn = targetSubmit === promoSubmitBtn;
    import_axios13.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=${urlParam}`, form_data).then(function(response) {
      const { data } = response;
      const promoError = promoBlock2.querySelectorAll(".promo-error");
      !!promoError.length && promoError.forEach((errBlock) => errBlock.remove());
      const couponList = data.data.COUPON_LIST;
      if (targetSubmit === promoSubmitBtn && !Object.keys(couponList).length) {
        throw new Error();
      }
      const orderPrice = document.querySelector(".order-block__purchase-summ-price span");
      orderPrice.textContent = !!data.data.FULL_PRICE ? new Intl.NumberFormat().format(data.data.FULL_PRICE) : "\u0426\u0435\u043D\u0430 \u043D\u0435 \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u0430\u043B\u0430\u0441\u044C";
      const newBasket = data.data.PRICES.BASKET;
      if (targetSubmit === promoSubmitBtn) {
        orderPromoForm.classList.add("cancel");
      } else {
        orderPromoForm.classList.remove("cancel");
      }
      if (newBasket) {
        setNewBasket(newBasket, submitterPromoBtn);
      }
      promoBtns.length > 0 && promoBtns.forEach((btn) => {
        const loaderBtn = btn.querySelector(".lds-ring-mob-wrap");
        !!loaderBtn && loaderBtn.remove();
        btn.removeAttribute("disabled");
      });
      handleCartPopup(urlParam);
    }).catch(function(error) {
      const promoError = promoBlock2.querySelectorAll(".promo-error");
      !!promoError.length && promoError.forEach((errBlock) => errBlock.remove());
      promoBtns.length > 0 && promoBtns.forEach((btn) => {
        const loader2 = btn.querySelector(".lds-ring-mob-wrap");
        !!loader2 && loader2.remove();
        btn.removeAttribute("disabled");
      });
      const promoCatchText = `<p class="promo-error">${targetSubmit === promoSubmitBtn ? "\u041F\u0440\u043E\u043C\u043E\u043A\u043E\u0434 \u043D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D" : "\u041E\u0448\u0438\u0431\u043A\u0430! \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0435\u0449\u0435 \u0440\u0430\u0437."}</p>`;
      !!promoBlock2 && promoBlock2.insertAdjacentHTML("beforeend", promoCatchText);
    });
  });

  // src/components/cards/reviews-card/reviews-card.js
  var reviewsCardWrapper = document.querySelectorAll(".card-review__images");
  !!reviewsCardWrapper && reviewsCardWrapper.forEach((item) => {
    new perfect_scrollbar_esm_default(item, {
      wheelSpeed: 0.5,
      wheelPropagation: false
    });
  });

  // src/components/cards/product-card/product-card.js
  var import_axios14 = __toModule(require_axios2());
  var favoriteLinks = document.querySelectorAll(".js-favorite");
  var favoriteCountHeader = document.querySelector(".js-header-favorite-count");
  !!favoriteLinks.length && document.addEventListener("click", (event2) => {
    const clickedLink = event2.target.closest(".js-favorite");
    if (clickedLink) {
      event2.preventDefault();
      const productCard = clickedLink.closest(".card-product");
      !!productCard && productCard.classList.add("disabled");
      clickedLink.classList.add("disabled");
      const iconInFavorite = clickedLink.classList.contains("is-active");
      const urlParams = iconInFavorite ? "deleteItemToFavrorite" : "addItemToFavorite";
      const id = clickedLink.getAttribute("data-id");
      const profileSectionFavorite = document.querySelector(".profile-section__favorite-cards");
      const data = { id };
      let form_data = new FormData();
      for (let key in data) {
        form_data.append(key, data[key]);
      }
      import_axios14.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=${urlParams}`, form_data).then((response) => {
        const favoriteWrap = document.querySelector(".profile-section__favorite-cards-inner");
        const favoriteCurrentCard = !!favoriteWrap && favoriteWrap.querySelector(`.js-favorite-profile-item[data-id="${id}"]`);
        const favoriteCurrentCardsAll = document.querySelectorAll(`.js-favorite.is-active[data-id="${id}"]`);
        if (urlParams === "deleteItemToFavrorite") {
          const cardsInFavoriteLength = !!favoriteWrap && favoriteWrap.childElementCount;
          clickedLink.classList.remove("is-active");
          favoriteCurrentCardsAll.forEach((el) => el.classList.remove("is-active"));
          favoriteCountHeader.textContent = Number(favoriteCountHeader.textContent) - 1;
          if (!!cardsInFavoriteLength && cardsInFavoriteLength <= 1) {
            favoriteWrap.innerHTML = "";
            !!profileSectionFavorite && profileSectionFavorite.classList.add("is-empty");
          }
          !!favoriteCurrentCard && favoriteCurrentCard.remove();
        } else {
          !!profileSectionFavorite && profileSectionFavorite.classList.remove("is-empty");
          favoriteCountHeader.textContent = Number(favoriteCountHeader.textContent) + 1;
          const cardProduct = clickedLink.closest(".card-product");
          clickedLink.classList.add("is-active");
          const newcardProduct = cardProduct.cloneNode(true);
          const newCardFavoriteWrapper = document.createElement("div");
          newCardFavoriteWrapper.classList.add("profile-section__favorite-cards-inner-item", "js-favorite-profile-item");
          newCardFavoriteWrapper.setAttribute("data-id", id);
          newCardFavoriteWrapper.append(newcardProduct);
          !!favoriteWrap && favoriteWrap.append(newCardFavoriteWrapper);
        }
        clickedLink.classList.remove("disabled");
        !!productCard && productCard.classList.remove("disabled");
      }).catch(function(error) {
        clickedLink.classList.remove("disabled");
        !!productCard && productCard.classList.remove("disabled");
      });
    }
  });
  var headerCount = document.querySelectorAll(".js-header-cart-count");
  var cartPageWrapper = document.querySelector(".cart-block__main-cards");
  var cartPageBlock = document.querySelector(".cart-block");
  var cartTitleCounter = document.querySelector(".section-head__title-count");
  var cartCheckAllBtn = document.querySelector(".js-cart-check-all input");
  var popupProductLimit2 = document.querySelector("#product-limit");
  var popupBasketLimit2 = document.querySelector("#basket-limit");
  document.addEventListener("click", (e2) => {
    const btn = e2.target.closest(".js-product-cart-btn");
    if (btn) {
      if (!btn.classList.contains("is-active")) {
        e2.preventDefault();
        const prodId = btn.getAttribute("data-id");
        const data = { productId: prodId };
        let form_data = new FormData();
        for (let key in data) {
          form_data.append(key, data[key]);
        }
        import_axios14.default.post(`/bitrix/services/main/ajax.php?mode=class&c=DoBuy:BasketComponent&action=addItemToBasket`, form_data).then((response) => {
          const { data: data2 } = response;
          if (data2.data === "products_limit") {
            showPopup(popupProductLimit2);
          } else if (data2.data === "basket_limit") {
            showPopup(popupBasketLimit2);
          } else {
            const btns = document.querySelectorAll(`.js-product-cart-btn[data-id="${prodId}"]`);
            btns.forEach((button) => button.classList.add("is-active"));
            headerCount.forEach((count) => count.textContent = Number(count.textContent) + 1);
            if (!!cartPageBlock && !!cartPageWrapper) {
              const currentProductCard = btn.closest(".card-product");
              const currentProductCardImg = !!currentProductCard && currentProductCard.querySelector(".card-product__slider-img");
              const currentProductSrc = !!currentProductCardImg && currentProductCardImg.getAttribute("src");
              const currentProductName = !!currentProductCard && currentProductCard.querySelector(".card-product__content-title");
              const currentProductNameText = !!currentProductName && currentProductName.textContent;
              const currentProductHref = !!currentProductName && currentProductName.getAttribute("href");
              const currentProductPrice = !!currentProductCard && currentProductCard.querySelector(".card-product__price span");
              const currentProductPriceSumm = !!currentProductPrice && currentProductPrice.textContent;
              const currentProductPriceOld = !!currentProductCard && currentProductCard.querySelector(".card-product__price--old");
              const currentProductPriceOldSumm = !!currentProductPriceOld && currentProductPriceOld.textContent;
              const currentProductPercent = !!currentProductCard && currentProductCard.querySelector(".card-product__price-discount");
              const currentProductPercentText = !!currentProductPercent && currentProductPercent.textContent;
              const currentCardFavorite = !!currentProductCard && currentProductCard.querySelector(".card-product__favorite");
              const stockPrice = currentProductPriceOldSumm ? Number(currentProductPriceOldSumm.replace(/\s/g, "").replace(//g, "")) - Number(currentProductPriceSumm.replace(/\s/g, "")) : "0";
              const emptyCartBlock = !!cartPageBlock && cartPageBlock.querySelector(".cart-empty");
              const cartDelCheckedBtn = document.querySelector(".js-card-del-checked");
              const cartDelAllBtn = document.querySelector(".js-cart-delet-all");
              const newProductCardHtml = `<div class="cart-block__item js-cart-item" data-id="${prodId}">
                                                  <div class="cart-block__item-img">
                                                      <label class="cart-block__item-img-check">
                                                          <input class="cart-block__item-img-check-input js-product-check" type="checkbox" name="${currentProductNameText}" id="${prodId}"
                                                              data-price="${Number(currentProductPriceSumm.replace(/\s/g, ""))}" data-id="${prodId}" data-stock="${stockPrice}">
                                                          <div class="cart-block__item-img-check-checked">
                                                              <svg class="icon checked" width="14px" height="14px">
                                                                  <use xlink:href="/local/templates/DoBuy/assets/images/sprite.svg#checked"></use>
                                                              </svg>
                                                          </div>
                                                      </label>
                                                      <a href="${currentProductHref}">
                                                          <div class="cart-block__item-img-image"><img src="${currentProductSrc}"></div>
                                                      </a>
                                                  </div>
                                                  <div class="cart-block__item-inner">
                                                      <a href="${currentProductHref}"
                                                          class="cart-block__item-inner-title">${currentProductNameText}</a>
                                                      <div class="cart-block__item-inner-body">
                                                          <div class="cart-block__item-inner-count" data-id="${prodId}">
                                                              <button class="cart-block__item-inner-count-decr js-btn-decr" disabled="true"></button>
                                                              <input class="cart-block__item-inner-count-counter js-cart-counter js-number" type="text" value="1"
                                                                  maxlength="1" readonly="">
                                                              <button class="cart-block__item-inner-count-incr js-btn-incr"></button>
                                                          </div>
                                                          <div class="cart-block__item-inner-block">
                                                              <div class="cart-block__item-inner-block-summ">
                                                                  <p class="cart-block__item-inner-block-summ-price">
                                                                      <span>${currentProductPriceSumm}</span> \u20BD
                                                                  </p>
                                                                  ${currentProductPercent ? `<div class="cart-block__item-inner-block-summ-price-old">
                                                                      <p class="cart-block__item-inner-block-summ-price-old-summ">${currentProductPriceOldSumm}</p>
                                                                      <p class="cart-block__item-inner-block-summ-price-old-stock">${currentProductPercentText}</p>
                                                                    </div>` : ""}
                                                              </div>
                                                              <div class="cart-block__item-inner-block-btns" data-id="${prodId}">
                                                                  <button class="cart-block__item-inner-block-btns-favorite js-favorite ${currentCardFavorite.classList.contains("is-active") ? "is-active" : ""}" data-id="${prodId}">
                                                                      <svg class="icon favorite" width="30px" height="30px" viewBox="0 0 30 30" fill="none"
                                                                          xmlns="http://www.w3.org/2000/svg">
                                                                          <path
                                                                              d="M23.1003 6.48251C23.8667 6.80107 24.5629 7.26797 25.1494 7.85655C25.7361 8.44486 26.2015 9.14336 26.519 9.91216C26.8366 10.681 27 11.505 27 12.3372C27 13.1694 26.8366 13.9934 26.519 14.7622C26.2015 15.531 25.7361 16.2295 25.1494 16.8178L23.9323 18.0387L17.8326 24.158C16.2695 25.7261 13.7299 25.7261 12.1667 24.158L6.06705 18.0387L4.85001 16.8178C3.66547 15.6295 3 14.0177 3 12.3372C3 10.6566 3.66547 9.04489 4.85001 7.85655C6.03455 6.66822 7.64114 6.00062 9.31633 6.00062C10.9915 6.00062 12.5981 6.66822 13.7826 7.85655C14.4542 8.53023 15.5452 8.53023 16.2167 7.85655C16.8032 7.26797 17.4994 6.80107 18.2658 6.48251C19.0321 6.16396 19.8535 6 20.6831 6C21.5126 6 22.334 6.16396 23.1003 6.48251Z"
                                                                              stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                                                          </path>
                                                                      </svg>
                                                                  </button>
                                                                  <button class="cart-block__item-inner-block-btns-del js-delet-cart-item">
                                                                      <svg class="icon delete" width="30px" height="30px">
                                                                          <use xlink:href="/local/templates/DoBuy/assets/images/sprite.svg#delete"></use>
                                                                      </svg>
                                                                  </button>
                                                              </div>
                                                          </div>
                                                      </div>
                                                  </div>
                                              </div>`;
              cartPageWrapper.innerHTML = cartPageWrapper.innerHTML;
              !!cartDelCheckedBtn && cartDelCheckedBtn.replaceWith(cartDelCheckedBtn.cloneNode(true));
              !!cartDelAllBtn && cartDelAllBtn.replaceWith(cartDelAllBtn.cloneNode(true));
              if (!!cartTitleCounter) {
                cartTitleCounter.textContent = Number(cartTitleCounter.textContent) + 1;
              }
              if (!!cartCheckAllBtn) {
                cartCheckAllBtn.checked = false;
              }
              cartPageWrapper.insertAdjacentHTML("beforeend", newProductCardHtml);
              !!emptyCartBlock && emptyCartBlock.remove();
              cartPageBlock.classList.remove("is-empty");
              cartPageCount();
            }
            handleCartPopup("addItemToBasket");
          }
        }).catch(function(error) {
        });
      }
    }
  });

  // src/components/brands-page/brands-main/brands-main.js
  var searchInput2 = document.querySelector(".brands-page .brands-filter__input");
  !!searchInput2 && searchInput2.addEventListener("input", function(e2) {
    const categories = document.querySelectorAll(".js-brands-category");
    const brands = document.querySelectorAll(".brands-page__body-list-item-name");
    !!brands.length && brands.forEach((el) => {
      const textContent = el.textContent;
      if (this.value.trim()) {
        if (el.textContent.toLocaleLowerCase().includes(this.value.toLocaleLowerCase())) {
          el.innerHTML = el.textContent.toLocaleLowerCase().replace(this.value.toLocaleLowerCase(), `<mark>${this.value.toLocaleLowerCase()}</mark>`);
          el.parentElement.classList.remove("is-hidden");
        } else {
          el.parentElement.classList.add("is-hidden");
        }
      } else {
        el.textContent = textContent;
        el.parentElement.classList.remove("is-hidden");
      }
    });
    !!categories.length && categories.forEach((category) => {
      if (this.value.trim()) {
        const labelsAll = category.querySelectorAll(".brands-page__body-list-item");
        const labels = [...labelsAll].map((el) => !el.classList.contains("is-hidden")).filter((el) => el);
        !labels.length ? category.classList.add("is-hidden") : category.classList.remove("is-hidden");
      } else {
        category.classList.remove("is-hidden");
      }
    });
    const categoriesShow = [...categories].map((el) => !el.classList.contains("is-hidden")).filter((el) => el);
    const brandsWrap = document.querySelector(".brands-page__body");
    const brandsNotFoundText = document.querySelectorAll(".brands-page__not-found");
    !!brandsNotFoundText.length && brandsNotFoundText.forEach((el) => el.remove());
    const textVotFoundBrands = '<p class="brands-page__not-found">\u041A \u0441\u043E\u0436\u0430\u043B\u0435\u043D\u0438\u044E, \u043D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E</p>';
    !categoriesShow.length ? brandsWrap.insertAdjacentHTML("beforeend", textVotFoundBrands) : !!brandsNotFoundText.length && brandsNotFoundText[0].remove();
  });

  // src/components/about/about.js
  var cartPopupEl2 = document.querySelectorAll(".about__block-body");
  cartPopupEl2.length > 0 && cartPopupEl2.forEach((el) => {
    new perfect_scrollbar_esm_default(el, {
      wheelSpeed: 2,
      wheelPropagation: true,
      minScrollbarLength: 20
    });
  });

  // src/components/pagination/pagination.js
  var filterPriceMinInput = document.querySelector(`.min-price`);
  var filterPriceMaxInput = document.querySelector(`.max-price`);
  function removeFilterPriceTag() {
    if (!!filterPriceMinInput && !!filterPriceMaxInput) {
      const filterTagPrice2 = document.querySelector(".js-filter-tag-price");
      const filterPriceMinInputInitialValue = Number(filterPriceMinInput.getAttribute("value"));
      const filterPriceMaxInputInitialValue = Number(filterPriceMaxInput.getAttribute("value"));
      const filterPriceMinInputValue = Number(filterPriceMinInput.value);
      const filterPriceMaxInputValue = Number(filterPriceMaxInput.value);
      if (!!filterTagPrice2 && filterPriceMinInputInitialValue === filterPriceMinInputValue && filterPriceMaxInputInitialValue === filterPriceMaxInputValue) {
        filterTagPrice2.remove();
      }
    }
  }
  document.addEventListener("click", (e2) => {
    const paginationItem = e2.target.closest(".pagination__item");
    if (paginationItem) {
      setTimeout(() => {
        removeFilterPriceTag();
        document.documentElement.scrollIntoView({ block: "start", behavior: "smooth" });
      }, 500);
    }
  });

  // src/components/catalog-tags/catalog-tags.js
  var filterCatalogTags = document.querySelectorAll(".js-tag-remove-btn");
  var smartFilterFormBtn = document.querySelector(".smart-filter-form .filter-products__btn");
  var smartFilterPriceSlider = document.querySelector(".js-range-filter");
  var filterTagPrice = document.querySelector(".js-filter-tag-price");
  !!filterCatalogTags.length && document.addEventListener("click", (event2) => {
    removePriceDeleteSortBtn();
    const tag = event2.target.closest(".js-tag-remove-btn");
    if (!!tag) {
      const id = tag.getAttribute("data-id");
      const filterInput = document.querySelector(`.js-checkbox-filter#${id}`);
      const filterPriceMinInput2 = document.querySelector(`.min-price#${id}_MIN`);
      const filterPriceMaxInput2 = document.querySelector(`.max-price#${id}_MAX`);
      const filterPriceMinInputInitialValue = !!filterPriceMinInput2 && Number(filterPriceMinInput2.getAttribute("value"));
      const filterPriceMaxInputInitialValue = !!filterPriceMaxInput2 && Number(filterPriceMaxInput2.getAttribute("value"));
      if (!!filterInput) {
        filterInput.checked = false;
        !!smartFilterFormBtn && smartFilterFormBtn.click();
      }
      if (!!filterPriceMinInput2 || !!filterPriceMaxInput2) {
        const url2 = new URL(document.location);
        const searchParams = url2.searchParams;
        searchParams.delete(`${id}_MAX`);
        searchParams.delete(`${id}_MIN`);
        window.history.pushState({}, "", url2.toString());
        smartFilterPriceSlider.noUiSlider.updateOptions({
          range: {
            "min": filterPriceMinInputInitialValue,
            "max": filterPriceMaxInputInitialValue
          },
          start: [filterPriceMinInputInitialValue, filterPriceMaxInputInitialValue]
        });
        !!smartFilterFormBtn && smartFilterFormBtn.click();
      }
    }
  });
  var removePriceDeleteSortBtn = () => {
    filterCatalogTags.forEach((tag) => {
      const id = tag.getAttribute("data-id");
      const filterPriceMinInput2 = document.querySelector(`.min-price#${id}_MIN`);
      const filterPriceMaxInput2 = document.querySelector(`.max-price#${id}_MAX`);
      const filterPriceMinInputInitialValue = !!filterPriceMinInput2 && Number(filterPriceMinInput2.getAttribute("value"));
      const filterPriceMaxInputInitialValue = !!filterPriceMaxInput2 && Number(filterPriceMaxInput2.getAttribute("value"));
      const filterPriceMinInputValue = !!filterPriceMinInput2 && Number(filterPriceMinInput2.value);
      const filterPriceMaxInputValue = !!filterPriceMaxInput2 && Number(filterPriceMaxInput2.value);
      if (!!filterPriceMinInput2 && !!filterPriceMaxInput2 && filterPriceMinInputInitialValue === filterPriceMinInputValue && filterPriceMaxInputInitialValue === filterPriceMaxInputValue) {
        !!filterTagPrice && filterTagPrice.remove();
      }
    });
  };
  !!filterCatalogTags.length && removePriceDeleteSortBtn();

  // src/components/breadcrumbs/breadcrumbs.js
  var breadcrumbsWrapper = document.querySelector(".breadcrumbs__wrap");
  !!breadcrumbsWrapper && new perfect_scrollbar_esm_default(breadcrumbsWrapper, {
    wheelSpeed: 2,
    wheelPropagation: true,
    suppressScrollY: true
  });

  // src/js/main.js
  document.addEventListener("click", (e2) => {
    const btnShowCharacters = e2.target.closest(".js-scroll-button");
    if (btnShowCharacters) {
      e2.preventDefault();
      const btnShowCharactersHref = btnShowCharacters.getAttribute("href");
      const tabToClick = document.querySelector(btnShowCharactersHref);
      tabToClick.click();
      let top = tabToClick.getBoundingClientRect().top;
      let left = tabToClick.getBoundingClientRect().left;
      let headerHight = document.querySelector("header.header").offsetHeight;
      let scroll2 = top - headerHight;
      window.scrollBy({ top: scroll2, behavior: "smooth" });
      if (btnShowCharacters.classList.contains("product-detail-main__rating-link") || btnShowCharacters.classList.contains("product-detail-main__spec-more")) {
        const containerTabs = document.querySelector(".js-tabs-container");
        !!containerTabs && containerTabs.scrollBy({ left: left - 20, behavior: "smooth" });
      }
    }
  });
})();
/*!
 * dist/inputmask
 * https://github.com/RobinHerbots/Inputmask
 * Copyright (c) 2010 - 2021 Robin Herbots
 * Licensed under the MIT license
 * Version: 5.0.7
 */
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
/*! rater-js. [c] 2018 Fredrik Olsson. MIT License */
//# sourceMappingURL=index.js.map
